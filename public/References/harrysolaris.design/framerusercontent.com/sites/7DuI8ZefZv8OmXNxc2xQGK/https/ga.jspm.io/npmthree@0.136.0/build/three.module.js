/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const e="136";const t={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};const n={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};const r=0;const i=1;const s=2;const a=3;const o=0;const l=1;const c=2;const u=3;const h=0;const d=1;const p=2;const f=1;const m=2;const g=0;const y=1;const x=2;const b=3;const _=4;const M=5;const w=100;const S=101;const T=102;const E=103;const A=104;const L=200;const C=201;const R=202;const P=203;const I=204;const D=205;const B=206;const V=207;const N=208;const U=209;const z=210;const G=0;const F=1;const O=2;const H=3;const k=4;const W=5;const j=6;const q=7;const X=0;const J=1;const Y=2;const Z=0;const Q=1;const K=2;const $=3;const ee=4;const te=5;const ne=300;const re=301;const ie=302;const se=303;const ae=304;const oe=306;const le=307;const ce=1e3;const ue=1001;const he=1002;const de=1003;const pe=1004;const fe=1004;const me=1005;const ge=1005;const ye=1006;const ve=1007;const xe=1007;const be=1008;const _e=1008;const Me=1009;const we=1010;const Se=1011;const Te=1012;const Ee=1013;const Ae=1014;const Le=1015;const Ce=1016;const Re=1017;const Pe=1018;const Ie=1019;const De=1020;const Be=1021;const Ve=1022;const Ne=1023;const Ue=1024;const ze=1025;const Ge=1026;const Fe=1027;const Oe=1028;const He=1029;const ke=1030;const We=1031;const je=1032;const qe=1033;const Xe=33776;const Je=33777;const Ye=33778;const Ze=33779;const Qe=35840;const Ke=35841;const $e=35842;const et=35843;const tt=36196;const nt=37492;const rt=37496;const it=37808;const st=37809;const at=37810;const ot=37811;const lt=37812;const ct=37813;const ut=37814;const ht=37815;const dt=37816;const pt=37817;const ft=37818;const mt=37819;const gt=37820;const yt=37821;const vt=36492;const xt=37840;const bt=37841;const _t=37842;const Mt=37843;const wt=37844;const St=37845;const Tt=37846;const Et=37847;const At=37848;const Lt=37849;const Ct=37850;const Rt=37851;const Pt=37852;const It=37853;const Dt=2200;const Bt=2201;const Vt=2202;const Nt=2300;const Ut=2301;const zt=2302;const Gt=2400;const Ft=2401;const Ot=2402;const Ht=2500;const kt=2501;const Wt=0;const jt=1;const qt=2;const Xt=3e3;const Jt=3001;const Yt=3200;const Zt=3201;const Qt=0;const Kt=1;const $t=0;const en=7680;const tn=7681;const nn=7682;const rn=7683;const sn=34055;const an=34056;const on=5386;const ln=512;const cn=513;const un=514;const hn=515;const dn=516;const pn=517;const fn=518;const mn=519;const gn=35044;const yn=35048;const vn=35040;const xn=35045;const bn=35049;const _n=35041;const Mn=35046;const wn=35050;const Sn=35042;const Tn="100";const En="300 es";class EventDispatcher{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]);-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return false;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const n=this._listeners;const r=n[e];if(void 0!==r){const e=r.indexOf(t);-1!==e&&r.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners;const n=t[e.type];if(void 0!==n){e.target=this;const t=n.slice(0);for(let n=0,r=t.length;n<r;n++)t[n].call(this,e);e.target=null}}}const An=[];for(let e=0;e<256;e++)An[e]=(e<16?"0":"")+e.toString(16);let Ln=1234567;const Cn=Math.PI/180;const Rn=180/Math.PI;function generateUUID(){const e=4294967295*Math.random()|0;const t=4294967295*Math.random()|0;const n=4294967295*Math.random()|0;const r=4294967295*Math.random()|0;const i=An[255&e]+An[e>>8&255]+An[e>>16&255]+An[e>>24&255]+"-"+An[255&t]+An[t>>8&255]+"-"+An[t>>16&15|64]+An[t>>24&255]+"-"+An[63&n|128]+An[n>>8&255]+"-"+An[n>>16&255]+An[n>>24&255]+An[255&r]+An[r>>8&255]+An[r>>16&255]+An[r>>24&255];return i.toUpperCase()}function clamp(e,t,n){return Math.max(t,Math.min(n,e))}function euclideanModulo(e,t){return(e%t+t)%t}function mapLinear(e,t,n,r,i){return r+(e-t)*(i-r)/(n-t)}function inverseLerp(e,t,n){return e!==t?(n-e)/(t-e):0}function lerp(e,t,n){return(1-n)*e+n*t}function damp(e,t,n,r){return lerp(e,t,1-Math.exp(-n*r))}function pingpong(e,t=1){return t-Math.abs(euclideanModulo(e,2*t)-t)}function smoothstep(e,t,n){if(e<=t)return 0;if(e>=n)return 1;e=(e-t)/(n-t);return e*e*(3-2*e)}function smootherstep(e,t,n){if(e<=t)return 0;if(e>=n)return 1;e=(e-t)/(n-t);return e*e*e*(e*(6*e-15)+10)}function randInt(e,t){return e+Math.floor(Math.random()*(t-e+1))}function randFloat(e,t){return e+Math.random()*(t-e)}function randFloatSpread(e){return e*(.5-Math.random())}function seededRandom(e){void 0!==e&&(Ln=e%2147483647);Ln=16807*Ln%2147483647;return(Ln-1)/2147483646}function degToRad(e){return e*Cn}function radToDeg(e){return e*Rn}function isPowerOfTwo(e){return 0===(e&e-1)&&0!==e}function ceilPowerOfTwo(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function floorPowerOfTwo(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}function setQuaternionFromProperEuler(e,t,n,r,i){const s=Math.cos;const a=Math.sin;const o=s(n/2);const l=a(n/2);const c=s((t+r)/2);const u=a((t+r)/2);const h=s((t-r)/2);const d=a((t-r)/2);const p=s((r-t)/2);const f=a((r-t)/2);switch(i){case"XYX":e.set(o*u,l*h,l*d,o*c);break;case"YZY":e.set(l*d,o*u,l*h,o*c);break;case"ZXZ":e.set(l*h,l*d,o*u,o*c);break;case"XZX":e.set(o*u,l*f,l*p,o*c);break;case"YXY":e.set(l*p,o*u,l*f,o*c);break;case"ZYZ":e.set(l*f,l*p,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}var Pn=Object.freeze({__proto__:null,DEG2RAD:Cn,RAD2DEG:Rn,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad,radToDeg:radToDeg,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler});class Vector2{constructor(e=0,t=0){this.x=e;this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){this.x=e;this.y=t;return this}setScalar(e){this.x=e;this.y=e;return this}setX(e){this.x=e;return this}setY(e){this.y=e;return this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){this.x=e.x;this.y=e.y;return this}add(e,t){if(void 0!==t){console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");return this.addVectors(e,t)}this.x+=e.x;this.y+=e.y;return this}addScalar(e){this.x+=e;this.y+=e;return this}addVectors(e,t){this.x=e.x+t.x;this.y=e.y+t.y;return this}addScaledVector(e,t){this.x+=e.x*t;this.y+=e.y*t;return this}sub(e,t){if(void 0!==t){console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");return this.subVectors(e,t)}this.x-=e.x;this.y-=e.y;return this}subScalar(e){this.x-=e;this.y-=e;return this}subVectors(e,t){this.x=e.x-t.x;this.y=e.y-t.y;return this}multiply(e){this.x*=e.x;this.y*=e.y;return this}multiplyScalar(e){this.x*=e;this.y*=e;return this}divide(e){this.x/=e.x;this.y/=e.y;return this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y;const r=e.elements;this.x=r[0]*t+r[3]*n+r[6];this.y=r[1]*t+r[4]*n+r[7];return this}min(e){this.x=Math.min(this.x,e.x);this.y=Math.min(this.y,e.y);return this}max(e){this.x=Math.max(this.x,e.x);this.y=Math.max(this.y,e.y);return this}clamp(e,t){this.x=Math.max(e.x,Math.min(t.x,this.x));this.y=Math.max(e.y,Math.min(t.y,this.y));return this}clampScalar(e,t){this.x=Math.max(e,Math.min(t,this.x));this.y=Math.max(e,Math.min(t,this.y));return this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this}negate(){this.x=-this.x;this.y=-this.y;return this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const e=Math.atan2(-this.y,-this.x)+Math.PI;return e}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){this.x+=(e.x-this.x)*t;this.y+=(e.y-this.y)*t;return this}lerpVectors(e,t,n){this.x=e.x+(t.x-e.x)*n;this.y=e.y+(t.y-e.y)*n;return this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){this.x=e[t];this.y=e[t+1];return this}toArray(e=[],t=0){e[t]=this.x;e[t+1]=this.y;return e}fromBufferAttribute(e,t,n){void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");this.x=e.getX(t);this.y=e.getY(t);return this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t);const i=this.x-e.x;const s=this.y-e.y;this.x=i*n-s*r+e.x;this.y=i*r+s*n+e.y;return this}random(){this.x=Math.random();this.y=Math.random();return this}*[Symbol.iterator](){yield this.x;yield this.y}}Vector2.prototype.isVector2=true;class Matrix3{constructor(){this.elements=[1,0,0,0,1,0,0,0,1];arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l){const c=this.elements;c[0]=e;c[1]=r;c[2]=a;c[3]=t;c[4]=i;c[5]=o;c[6]=n;c[7]=s;c[8]=l;return this}identity(){this.set(1,0,0,0,1,0,0,0,1);return this}copy(e){const t=this.elements;const n=e.elements;t[0]=n[0];t[1]=n[1];t[2]=n[2];t[3]=n[3];t[4]=n[4];t[5]=n[5];t[6]=n[6];t[7]=n[7];t[8]=n[8];return this}extractBasis(e,t,n){e.setFromMatrix3Column(this,0);t.setFromMatrix3Column(this,1);n.setFromMatrix3Column(this,2);return this}setFromMatrix4(e){const t=e.elements;this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]);return this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements;const r=t.elements;const i=this.elements;const s=n[0],a=n[3],o=n[6];const l=n[1],c=n[4],u=n[7];const h=n[2],d=n[5],p=n[8];const f=r[0],m=r[3],g=r[6];const y=r[1],x=r[4],b=r[7];const _=r[2],M=r[5],w=r[8];i[0]=s*f+a*y+o*_;i[3]=s*m+a*x+o*M;i[6]=s*g+a*b+o*w;i[1]=l*f+c*y+u*_;i[4]=l*m+c*x+u*M;i[7]=l*g+c*b+u*w;i[2]=h*f+d*y+p*_;i[5]=h*m+d*x+p*M;i[8]=h*g+d*b+p*w;return this}multiplyScalar(e){const t=this.elements;t[0]*=e;t[3]*=e;t[6]*=e;t[1]*=e;t[4]*=e;t[7]*=e;t[2]*=e;t[5]*=e;t[8]*=e;return this}determinant(){const e=this.elements;const t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8];return t*s*c-t*a*l-n*i*c+n*a*o+r*i*l-r*s*o}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=c*s-a*l,h=a*o-c*i,d=l*i-s*o,p=t*u+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;e[0]=u*f;e[1]=(r*l-c*n)*f;e[2]=(a*n-r*s)*f;e[3]=h*f;e[4]=(c*t-r*o)*f;e[5]=(r*i-a*t)*f;e[6]=d*f;e[7]=(n*o-l*t)*f;e[8]=(s*t-n*i)*f;return this}transpose(){let e;const t=this.elements;e=t[1];t[1]=t[3];t[3]=e;e=t[2];t[2]=t[6];t[6]=e;e=t[5];t[5]=t[7];t[7]=e;return this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;e[0]=t[0];e[1]=t[3];e[2]=t[6];e[3]=t[1];e[4]=t[4];e[5]=t[7];e[6]=t[2];e[7]=t[5];e[8]=t[8];return this}setUvTransform(e,t,n,r,i,s,a){const o=Math.cos(i);const l=Math.sin(i);this.set(n*o,n*l,-n*(o*s+l*a)+s+e,-r*l,r*o,-r*(-l*s+o*a)+a+t,0,0,1);return this}scale(e,t){const n=this.elements;n[0]*=e;n[3]*=e;n[6]*=e;n[1]*=t;n[4]*=t;n[7]*=t;return this}rotate(e){const t=Math.cos(e);const n=Math.sin(e);const r=this.elements;const i=r[0],s=r[3],a=r[6];const o=r[1],l=r[4],c=r[7];r[0]=t*i+n*o;r[3]=t*s+n*l;r[6]=t*a+n*c;r[1]=-n*i+t*o;r[4]=-n*s+t*l;r[7]=-n*a+t*c;return this}translate(e,t){const n=this.elements;n[0]+=e*n[2];n[3]+=e*n[5];n[6]+=e*n[8];n[1]+=t*n[2];n[4]+=t*n[5];n[7]+=t*n[8];return this}equals(e){const t=this.elements;const n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return false;return true}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;e[t]=n[0];e[t+1]=n[1];e[t+2]=n[2];e[t+3]=n[3];e[t+4]=n[4];e[t+5]=n[5];e[t+6]=n[6];e[t+7]=n[7];e[t+8]=n[8];return e}clone(){return(new this.constructor).fromArray(this.elements)}}Matrix3.prototype.isMatrix3=true;function arrayMax(e){if(0===e.length)return-Infinity;let t=e[0];for(let n=1,r=e.length;n<r;++n)e[n]>t&&(t=e[n]);return t}const In={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function getTypedArray(e,t){return new In[e](t)}function createElementNS(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}let Dn;class ImageUtils{static getDataURL(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===Dn&&(Dn=createElementNS("canvas"));Dn.width=e.width;Dn.height=e.height;const n=Dn.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height);t=Dn}if(t.width>2048||t.height>2048){console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e);return t.toDataURL("image/jpeg",.6)}return t.toDataURL("image/png")}}let Bn=0;class Texture extends EventDispatcher{constructor(e=Texture.DEFAULT_IMAGE,t=Texture.DEFAULT_MAPPING,n=ue,r=ue,i=ye,s=be,a=Ne,o=Me,l=1,c=Xt){super();Object.defineProperty(this,"id",{value:Bn++});this.uuid=generateUUID();this.name="";this.image=e;this.mipmaps=[];this.mapping=t;this.wrapS=n;this.wrapT=r;this.magFilter=i;this.minFilter=s;this.anisotropy=l;this.format=a;this.internalFormat=null;this.type=o;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3;this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;this.encoding=c;this.userData={};this.version=0;this.onUpdate=null;this.isRenderTargetTexture=false}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name;this.image=e.image;this.mipmaps=e.mipmaps.slice(0);this.mapping=e.mapping;this.wrapS=e.wrapS;this.wrapT=e.wrapT;this.magFilter=e.magFilter;this.minFilter=e.minFilter;this.anisotropy=e.anisotropy;this.format=e.format;this.internalFormat=e.internalFormat;this.type=e.type;this.offset.copy(e.offset);this.repeat.copy(e.repeat);this.center.copy(e.center);this.rotation=e.rotation;this.matrixAutoUpdate=e.matrixAutoUpdate;this.matrix.copy(e.matrix);this.generateMipmaps=e.generateMipmaps;this.premultiplyAlpha=e.premultiplyAlpha;this.flipY=e.flipY;this.unpackAlignment=e.unpackAlignment;this.encoding=e.encoding;this.userData=JSON.parse(JSON.stringify(e.userData));return this}toJSON(e){const t=void 0===e||"string"===typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const r=this.image;void 0===r.uuid&&(r.uuid=generateUUID());if(!t&&void 0===e.images[r.uuid]){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(serializeImage(r[e].image)):t.push(serializeImage(r[e]))}else t=serializeImage(r);e.images[r.uuid]={uuid:r.uuid,url:t}}n.image=r.uuid}"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData);t||(e.textures[this.uuid]=n);return n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==ne)return e;e.applyMatrix3(this.matrix);if(e.x<0||e.x>1)switch(this.wrapS){case ce:e.x=e.x-Math.floor(e.x);break;case ue:e.x=e.x<0?0:1;break;case he:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case ce:e.y=e.y-Math.floor(e.y);break;case ue:e.y=e.y<0?0:1;break;case he:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}this.flipY&&(e.y=1-e.y);return e}set needsUpdate(e){true===e&&this.version++}}Texture.DEFAULT_IMAGE=void 0;Texture.DEFAULT_MAPPING=ne;Texture.prototype.isTexture=true;function serializeImage(e){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap)return ImageUtils.getDataURL(e);if(e.data)return{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name};console.warn("THREE.Texture: Unable to serialize Texture.");return{}}class Vector4{constructor(e=0,t=0,n=0,r=1){this.x=e;this.y=t;this.z=n;this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){this.x=e;this.y=t;this.z=n;this.w=r;return this}setScalar(e){this.x=e;this.y=e;this.z=e;this.w=e;return this}setX(e){this.x=e;return this}setY(e){this.y=e;return this}setZ(e){this.z=e;return this}setW(e){this.w=e;return this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){this.x=e.x;this.y=e.y;this.z=e.z;this.w=void 0!==e.w?e.w:1;return this}add(e,t){if(void 0!==t){console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");return this.addVectors(e,t)}this.x+=e.x;this.y+=e.y;this.z+=e.z;this.w+=e.w;return this}addScalar(e){this.x+=e;this.y+=e;this.z+=e;this.w+=e;return this}addVectors(e,t){this.x=e.x+t.x;this.y=e.y+t.y;this.z=e.z+t.z;this.w=e.w+t.w;return this}addScaledVector(e,t){this.x+=e.x*t;this.y+=e.y*t;this.z+=e.z*t;this.w+=e.w*t;return this}sub(e,t){if(void 0!==t){console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");return this.subVectors(e,t)}this.x-=e.x;this.y-=e.y;this.z-=e.z;this.w-=e.w;return this}subScalar(e){this.x-=e;this.y-=e;this.z-=e;this.w-=e;return this}subVectors(e,t){this.x=e.x-t.x;this.y=e.y-t.y;this.z=e.z-t.z;this.w=e.w-t.w;return this}multiply(e){this.x*=e.x;this.y*=e.y;this.z*=e.z;this.w*=e.w;return this}multiplyScalar(e){this.x*=e;this.y*=e;this.z*=e;this.w*=e;return this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=this.w;const s=e.elements;this.x=s[0]*t+s[4]*n+s[8]*r+s[12]*i;this.y=s[1]*t+s[5]*n+s[9]*r+s[13]*i;this.z=s[2]*t+s[6]*n+s[10]*r+s[14]*i;this.w=s[3]*t+s[7]*n+s[11]*r+s[15]*i;return this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);if(t<1e-4){this.x=1;this.y=0;this.z=0}else{this.x=e.x/t;this.y=e.y/t;this.z=e.z/t}return this}setAxisAngleFromRotationMatrix(e){let t,n,r,i;const s=.01,a=.1,o=e.elements,l=o[0],c=o[4],u=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<a&&Math.abs(u+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a){this.set(1,0,0,0);return this}t=Math.PI;const e=(l+1)/2;const o=(d+1)/2;const y=(g+1)/2;const x=(c+h)/4;const b=(u+f)/4;const _=(p+m)/4;if(e>o&&e>y)if(e<s){n=0;r=.707106781;i=.707106781}else{n=Math.sqrt(e);r=x/n;i=b/n}else if(o>y)if(o<s){n=.707106781;r=0;i=.707106781}else{r=Math.sqrt(o);n=x/r;i=_/r}else if(y<s){n=.707106781;r=.707106781;i=0}else{i=Math.sqrt(y);n=b/i;r=_/i}this.set(n,r,i,t);return this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));Math.abs(y)<.001&&(y=1);this.x=(m-p)/y;this.y=(u-f)/y;this.z=(h-c)/y;this.w=Math.acos((l+d+g-1)/2);return this}min(e){this.x=Math.min(this.x,e.x);this.y=Math.min(this.y,e.y);this.z=Math.min(this.z,e.z);this.w=Math.min(this.w,e.w);return this}max(e){this.x=Math.max(this.x,e.x);this.y=Math.max(this.y,e.y);this.z=Math.max(this.z,e.z);this.w=Math.max(this.w,e.w);return this}clamp(e,t){this.x=Math.max(e.x,Math.min(t.x,this.x));this.y=Math.max(e.y,Math.min(t.y,this.y));this.z=Math.max(e.z,Math.min(t.z,this.z));this.w=Math.max(e.w,Math.min(t.w,this.w));return this}clampScalar(e,t){this.x=Math.max(e,Math.min(t,this.x));this.y=Math.max(e,Math.min(t,this.y));this.z=Math.max(e,Math.min(t,this.z));this.w=Math.max(e,Math.min(t,this.w));return this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){this.x+=(e.x-this.x)*t;this.y+=(e.y-this.y)*t;this.z+=(e.z-this.z)*t;this.w+=(e.w-this.w)*t;return this}lerpVectors(e,t,n){this.x=e.x+(t.x-e.x)*n;this.y=e.y+(t.y-e.y)*n;this.z=e.z+(t.z-e.z)*n;this.w=e.w+(t.w-e.w)*n;return this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){this.x=e[t];this.y=e[t+1];this.z=e[t+2];this.w=e[t+3];return this}toArray(e=[],t=0){e[t]=this.x;e[t+1]=this.y;e[t+2]=this.z;e[t+3]=this.w;return e}fromBufferAttribute(e,t,n){void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");this.x=e.getX(t);this.y=e.getY(t);this.z=e.getZ(t);this.w=e.getW(t);return this}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;yield this.w}}Vector4.prototype.isVector4=true;class WebGLRenderTarget extends EventDispatcher{constructor(e,t,n={}){super();this.width=e;this.height=t;this.depth=1;this.scissor=new Vector4(0,0,e,t);this.scissorTest=false;this.viewport=new Vector4(0,0,e,t);this.texture=new Texture(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding);this.texture.isRenderTargetTexture=true;this.texture.image={width:e,height:t,depth:1};this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps;this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null;this.texture.minFilter=void 0!==n.minFilter?n.minFilter:ye;this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer;this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer;this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth};this.texture=e}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e;this.height=t;this.depth=n;this.texture.image.width=e;this.texture.image.height=t;this.texture.image.depth=n;this.dispose()}this.viewport.set(0,0,e,t);this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width;this.height=e.height;this.depth=e.depth;this.viewport.copy(e.viewport);this.texture=e.texture.clone();this.texture.image={...this.texture.image};this.depthBuffer=e.depthBuffer;this.stencilBuffer=e.stencilBuffer;this.depthTexture=e.depthTexture;return this}dispose(){this.dispatchEvent({type:"dispose"})}}WebGLRenderTarget.prototype.isWebGLRenderTarget=true;class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(e,t,n){super(e,t);const r=this.texture;this.texture=[];for(let e=0;e<n;e++)this.texture[e]=r.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e;this.height=t;this.depth=n;for(let r=0,i=this.texture.length;r<i;r++){this.texture[r].image.width=e;this.texture[r].image.height=t;this.texture[r].image.depth=n}this.dispose()}this.viewport.set(0,0,e,t);this.scissor.set(0,0,e,t);return this}copy(e){this.dispose();this.width=e.width;this.height=e.height;this.depth=e.depth;this.viewport.set(0,0,this.width,this.height);this.scissor.set(0,0,this.width,this.height);this.depthBuffer=e.depthBuffer;this.stencilBuffer=e.stencilBuffer;this.depthTexture=e.depthTexture;this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets=true;class WebGLMultisampleRenderTarget extends WebGLRenderTarget{constructor(e,t,n={}){super(e,t,n);this.samples=4;this.ignoreDepthForMultisampleCopy=void 0===n.ignoreDepth||n.ignoreDepth;this.useRenderToTexture=void 0!==n.useRenderToTexture&&n.useRenderToTexture;this.useRenderbuffer=false===this.useRenderToTexture}copy(e){super.copy.call(this,e);this.samples=e.samples;this.useRenderToTexture=e.useRenderToTexture;this.useRenderbuffer=e.useRenderbuffer;return this}}WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget=true;class Quaternion{constructor(e=0,t=0,n=0,r=1){this._x=e;this._y=t;this._z=n;this._w=r}static slerp(e,t,n,r){console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");return n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,i,s,a){let o=n[r+0],l=n[r+1],c=n[r+2],u=n[r+3];const h=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0!==a)if(1!==a){if(u!==f||o!==h||l!==d||c!==p){let e=1-a;const t=o*h+l*d+c*p+u*f,n=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,t*n);e=Math.sin(e*s)/i;a=Math.sin(a*s)/i}const i=a*n;o=o*e+h*i;l=l*e+d*i;c=c*e+p*i;u=u*e+f*i;if(e===1-a){const e=1/Math.sqrt(o*o+l*l+c*c+u*u);o*=e;l*=e;c*=e;u*=e}}e[t]=o;e[t+1]=l;e[t+2]=c;e[t+3]=u}else{e[t+0]=h;e[t+1]=d;e[t+2]=p;e[t+3]=f}else{e[t+0]=o;e[t+1]=l;e[t+2]=c;e[t+3]=u}}static multiplyQuaternionsFlat(e,t,n,r,i,s){const a=n[r];const o=n[r+1];const l=n[r+2];const c=n[r+3];const u=i[s];const h=i[s+1];const d=i[s+2];const p=i[s+3];e[t]=a*p+c*u+o*d-l*h;e[t+1]=o*p+c*h+l*u-a*d;e[t+2]=l*p+c*d+a*h-o*u;e[t+3]=c*p-a*u-o*h-l*d;return e}get x(){return this._x}set x(e){this._x=e;this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e;this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e;this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e;this._onChangeCallback()}set(e,t,n,r){this._x=e;this._y=t;this._z=n;this._w=r;this._onChangeCallback();return this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){this._x=e.x;this._y=e.y;this._z=e.z;this._w=e.w;this._onChangeCallback();return this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,i=e._z,s=e._order;const a=Math.cos;const o=Math.sin;const l=a(n/2);const c=a(r/2);const u=a(i/2);const h=o(n/2);const d=o(r/2);const p=o(i/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p;this._y=l*d*u-h*c*p;this._z=l*c*p+h*d*u;this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p;this._y=l*d*u-h*c*p;this._z=l*c*p-h*d*u;this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p;this._y=l*d*u+h*c*p;this._z=l*c*p+h*d*u;this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p;this._y=l*d*u+h*c*p;this._z=l*c*p-h*d*u;this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p;this._y=l*d*u+h*c*p;this._z=l*c*p-h*d*u;this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p;this._y=l*d*u-h*c*p;this._z=l*c*p+h*d*u;this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}false!==t&&this._onChangeCallback();return this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);this._x=e.x*r;this._y=e.y*r;this._z=e.z*r;this._w=Math.cos(n);this._onChangeCallback();return this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],i=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],u=t[10],h=n+a+u;if(h>0){const e=.5/Math.sqrt(h+1);this._w=.25/e;this._x=(c-o)*e;this._y=(i-l)*e;this._z=(s-r)*e}else if(n>a&&n>u){const e=2*Math.sqrt(1+n-a-u);this._w=(c-o)/e;this._x=.25*e;this._y=(r+s)/e;this._z=(i+l)/e}else if(a>u){const e=2*Math.sqrt(1+a-n-u);this._w=(i-l)/e;this._x=(r+s)/e;this._y=.25*e;this._z=(o+c)/e}else{const e=2*Math.sqrt(1+u-n-a);this._w=(s-r)/e;this._x=(i+l)/e;this._y=(o+c)/e;this._z=.25*e}this._onChangeCallback();return this}setFromUnitVectors(e,t){let n=e.dot(t)+1;if(n<Number.EPSILON){n=0;if(Math.abs(e.x)>Math.abs(e.z)){this._x=-e.y;this._y=e.x;this._z=0;this._w=n}else{this._x=0;this._y=-e.z;this._z=e.y;this._w=n}}else{this._x=e.y*t.z-e.z*t.y;this._y=e.z*t.x-e.x*t.z;this._z=e.x*t.y-e.y*t.x;this._w=n}return this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const r=Math.min(1,t/n);this.slerp(e,r);return this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();if(0===e){this._x=0;this._y=0;this._z=0;this._w=1}else{e=1/e;this._x=this._x*e;this._y=this._y*e;this._z=this._z*e;this._w=this._w*e}this._onChangeCallback();return this}multiply(e,t){if(void 0!==t){console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");return this.multiplyQuaternions(e,t)}return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,i=e._z,s=e._w;const a=t._x,o=t._y,l=t._z,c=t._w;this._x=n*c+s*a+r*l-i*o;this._y=r*c+s*o+i*a-n*l;this._z=i*c+s*l+n*o-r*a;this._w=s*c-n*a-r*o-i*l;this._onChangeCallback();return this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,r=this._y,i=this._z,s=this._w;let a=s*e._w+n*e._x+r*e._y+i*e._z;if(a<0){this._w=-e._w;this._x=-e._x;this._y=-e._y;this._z=-e._z;a=-a}else this.copy(e);if(a>=1){this._w=s;this._x=n;this._y=r;this._z=i;return this}const o=1-a*a;if(o<=Number.EPSILON){const e=1-t;this._w=e*s+t*this._w;this._x=e*n+t*this._x;this._y=e*r+t*this._y;this._z=e*i+t*this._z;this.normalize();this._onChangeCallback();return this}const l=Math.sqrt(o);const c=Math.atan2(l,a);const u=Math.sin((1-t)*c)/l,h=Math.sin(t*c)/l;this._w=s*u+this._w*h;this._x=n*u+this._x*h;this._y=r*u+this._y*h;this._z=i*u+this._z*h;this._onChangeCallback();return this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}random(){const e=Math.random();const t=Math.sqrt(1-e);const n=Math.sqrt(e);const r=2*Math.PI*Math.random();const i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(i),n*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){this._x=e[t];this._y=e[t+1];this._z=e[t+2];this._w=e[t+3];this._onChangeCallback();return this}toArray(e=[],t=0){e[t]=this._x;e[t+1]=this._y;e[t+2]=this._z;e[t+3]=this._w;return e}fromBufferAttribute(e,t){this._x=e.getX(t);this._y=e.getY(t);this._z=e.getZ(t);this._w=e.getW(t);return this}_onChange(e){this._onChangeCallback=e;return this}_onChangeCallback(){}}Quaternion.prototype.isQuaternion=true;class Vector3{constructor(e=0,t=0,n=0){this.x=e;this.y=t;this.z=n}set(e,t,n){void 0===n&&(n=this.z);this.x=e;this.y=t;this.z=n;return this}setScalar(e){this.x=e;this.y=e;this.z=e;return this}setX(e){this.x=e;return this}setY(e){this.y=e;return this}setZ(e){this.z=e;return this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){this.x=e.x;this.y=e.y;this.z=e.z;return this}add(e,t){if(void 0!==t){console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");return this.addVectors(e,t)}this.x+=e.x;this.y+=e.y;this.z+=e.z;return this}addScalar(e){this.x+=e;this.y+=e;this.z+=e;return this}addVectors(e,t){this.x=e.x+t.x;this.y=e.y+t.y;this.z=e.z+t.z;return this}addScaledVector(e,t){this.x+=e.x*t;this.y+=e.y*t;this.z+=e.z*t;return this}sub(e,t){if(void 0!==t){console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");return this.subVectors(e,t)}this.x-=e.x;this.y-=e.y;this.z-=e.z;return this}subScalar(e){this.x-=e;this.y-=e;this.z-=e;return this}subVectors(e,t){this.x=e.x-t.x;this.y=e.y-t.y;this.z=e.z-t.z;return this}multiply(e,t){if(void 0!==t){console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");return this.multiplyVectors(e,t)}this.x*=e.x;this.y*=e.y;this.z*=e.z;return this}multiplyScalar(e){this.x*=e;this.y*=e;this.z*=e;return this}multiplyVectors(e,t){this.x=e.x*t.x;this.y=e.y*t.y;this.z=e.z*t.z;return this}applyEuler(e){e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");return this.applyQuaternion(Nn.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Nn.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z;const i=e.elements;this.x=i[0]*t+i[3]*n+i[6]*r;this.y=i[1]*t+i[4]*n+i[7]*r;this.z=i[2]*t+i[5]*n+i[8]*r;return this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z;const i=e.elements;const s=1/(i[3]*t+i[7]*n+i[11]*r+i[15]);this.x=(i[0]*t+i[4]*n+i[8]*r+i[12])*s;this.y=(i[1]*t+i[5]*n+i[9]*r+i[13])*s;this.z=(i[2]*t+i[6]*n+i[10]*r+i[14])*s;return this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z;const i=e.x,s=e.y,a=e.z,o=e.w;const l=o*t+s*r-a*n;const c=o*n+a*t-i*r;const u=o*r+i*n-s*t;const h=-i*t-s*n-a*r;this.x=l*o+h*-i+c*-a-u*-s;this.y=c*o+h*-s+u*-i-l*-a;this.z=u*o+h*-a+l*-s-c*-i;return this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z;const i=e.elements;this.x=i[0]*t+i[4]*n+i[8]*r;this.y=i[1]*t+i[5]*n+i[9]*r;this.z=i[2]*t+i[6]*n+i[10]*r;return this.normalize()}divide(e){this.x/=e.x;this.y/=e.y;this.z/=e.z;return this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){this.x=Math.min(this.x,e.x);this.y=Math.min(this.y,e.y);this.z=Math.min(this.z,e.z);return this}max(e){this.x=Math.max(this.x,e.x);this.y=Math.max(this.y,e.y);this.z=Math.max(this.z,e.z);return this}clamp(e,t){this.x=Math.max(e.x,Math.min(t.x,this.x));this.y=Math.max(e.y,Math.min(t.y,this.y));this.z=Math.max(e.z,Math.min(t.z,this.z));return this}clampScalar(e,t){this.x=Math.max(e,Math.min(t,this.x));this.y=Math.max(e,Math.min(t,this.y));this.z=Math.max(e,Math.min(t,this.z));return this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){this.x+=(e.x-this.x)*t;this.y+=(e.y-this.y)*t;this.z+=(e.z-this.z)*t;return this}lerpVectors(e,t,n){this.x=e.x+(t.x-e.x)*n;this.y=e.y+(t.y-e.y)*n;this.z=e.z+(t.z-e.z)*n;return this}cross(e,t){if(void 0!==t){console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");return this.crossVectors(e,t)}return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,i=e.z;const s=t.x,a=t.y,o=t.z;this.x=r*o-i*a;this.y=i*s-n*o;this.z=n*a-r*s;return this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){Vn.copy(this).projectOnVector(e);return this.sub(Vn)}reflect(e){return this.sub(Vn.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(clamp(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;this.x=r*Math.sin(n);this.y=Math.cos(t)*e;this.z=r*Math.cos(n);return this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){this.x=e*Math.sin(t);this.y=n;this.z=e*Math.cos(t);return this}setFromMatrixPosition(e){const t=e.elements;this.x=t[12];this.y=t[13];this.z=t[14];return this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length();const n=this.setFromMatrixColumn(e,1).length();const r=this.setFromMatrixColumn(e,2).length();this.x=t;this.y=n;this.z=r;return this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){this.x=e[t];this.y=e[t+1];this.z=e[t+2];return this}toArray(e=[],t=0){e[t]=this.x;e[t+1]=this.y;e[t+2]=this.z;return e}fromBufferAttribute(e,t,n){void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");this.x=e.getX(t);this.y=e.getY(t);this.z=e.getZ(t);return this}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this}randomDirection(){const e=2*(Math.random()-.5);const t=Math.random()*Math.PI*2;const n=Math.sqrt(1-e**2);this.x=n*Math.cos(t);this.y=n*Math.sin(t);this.z=e;return this}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z}}Vector3.prototype.isVector3=true;const Vn=new Vector3;const Nn=new Quaternion;class Box3{constructor(e=new Vector3(Infinity,Infinity,Infinity),t=new Vector3(-Infinity,-Infinity,-Infinity)){this.min=e;this.max=t}set(e,t){this.min.copy(e);this.max.copy(t);return this}setFromArray(e){let t=Infinity;let n=Infinity;let r=Infinity;let i=-Infinity;let s=-Infinity;let a=-Infinity;for(let o=0,l=e.length;o<l;o+=3){const l=e[o];const c=e[o+1];const u=e[o+2];l<t&&(t=l);c<n&&(n=c);u<r&&(r=u);l>i&&(i=l);c>s&&(s=c);u>a&&(a=u)}this.min.set(t,n,r);this.max.set(i,s,a);return this}setFromBufferAttribute(e){let t=Infinity;let n=Infinity;let r=Infinity;let i=-Infinity;let s=-Infinity;let a=-Infinity;for(let o=0,l=e.count;o<l;o++){const l=e.getX(o);const c=e.getY(o);const u=e.getZ(o);l<t&&(t=l);c<n&&(n=c);u<r&&(r=u);l>i&&(i=l);c>s&&(s=c);u>a&&(a=u)}this.min.set(t,n,r);this.max.set(i,s,a);return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=zn.copy(t).multiplyScalar(.5);this.min.copy(e).sub(n);this.max.copy(e).add(n);return this}setFromObject(e){this.makeEmpty();return this.expandByObject(e)}clone(){return(new this.constructor).copy(this)}copy(e){this.min.copy(e.min);this.max.copy(e.max);return this}makeEmpty(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){this.min.min(e);this.max.max(e);return this}expandByVector(e){this.min.sub(e);this.max.add(e);return this}expandByScalar(e){this.min.addScalar(-e);this.max.addScalar(e);return this}expandByObject(e){e.updateWorldMatrix(false,false);const t=e.geometry;if(void 0!==t){null===t.boundingBox&&t.computeBoundingBox();Gn.copy(t.boundingBox);Gn.applyMatrix4(e.matrixWorld);this.union(Gn)}const n=e.children;for(let e=0,t=n.length;e<t;e++)this.expandByObject(n[e]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){this.clampPoint(e.center,zn);return zn.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;if(e.normal.x>0){t=e.normal.x*this.min.x;n=e.normal.x*this.max.x}else{t=e.normal.x*this.max.x;n=e.normal.x*this.min.x}if(e.normal.y>0){t+=e.normal.y*this.min.y;n+=e.normal.y*this.max.y}else{t+=e.normal.y*this.max.y;n+=e.normal.y*this.min.y}if(e.normal.z>0){t+=e.normal.z*this.min.z;n+=e.normal.z*this.max.z}else{t+=e.normal.z*this.max.z;n+=e.normal.z*this.min.z}return t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return false;this.getCenter(qn);Xn.subVectors(this.max,qn);Fn.subVectors(e.a,qn);On.subVectors(e.b,qn);Hn.subVectors(e.c,qn);kn.subVectors(On,Fn);Wn.subVectors(Hn,On);jn.subVectors(Fn,Hn);let t=[0,-kn.z,kn.y,0,-Wn.z,Wn.y,0,-jn.z,jn.y,kn.z,0,-kn.x,Wn.z,0,-Wn.x,jn.z,0,-jn.x,-kn.y,kn.x,0,-Wn.y,Wn.x,0,-jn.y,jn.x,0];if(!satForAxes(t,Fn,On,Hn,Xn))return false;t=[1,0,0,0,1,0,0,0,1];if(!satForAxes(t,Fn,On,Hn,Xn))return false;Jn.crossVectors(kn,Wn);t=[Jn.x,Jn.y,Jn.z];return satForAxes(t,Fn,On,Hn,Xn)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){const t=zn.copy(e).clamp(this.min,this.max);return t.sub(e).length()}getBoundingSphere(e){this.getCenter(e.center);e.radius=.5*this.getSize(zn).length();return e}intersect(e){this.min.max(e.min);this.max.min(e.max);this.isEmpty()&&this.makeEmpty();return this}union(e){this.min.min(e.min);this.max.max(e.max);return this}applyMatrix4(e){if(this.isEmpty())return this;Un[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e);Un[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e);Un[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e);Un[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e);Un[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e);Un[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e);Un[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e);Un[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e);this.setFromPoints(Un);return this}translate(e){this.min.add(e);this.max.add(e);return this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Box3.prototype.isBox3=true;const Un=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3];const zn=new Vector3;const Gn=new Box3;const Fn=new Vector3;const On=new Vector3;const Hn=new Vector3;const kn=new Vector3;const Wn=new Vector3;const jn=new Vector3;const qn=new Vector3;const Xn=new Vector3;const Jn=new Vector3;const Yn=new Vector3;function satForAxes(e,t,n,r,i){for(let s=0,a=e.length-3;s<=a;s+=3){Yn.fromArray(e,s);const a=i.x*Math.abs(Yn.x)+i.y*Math.abs(Yn.y)+i.z*Math.abs(Yn.z);const o=t.dot(Yn);const l=n.dot(Yn);const c=r.dot(Yn);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return false}return true}const Zn=new Box3;const Qn=new Vector3;const Kn=new Vector3;const $n=new Vector3;class Sphere{constructor(e=new Vector3,t=-1){this.center=e;this.radius=t}set(e,t){this.center.copy(e);this.radius=t;return this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):Zn.setFromPoints(e).getCenter(n);let r=0;for(let t=0,i=e.length;t<i;t++)r=Math.max(r,n.distanceToSquared(e[t]));this.radius=Math.sqrt(r);return this}copy(e){this.center.copy(e.center);this.radius=e.radius;return this}isEmpty(){return this.radius<0}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);t.copy(e);if(n>this.radius*this.radius){t.sub(this.center).normalize();t.multiplyScalar(this.radius).add(this.center)}return t}getBoundingBox(e){if(this.isEmpty()){e.makeEmpty();return e}e.set(this.center,this.center);e.expandByScalar(this.radius);return e}applyMatrix4(e){this.center.applyMatrix4(e);this.radius=this.radius*e.getMaxScaleOnAxis();return this}translate(e){this.center.add(e);return this}expandByPoint(e){$n.subVectors(e,this.center);const t=$n.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t);const n=.5*(e-this.radius);this.center.add($n.multiplyScalar(n/e));this.radius+=n}return this}union(e){true===this.center.equals(e.center)?Kn.set(0,0,1).multiplyScalar(e.radius):Kn.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius);this.expandByPoint(Qn.copy(e.center).add(Kn));this.expandByPoint(Qn.copy(e.center).sub(Kn));return this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const er=new Vector3;const tr=new Vector3;const nr=new Vector3;const rr=new Vector3;const ir=new Vector3;const sr=new Vector3;const ar=new Vector3;class Ray{constructor(e=new Vector3,t=new Vector3(0,0,-1)){this.origin=e;this.direction=t}set(e,t){this.origin.copy(e);this.direction.copy(t);return this}copy(e){this.origin.copy(e.origin);this.direction.copy(e.direction);return this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){this.direction.copy(e).sub(this.origin).normalize();return this}recast(e){this.origin.copy(this.at(e,er));return this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=er.subVectors(e,this.origin).dot(this.direction);if(t<0)return this.origin.distanceToSquared(e);er.copy(this.direction).multiplyScalar(t).add(this.origin);return er.distanceToSquared(e)}distanceSqToSegment(e,t,n,r){tr.copy(e).add(t).multiplyScalar(.5);nr.copy(t).sub(e).normalize();rr.copy(this.origin).sub(tr);const i=.5*e.distanceTo(t);const s=-this.direction.dot(nr);const a=rr.dot(this.direction);const o=-rr.dot(nr);const l=rr.lengthSq();const c=Math.abs(1-s*s);let u,h,d,p;if(c>0){u=s*o-a;h=s*a-o;p=i*c;if(u>=0)if(h>=-p)if(h<=p){const e=1/c;u*=e;h*=e;d=u*(u+s*h+2*a)+h*(s*u+h+2*o)+l}else{h=i;u=Math.max(0,-(s*h+a));d=-u*u+h*(h+2*o)+l}else{h=-i;u=Math.max(0,-(s*h+a));d=-u*u+h*(h+2*o)+l}else if(h<=-p){u=Math.max(0,-(-s*i+a));h=u>0?-i:Math.min(Math.max(-i,-o),i);d=-u*u+h*(h+2*o)+l}else if(h<=p){u=0;h=Math.min(Math.max(-i,-o),i);d=h*(h+2*o)+l}else{u=Math.max(0,-(s*i+a));h=u>0?i:Math.min(Math.max(-i,-o),i);d=-u*u+h*(h+2*o)+l}}else{h=s>0?-i:i;u=Math.max(0,-(s*h+a));d=-u*u+h*(h+2*o)+l}n&&n.copy(this.direction).multiplyScalar(u).add(this.origin);r&&r.copy(nr).multiplyScalar(h).add(tr);return d}intersectSphere(e,t){er.subVectors(e.center,this.origin);const n=er.dot(this.direction);const r=er.dot(er)-n*n;const i=e.radius*e.radius;if(r>i)return null;const s=Math.sqrt(i-r);const a=n-s;const o=n+s;return a<0&&o<0?null:a<0?this.at(o,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);if(0===t)return true;const n=e.normal.dot(this.direction);return n*t<0}intersectBox(e,t){let n,r,i,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z;const h=this.origin;if(l>=0){n=(e.min.x-h.x)*l;r=(e.max.x-h.x)*l}else{n=(e.max.x-h.x)*l;r=(e.min.x-h.x)*l}if(c>=0){i=(e.min.y-h.y)*c;s=(e.max.y-h.y)*c}else{i=(e.max.y-h.y)*c;s=(e.min.y-h.y)*c}if(n>s||i>r)return null;(i>n||n!==n)&&(n=i);(s<r||r!==r)&&(r=s);if(u>=0){a=(e.min.z-h.z)*u;o=(e.max.z-h.z)*u}else{a=(e.max.z-h.z)*u;o=(e.min.z-h.z)*u}if(n>o||a>r)return null;(a>n||n!==n)&&(n=a);(o<r||r!==r)&&(r=o);return r<0?null:this.at(n>=0?n:r,t)}intersectsBox(e){return null!==this.intersectBox(e,er)}intersectTriangle(e,t,n,r,i){ir.subVectors(t,e);sr.subVectors(n,e);ar.crossVectors(ir,sr);let s=this.direction.dot(ar);let a;if(s>0){if(r)return null;a=1}else{if(!(s<0))return null;a=-1;s=-s}rr.subVectors(this.origin,e);const o=a*this.direction.dot(sr.crossVectors(rr,sr));if(o<0)return null;const l=a*this.direction.dot(ir.cross(rr));if(l<0)return null;if(o+l>s)return null;const c=-a*rr.dot(ar);return c<0?null:this.at(c/s,i)}applyMatrix4(e){this.origin.applyMatrix4(e);this.direction.transformDirection(e);return this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l,c,u,h,d,p,f,m){const g=this.elements;g[0]=e;g[4]=t;g[8]=n;g[12]=r;g[1]=i;g[5]=s;g[9]=a;g[13]=o;g[2]=l;g[6]=c;g[10]=u;g[14]=h;g[3]=d;g[7]=p;g[11]=f;g[15]=m;return this}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this}clone(){return(new Matrix4).fromArray(this.elements)}copy(e){const t=this.elements;const n=e.elements;t[0]=n[0];t[1]=n[1];t[2]=n[2];t[3]=n[3];t[4]=n[4];t[5]=n[5];t[6]=n[6];t[7]=n[7];t[8]=n[8];t[9]=n[9];t[10]=n[10];t[11]=n[11];t[12]=n[12];t[13]=n[13];t[14]=n[14];t[15]=n[15];return this}copyPosition(e){const t=this.elements,n=e.elements;t[12]=n[12];t[13]=n[13];t[14]=n[14];return this}setFromMatrix3(e){const t=e.elements;this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1);return this}extractBasis(e,t,n){e.setFromMatrixColumn(this,0);t.setFromMatrixColumn(this,1);n.setFromMatrixColumn(this,2);return this}makeBasis(e,t,n){this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1);return this}extractRotation(e){const t=this.elements;const n=e.elements;const r=1/or.setFromMatrixColumn(e,0).length();const i=1/or.setFromMatrixColumn(e,1).length();const s=1/or.setFromMatrixColumn(e,2).length();t[0]=n[0]*r;t[1]=n[1]*r;t[2]=n[2]*r;t[3]=0;t[4]=n[4]*i;t[5]=n[5]*i;t[6]=n[6]*i;t[7]=0;t[8]=n[8]*s;t[9]=n[9]*s;t[10]=n[10]*s;t[11]=0;t[12]=0;t[13]=0;t[14]=0;t[15]=1;return this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements;const n=e.x,r=e.y,i=e.z;const s=Math.cos(n),a=Math.sin(n);const o=Math.cos(r),l=Math.sin(r);const c=Math.cos(i),u=Math.sin(i);if("XYZ"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c;t[4]=-o*u;t[8]=l;t[1]=n+r*l;t[5]=e-i*l;t[9]=-a*o;t[2]=i-e*l;t[6]=r+n*l;t[10]=s*o}else if("YXZ"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e+i*a;t[4]=r*a-n;t[8]=s*l;t[1]=s*u;t[5]=s*c;t[9]=-a;t[2]=n*a-r;t[6]=i+e*a;t[10]=s*o}else if("ZXY"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e-i*a;t[4]=-s*u;t[8]=r+n*a;t[1]=n+r*a;t[5]=s*c;t[9]=i-e*a;t[2]=-s*l;t[6]=a;t[10]=s*o}else if("ZYX"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c;t[4]=r*l-n;t[8]=e*l+i;t[1]=o*u;t[5]=i*l+e;t[9]=n*l-r;t[2]=-l;t[6]=a*o;t[10]=s*o}else if("YZX"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c;t[4]=i-e*u;t[8]=r*u+n;t[1]=u;t[5]=s*c;t[9]=-a*c;t[2]=-l*c;t[6]=n*u+r;t[10]=e-i*u}else if("XZY"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c;t[4]=-u;t[8]=l*c;t[1]=e*u+i;t[5]=s*c;t[9]=n*u-r;t[2]=r*u-n;t[6]=a*c;t[10]=i*u+e}t[3]=0;t[7]=0;t[11]=0;t[12]=0;t[13]=0;t[14]=0;t[15]=1;return this}makeRotationFromQuaternion(e){return this.compose(cr,e,ur)}lookAt(e,t,n){const r=this.elements;pr.subVectors(e,t);0===pr.lengthSq()&&(pr.z=1);pr.normalize();hr.crossVectors(n,pr);if(0===hr.lengthSq()){1===Math.abs(n.z)?pr.x+=1e-4:pr.z+=1e-4;pr.normalize();hr.crossVectors(n,pr)}hr.normalize();dr.crossVectors(pr,hr);r[0]=hr.x;r[4]=dr.x;r[8]=pr.x;r[1]=hr.y;r[5]=dr.y;r[9]=pr.y;r[2]=hr.z;r[6]=dr.z;r[10]=pr.z;return this}multiply(e,t){if(void 0!==t){console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");return this.multiplyMatrices(e,t)}return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements;const r=t.elements;const i=this.elements;const s=n[0],a=n[4],o=n[8],l=n[12];const c=n[1],u=n[5],h=n[9],d=n[13];const p=n[2],f=n[6],m=n[10],g=n[14];const y=n[3],x=n[7],b=n[11],_=n[15];const M=r[0],w=r[4],S=r[8],T=r[12];const E=r[1],A=r[5],L=r[9],C=r[13];const R=r[2],P=r[6],I=r[10],D=r[14];const B=r[3],V=r[7],N=r[11],U=r[15];i[0]=s*M+a*E+o*R+l*B;i[4]=s*w+a*A+o*P+l*V;i[8]=s*S+a*L+o*I+l*N;i[12]=s*T+a*C+o*D+l*U;i[1]=c*M+u*E+h*R+d*B;i[5]=c*w+u*A+h*P+d*V;i[9]=c*S+u*L+h*I+d*N;i[13]=c*T+u*C+h*D+d*U;i[2]=p*M+f*E+m*R+g*B;i[6]=p*w+f*A+m*P+g*V;i[10]=p*S+f*L+m*I+g*N;i[14]=p*T+f*C+m*D+g*U;i[3]=y*M+x*E+b*R+_*B;i[7]=y*w+x*A+b*P+_*V;i[11]=y*S+x*L+b*I+_*N;i[15]=y*T+x*C+b*D+_*U;return this}multiplyScalar(e){const t=this.elements;t[0]*=e;t[4]*=e;t[8]*=e;t[12]*=e;t[1]*=e;t[5]*=e;t[9]*=e;t[13]*=e;t[2]*=e;t[6]*=e;t[10]*=e;t[14]*=e;t[3]*=e;t[7]*=e;t[11]*=e;t[15]*=e;return this}determinant(){const e=this.elements;const t=e[0],n=e[4],r=e[8],i=e[12];const s=e[1],a=e[5],o=e[9],l=e[13];const c=e[2],u=e[6],h=e[10],d=e[14];const p=e[3],f=e[7],m=e[11],g=e[15];return p*(+i*o*u-r*l*u-i*a*h+n*l*h+r*a*d-n*o*d)+f*(+t*o*d-t*l*h+i*s*h-r*s*d+r*l*c-i*o*c)+m*(+t*l*u-t*a*d-i*s*u+n*s*d+i*a*c-n*l*c)+g*(-r*a*c-t*o*u+t*a*h+r*s*u-n*s*h+n*o*c)}transpose(){const e=this.elements;let t;t=e[1];e[1]=e[4];e[4]=t;t=e[2];e[2]=e[8];e[8]=t;t=e[6];e[6]=e[9];e[9]=t;t=e[3];e[3]=e[12];e[12]=t;t=e[7];e[7]=e[13];e[13]=t;t=e[11];e[11]=e[14];e[14]=t;return this}setPosition(e,t,n){const r=this.elements;if(e.isVector3){r[12]=e.x;r[13]=e.y;r[14]=e.z}else{r[12]=e;r[13]=t;r[14]=n}return this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],y=u*m*l-f*h*l+f*o*d-a*m*d-u*o*g+a*h*g,x=p*h*l-c*m*l-p*o*d+s*m*d+c*o*g-s*h*g,b=c*f*l-p*u*l+p*a*d-s*f*d-c*a*g+s*u*g,_=p*u*o-c*f*o-p*a*h+s*f*h+c*a*m-s*u*m;const M=t*y+n*x+r*b+i*_;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/M;e[0]=y*w;e[1]=(f*h*i-u*m*i-f*r*d+n*m*d+u*r*g-n*h*g)*w;e[2]=(a*m*i-f*o*i+f*r*l-n*m*l-a*r*g+n*o*g)*w;e[3]=(u*o*i-a*h*i-u*r*l+n*h*l+a*r*d-n*o*d)*w;e[4]=x*w;e[5]=(c*m*i-p*h*i+p*r*d-t*m*d-c*r*g+t*h*g)*w;e[6]=(p*o*i-s*m*i-p*r*l+t*m*l+s*r*g-t*o*g)*w;e[7]=(s*h*i-c*o*i+c*r*l-t*h*l-s*r*d+t*o*d)*w;e[8]=b*w;e[9]=(p*u*i-c*f*i-p*n*d+t*f*d+c*n*g-t*u*g)*w;e[10]=(s*f*i-p*a*i+p*n*l-t*f*l-s*n*g+t*a*g)*w;e[11]=(c*a*i-s*u*i-c*n*l+t*u*l+s*n*d-t*a*d)*w;e[12]=_*w;e[13]=(c*f*r-p*u*r+p*n*h-t*f*h-c*n*m+t*u*m)*w;e[14]=(p*a*r-s*f*r-p*n*o+t*f*o+s*n*m-t*a*m)*w;e[15]=(s*u*r-c*a*r+c*n*o-t*u*o-s*n*h+t*a*h)*w;return this}scale(e){const t=this.elements;const n=e.x,r=e.y,i=e.z;t[0]*=n;t[4]*=r;t[8]*=i;t[1]*=n;t[5]*=r;t[9]*=i;t[2]*=n;t[6]*=r;t[10]*=i;t[3]*=n;t[7]*=r;t[11]*=i;return this}getMaxScaleOnAxis(){const e=this.elements;const t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2];const n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6];const r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1);return this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1);return this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1);return this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1);return this}makeRotationAxis(e,t){const n=Math.cos(t);const r=Math.sin(t);const i=1-n;const s=e.x,a=e.y,o=e.z;const l=i*s,c=i*a;this.set(l*s+n,l*a-r*o,l*o+r*a,0,l*a+r*o,c*a+n,c*o-r*s,0,l*o-r*a,c*o+r*s,i*o*o+n,0,0,0,0,1);return this}makeScale(e,t,n){this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1);return this}makeShear(e,t,n,r,i,s){this.set(1,n,i,0,e,1,s,0,t,r,1,0,0,0,0,1);return this}compose(e,t,n){const r=this.elements;const i=t._x,s=t._y,a=t._z,o=t._w;const l=i+i,c=s+s,u=a+a;const h=i*l,d=i*c,p=i*u;const f=s*c,m=s*u,g=a*u;const y=o*l,x=o*c,b=o*u;const _=n.x,M=n.y,w=n.z;r[0]=(1-(f+g))*_;r[1]=(d+b)*_;r[2]=(p-x)*_;r[3]=0;r[4]=(d-b)*M;r[5]=(1-(h+g))*M;r[6]=(m+y)*M;r[7]=0;r[8]=(p+x)*w;r[9]=(m-y)*w;r[10]=(1-(h+f))*w;r[11]=0;r[12]=e.x;r[13]=e.y;r[14]=e.z;r[15]=1;return this}decompose(e,t,n){const r=this.elements;let i=or.set(r[0],r[1],r[2]).length();const s=or.set(r[4],r[5],r[6]).length();const a=or.set(r[8],r[9],r[10]).length();const o=this.determinant();o<0&&(i=-i);e.x=r[12];e.y=r[13];e.z=r[14];lr.copy(this);const l=1/i;const c=1/s;const u=1/a;lr.elements[0]*=l;lr.elements[1]*=l;lr.elements[2]*=l;lr.elements[4]*=c;lr.elements[5]*=c;lr.elements[6]*=c;lr.elements[8]*=u;lr.elements[9]*=u;lr.elements[10]*=u;t.setFromRotationMatrix(lr);n.x=i;n.y=s;n.z=a;return this}makePerspective(e,t,n,r,i,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements;const o=2*i/(t-e);const l=2*i/(n-r);const c=(t+e)/(t-e);const u=(n+r)/(n-r);const h=-(s+i)/(s-i);const d=-2*s*i/(s-i);a[0]=o;a[4]=0;a[8]=c;a[12]=0;a[1]=0;a[5]=l;a[9]=u;a[13]=0;a[2]=0;a[6]=0;a[10]=h;a[14]=d;a[3]=0;a[7]=0;a[11]=-1;a[15]=0;return this}makeOrthographic(e,t,n,r,i,s){const a=this.elements;const o=1/(t-e);const l=1/(n-r);const c=1/(s-i);const u=(t+e)*o;const h=(n+r)*l;const d=(s+i)*c;a[0]=2*o;a[4]=0;a[8]=0;a[12]=-u;a[1]=0;a[5]=2*l;a[9]=0;a[13]=-h;a[2]=0;a[6]=0;a[10]=-2*c;a[14]=-d;a[3]=0;a[7]=0;a[11]=0;a[15]=1;return this}equals(e){const t=this.elements;const n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return false;return true}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;e[t]=n[0];e[t+1]=n[1];e[t+2]=n[2];e[t+3]=n[3];e[t+4]=n[4];e[t+5]=n[5];e[t+6]=n[6];e[t+7]=n[7];e[t+8]=n[8];e[t+9]=n[9];e[t+10]=n[10];e[t+11]=n[11];e[t+12]=n[12];e[t+13]=n[13];e[t+14]=n[14];e[t+15]=n[15];return e}}Matrix4.prototype.isMatrix4=true;const or=new Vector3;const lr=new Matrix4;const cr=new Vector3(0,0,0);const ur=new Vector3(1,1,1);const hr=new Vector3;const dr=new Vector3;const pr=new Vector3;const fr=new Matrix4;const mr=new Quaternion;class Euler{constructor(e=0,t=0,n=0,r=Euler.DefaultOrder){this._x=e;this._y=t;this._z=n;this._order=r}get x(){return this._x}set x(e){this._x=e;this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e;this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e;this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e;this._onChangeCallback()}set(e,t,n,r=this._order){this._x=e;this._y=t;this._z=n;this._order=r;this._onChangeCallback();return this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){this._x=e._x;this._y=e._y;this._z=e._z;this._order=e._order;this._onChangeCallback();return this}setFromRotationMatrix(e,t=this._order,n=true){const r=e.elements;const i=r[0],s=r[4],a=r[8];const o=r[1],l=r[5],c=r[9];const u=r[2],h=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(clamp(a,-1,1));if(Math.abs(a)<.9999999){this._x=Math.atan2(-c,d);this._z=Math.atan2(-s,i)}else{this._x=Math.atan2(h,l);this._z=0}break;case"YXZ":this._x=Math.asin(-clamp(c,-1,1));if(Math.abs(c)<.9999999){this._y=Math.atan2(a,d);this._z=Math.atan2(o,l)}else{this._y=Math.atan2(-u,i);this._z=0}break;case"ZXY":this._x=Math.asin(clamp(h,-1,1));if(Math.abs(h)<.9999999){this._y=Math.atan2(-u,d);this._z=Math.atan2(-s,l)}else{this._y=0;this._z=Math.atan2(o,i)}break;case"ZYX":this._y=Math.asin(-clamp(u,-1,1));if(Math.abs(u)<.9999999){this._x=Math.atan2(h,d);this._z=Math.atan2(o,i)}else{this._x=0;this._z=Math.atan2(-s,l)}break;case"YZX":this._z=Math.asin(clamp(o,-1,1));if(Math.abs(o)<.9999999){this._x=Math.atan2(-c,l);this._y=Math.atan2(-u,i)}else{this._x=0;this._y=Math.atan2(a,d)}break;case"XZY":this._z=Math.asin(-clamp(s,-1,1));if(Math.abs(s)<.9999999){this._x=Math.atan2(h,l);this._y=Math.atan2(a,i)}else{this._x=Math.atan2(-c,d);this._y=0}break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}this._order=t;true===n&&this._onChangeCallback();return this}setFromQuaternion(e,t,n){fr.makeRotationFromQuaternion(e);return this.setFromRotationMatrix(fr,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){mr.setFromEuler(this);return this.setFromQuaternion(mr,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){this._x=e[0];this._y=e[1];this._z=e[2];void 0!==e[3]&&(this._order=e[3]);this._onChangeCallback();return this}toArray(e=[],t=0){e[t]=this._x;e[t+1]=this._y;e[t+2]=this._z;e[t+3]=this._order;return e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Vector3(this._x,this._y,this._z)}_onChange(e){this._onChangeCallback=e;return this}_onChangeCallback(){}}Euler.prototype.isEuler=true;Euler.DefaultOrder="XYZ";Euler.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Layers{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!==(this.mask&e.mask)}isEnabled(e){return 0!==(this.mask&(1<<e|0))}}let gr=0;const yr=new Vector3;const vr=new Quaternion;const xr=new Matrix4;const br=new Vector3;const _r=new Vector3;const Mr=new Vector3;const wr=new Quaternion;const Sr=new Vector3(1,0,0);const Tr=new Vector3(0,1,0);const Er=new Vector3(0,0,1);const Ar={type:"added"};const Lr={type:"removed"};class Object3D extends EventDispatcher{constructor(){super();Object.defineProperty(this,"id",{value:gr++});this.uuid=generateUUID();this.name="";this.type="Object3D";this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();const e=new Vector3;const t=new Euler;const n=new Quaternion;const r=new Vector3(1,1,1);function onRotationChange(){n.setFromEuler(t,false)}function onQuaternionChange(){t.setFromQuaternion(n,void 0,false)}t._onChange(onRotationChange);n._onChange(onQuaternionChange);Object.defineProperties(this,{position:{configurable:true,enumerable:true,value:e},rotation:{configurable:true,enumerable:true,value:t},quaternion:{configurable:true,enumerable:true,value:n},scale:{configurable:true,enumerable:true,value:r},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}});this.matrix=new Matrix4;this.matrixWorld=new Matrix4;this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers;this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.animations=[];this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix();this.matrix.premultiply(e);this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){this.quaternion.premultiply(e);return this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,true)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){vr.setFromAxisAngle(e,t);this.quaternion.multiply(vr);return this}rotateOnWorldAxis(e,t){vr.setFromAxisAngle(e,t);this.quaternion.premultiply(vr);return this}rotateX(e){return this.rotateOnAxis(Sr,e)}rotateY(e){return this.rotateOnAxis(Tr,e)}rotateZ(e){return this.rotateOnAxis(Er,e)}translateOnAxis(e,t){yr.copy(e).applyQuaternion(this.quaternion);this.position.add(yr.multiplyScalar(t));return this}translateX(e){return this.translateOnAxis(Sr,e)}translateY(e){return this.translateOnAxis(Tr,e)}translateZ(e){return this.translateOnAxis(Er,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(xr.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?br.copy(e):br.set(e,t,n);const r=this.parent;this.updateWorldMatrix(true,false);_r.setFromMatrixPosition(this.matrixWorld);this.isCamera||this.isLight?xr.lookAt(_r,br,this.up):xr.lookAt(br,_r,this.up);this.quaternion.setFromRotationMatrix(xr);if(r){xr.extractRotation(r.matrixWorld);vr.setFromRotationMatrix(xr);this.quaternion.premultiply(vr.invert())}}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}if(e===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",e);return this}if(e&&e.isObject3D){null!==e.parent&&e.parent.remove(e);e.parent=this;this.children.push(e);e.dispatchEvent(Ar)}else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e);return this}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);if(-1!==t){e.parent=null;this.children.splice(t,1);e.dispatchEvent(Lr)}return this}removeFromParent(){const e=this.parent;null!==e&&e.remove(this);return this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null;t.dispatchEvent(Lr)}this.children.length=0;return this}attach(e){this.updateWorldMatrix(true,false);xr.copy(this.matrixWorld).invert();if(null!==e.parent){e.parent.updateWorldMatrix(true,false);xr.multiply(e.parent.matrixWorld)}e.applyMatrix4(xr);this.add(e);e.updateWorldMatrix(false,true);return this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n];const i=r.getObjectByProperty(e,t);if(void 0!==i)return i}}getWorldPosition(e){this.updateWorldMatrix(true,false);return e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_r,e,Mr);return e}getWorldScale(e){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_r,wr,e);return e}getWorldDirection(e){this.updateWorldMatrix(true,false);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(false===this.visible)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;if(null!==t){e(t);t.traverseAncestors(e)}}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||e){null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);this.matrixWorldNeedsUpdate=false;e=true}const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;true===e&&null!==n&&n.updateWorldMatrix(true,false);this.matrixAutoUpdate&&this.updateMatrix();null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);if(true===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(false,true)}}toJSON(e){const t=void 0===e||"string"===typeof e;const n={};if(t){e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}};n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"}}const r={};r.uuid=this.uuid;r.type=this.type;""!==this.name&&(r.name=this.name);true===this.castShadow&&(r.castShadow=true);true===this.receiveShadow&&(r.receiveShadow=true);false===this.visible&&(r.visible=false);false===this.frustumCulled&&(r.frustumCulled=false);0!==this.renderOrder&&(r.renderOrder=this.renderOrder);"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData);r.layers=this.layers.mask;r.matrix=this.matrix.toArray();false===this.matrixAutoUpdate&&(r.matrixAutoUpdate=false);if(this.isInstancedMesh){r.type="InstancedMesh";r.count=this.count;r.instanceMatrix=this.instanceMatrix.toJSON();null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())}function serialize(t,n){void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e));return n.uuid}if(this.isScene){this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid));this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid)}else if(this.isMesh||this.isLine||this.isPoints){r.geometry=serialize(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const r=n[t];serialize(e.shapes,r)}else serialize(e.shapes,n)}}if(this.isSkinnedMesh){r.bindMode=this.bindMode;r.bindMatrix=this.bindMatrix.toArray();if(void 0!==this.skeleton){serialize(e.skeletons,this.skeleton);r.skeleton=this.skeleton.uuid}}if(void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,r=this.material.length;n<r;n++)t.push(serialize(e.materials,this.material[n]));r.material=t}else r.material=serialize(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];r.animations.push(serialize(e.animations,n))}}if(t){const t=extractFromCache(e.geometries);const r=extractFromCache(e.materials);const i=extractFromCache(e.textures);const s=extractFromCache(e.images);const a=extractFromCache(e.shapes);const o=extractFromCache(e.skeletons);const l=extractFromCache(e.animations);t.length>0&&(n.geometries=t);r.length>0&&(n.materials=r);i.length>0&&(n.textures=i);s.length>0&&(n.images=s);a.length>0&&(n.shapes=a);o.length>0&&(n.skeletons=o);l.length>0&&(n.animations=l)}n.object=r;return n;function extractFromCache(e){const t=[];for(const n in e){const r=e[n];delete r.metadata;t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=true){this.name=e.name;this.up.copy(e.up);this.position.copy(e.position);this.rotation.order=e.rotation.order;this.quaternion.copy(e.quaternion);this.scale.copy(e.scale);this.matrix.copy(e.matrix);this.matrixWorld.copy(e.matrixWorld);this.matrixAutoUpdate=e.matrixAutoUpdate;this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate;this.layers.mask=e.layers.mask;this.visible=e.visible;this.castShadow=e.castShadow;this.receiveShadow=e.receiveShadow;this.frustumCulled=e.frustumCulled;this.renderOrder=e.renderOrder;this.userData=JSON.parse(JSON.stringify(e.userData));if(true===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype.isObject3D=true;const Cr=new Vector3;const Rr=new Vector3;const Pr=new Vector3;const Ir=new Vector3;const Dr=new Vector3;const Br=new Vector3;const Vr=new Vector3;const Nr=new Vector3;const Ur=new Vector3;const zr=new Vector3;class Triangle{constructor(e=new Vector3,t=new Vector3,n=new Vector3){this.a=e;this.b=t;this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t);Cr.subVectors(e,t);r.cross(Cr);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,n,r,i){Cr.subVectors(r,t);Rr.subVectors(n,t);Pr.subVectors(e,t);const s=Cr.dot(Cr);const a=Cr.dot(Rr);const o=Cr.dot(Pr);const l=Rr.dot(Rr);const c=Rr.dot(Pr);const u=s*l-a*a;if(0===u)return i.set(-2,-1,-1);const h=1/u;const d=(l*o-a*c)*h;const p=(s*c-a*o)*h;return i.set(1-d-p,p,d)}static containsPoint(e,t,n,r){this.getBarycoord(e,t,n,r,Ir);return Ir.x>=0&&Ir.y>=0&&Ir.x+Ir.y<=1}static getUV(e,t,n,r,i,s,a,o){this.getBarycoord(e,t,n,r,Ir);o.set(0,0);o.addScaledVector(i,Ir.x);o.addScaledVector(s,Ir.y);o.addScaledVector(a,Ir.z);return o}static isFrontFacing(e,t,n,r){Cr.subVectors(n,t);Rr.subVectors(e,t);return Cr.cross(Rr).dot(r)<0}set(e,t,n){this.a.copy(e);this.b.copy(t);this.c.copy(n);return this}setFromPointsAndIndices(e,t,n,r){this.a.copy(e[t]);this.b.copy(e[n]);this.c.copy(e[r]);return this}setFromAttributeAndIndices(e,t,n,r){this.a.fromBufferAttribute(e,t);this.b.fromBufferAttribute(e,n);this.c.fromBufferAttribute(e,r);return this}clone(){return(new this.constructor).copy(this)}copy(e){this.a.copy(e.a);this.b.copy(e.b);this.c.copy(e.c);return this}getArea(){Cr.subVectors(this.c,this.b);Rr.subVectors(this.a,this.b);return.5*Cr.cross(Rr).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Triangle.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Triangle.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,i){return Triangle.getUV(e,this.a,this.b,this.c,t,n,r,i)}containsPoint(e){return Triangle.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,i=this.c;let s,a;Dr.subVectors(r,n);Br.subVectors(i,n);Nr.subVectors(e,n);const o=Dr.dot(Nr);const l=Br.dot(Nr);if(o<=0&&l<=0)return t.copy(n);Ur.subVectors(e,r);const c=Dr.dot(Ur);const u=Br.dot(Ur);if(c>=0&&u<=c)return t.copy(r);const h=o*u-c*l;if(h<=0&&o>=0&&c<=0){s=o/(o-c);return t.copy(n).addScaledVector(Dr,s)}zr.subVectors(e,i);const d=Dr.dot(zr);const p=Br.dot(zr);if(p>=0&&d<=p)return t.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0){a=l/(l-p);return t.copy(n).addScaledVector(Br,a)}const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0){Vr.subVectors(i,r);a=(u-c)/(u-c+(d-p));return t.copy(r).addScaledVector(Vr,a)}const g=1/(m+f+h);s=f*g;a=h*g;return t.copy(n).addScaledVector(Dr,s).addScaledVector(Br,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Gr=0;class Material extends EventDispatcher{constructor(){super();Object.defineProperty(this,"id",{value:Gr++});this.uuid=generateUUID();this.name="";this.type="Material";this.fog=true;this.blending=y;this.side=h;this.vertexColors=false;this.opacity=1;this.format=Ne;this.transparent=false;this.blendSrc=I;this.blendDst=D;this.blendEquation=w;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=H;this.depthTest=true;this.depthWrite=true;this.stencilWriteMask=255;this.stencilFunc=mn;this.stencilRef=0;this.stencilFuncMask=255;this.stencilFail=en;this.stencilZFail=en;this.stencilZPass=en;this.stencilWrite=false;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaToCoverage=false;this.premultipliedAlpha=false;this.visible=true;this.toneMapped=true;this.userData={};this.version=0;this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!==e>0&&this.version++;this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.");this.flatShading=n===f;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=void 0===e||"string"===typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid;n.type=this.type;""!==this.name&&(n.name=this.name);this.color&&this.color.isColor&&(n.color=this.color.getHex());void 0!==this.roughness&&(n.roughness=this.roughness);void 0!==this.metalness&&(n.metalness=this.metalness);void 0!==this.sheen&&(n.sheen=this.sheen);this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex());void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness);this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex());this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity);this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex());void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity);this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex());void 0!==this.shininess&&(n.shininess=this.shininess);void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat);void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness);this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid);this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid);if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid;n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()}this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid);this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid);this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid);if(this.lightMap&&this.lightMap.isTexture){n.lightMap=this.lightMap.toJSON(e).uuid;n.lightMapIntensity=this.lightMapIntensity}if(this.aoMap&&this.aoMap.isTexture){n.aoMap=this.aoMap.toJSON(e).uuid;n.aoMapIntensity=this.aoMapIntensity}if(this.bumpMap&&this.bumpMap.isTexture){n.bumpMap=this.bumpMap.toJSON(e).uuid;n.bumpScale=this.bumpScale}if(this.normalMap&&this.normalMap.isTexture){n.normalMap=this.normalMap.toJSON(e).uuid;n.normalMapType=this.normalMapType;n.normalScale=this.normalScale.toArray()}if(this.displacementMap&&this.displacementMap.isTexture){n.displacementMap=this.displacementMap.toJSON(e).uuid;n.displacementScale=this.displacementScale;n.displacementBias=this.displacementBias}this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid);this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid);this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid);this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid);this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid);this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid);if(this.envMap&&this.envMap.isTexture){n.envMap=this.envMap.toJSON(e).uuid;void 0!==this.combine&&(n.combine=this.combine)}void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity);void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity);void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio);this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid);void 0!==this.transmission&&(n.transmission=this.transmission);this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid);void 0!==this.thickness&&(n.thickness=this.thickness);this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid);void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance);void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex());void 0!==this.size&&(n.size=this.size);null!==this.shadowSide&&(n.shadowSide=this.shadowSide);void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation);this.blending!==y&&(n.blending=this.blending);this.side!==h&&(n.side=this.side);this.vertexColors&&(n.vertexColors=true);this.opacity<1&&(n.opacity=this.opacity);this.format!==Ne&&(n.format=this.format);true===this.transparent&&(n.transparent=this.transparent);n.depthFunc=this.depthFunc;n.depthTest=this.depthTest;n.depthWrite=this.depthWrite;n.colorWrite=this.colorWrite;n.stencilWrite=this.stencilWrite;n.stencilWriteMask=this.stencilWriteMask;n.stencilFunc=this.stencilFunc;n.stencilRef=this.stencilRef;n.stencilFuncMask=this.stencilFuncMask;n.stencilFail=this.stencilFail;n.stencilZFail=this.stencilZFail;n.stencilZPass=this.stencilZPass;this.rotation&&0!==this.rotation&&(n.rotation=this.rotation);true===this.polygonOffset&&(n.polygonOffset=true);0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor);0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits);this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth);void 0!==this.dashSize&&(n.dashSize=this.dashSize);void 0!==this.gapSize&&(n.gapSize=this.gapSize);void 0!==this.scale&&(n.scale=this.scale);true===this.dithering&&(n.dithering=true);this.alphaTest>0&&(n.alphaTest=this.alphaTest);true===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage);true===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha);true===this.wireframe&&(n.wireframe=this.wireframe);this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth);"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap);"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin);true===this.flatShading&&(n.flatShading=this.flatShading);false===this.visible&&(n.visible=false);false===this.toneMapped&&(n.toneMapped=false);"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData);function extractFromCache(e){const t=[];for(const n in e){const r=e[n];delete r.metadata;t.push(r)}return t}if(t){const t=extractFromCache(e.textures);const r=extractFromCache(e.images);t.length>0&&(n.textures=t);r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name;this.fog=e.fog;this.blending=e.blending;this.side=e.side;this.vertexColors=e.vertexColors;this.opacity=e.opacity;this.format=e.format;this.transparent=e.transparent;this.blendSrc=e.blendSrc;this.blendDst=e.blendDst;this.blendEquation=e.blendEquation;this.blendSrcAlpha=e.blendSrcAlpha;this.blendDstAlpha=e.blendDstAlpha;this.blendEquationAlpha=e.blendEquationAlpha;this.depthFunc=e.depthFunc;this.depthTest=e.depthTest;this.depthWrite=e.depthWrite;this.stencilWriteMask=e.stencilWriteMask;this.stencilFunc=e.stencilFunc;this.stencilRef=e.stencilRef;this.stencilFuncMask=e.stencilFuncMask;this.stencilFail=e.stencilFail;this.stencilZFail=e.stencilZFail;this.stencilZPass=e.stencilZPass;this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let r=0;r!==e;++r)n[r]=t[r].clone()}this.clippingPlanes=n;this.clipIntersection=e.clipIntersection;this.clipShadows=e.clipShadows;this.shadowSide=e.shadowSide;this.colorWrite=e.colorWrite;this.precision=e.precision;this.polygonOffset=e.polygonOffset;this.polygonOffsetFactor=e.polygonOffsetFactor;this.polygonOffsetUnits=e.polygonOffsetUnits;this.dithering=e.dithering;this.alphaTest=e.alphaTest;this.alphaToCoverage=e.alphaToCoverage;this.premultipliedAlpha=e.premultipliedAlpha;this.visible=e.visible;this.toneMapped=e.toneMapped;this.userData=JSON.parse(JSON.stringify(e.userData));return this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){true===e&&this.version++}}Material.prototype.isMaterial=true;const Fr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};const Or={h:0,s:0,l:0};const Hr={h:0,s:0,l:0};function hue2rgb(e,t,n){n<0&&(n+=1);n>1&&(n-=1);return n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function SRGBToLinear(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function LinearToSRGB(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class Color{constructor(e,t,n){return void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){e&&e.isColor?this.copy(e):"number"===typeof e?this.setHex(e):"string"===typeof e&&this.setStyle(e);return this}setScalar(e){this.r=e;this.g=e;this.b=e;return this}setHex(e){e=Math.floor(e);this.r=(e>>16&255)/255;this.g=(e>>8&255)/255;this.b=(255&e)/255;return this}setRGB(e,t,n){this.r=e;this.g=t;this.b=n;return this}setHSL(e,t,n){e=euclideanModulo(e,1);t=clamp(t,0,1);n=clamp(n,0,1);if(0===t)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t;const i=2*n-r;this.r=hue2rgb(i,r,e+1/3);this.g=hue2rgb(i,r,e);this.b=hue2rgb(i,r,e-1/3)}return this}setStyle(e){function handleAlpha(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let t;if(t=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const n=t[1];const r=t[2];switch(n){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){this.r=Math.min(255,parseInt(e[1],10))/255;this.g=Math.min(255,parseInt(e[2],10))/255;this.b=Math.min(255,parseInt(e[3],10))/255;handleAlpha(e[4]);return this}if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){this.r=Math.min(100,parseInt(e[1],10))/100;this.g=Math.min(100,parseInt(e[2],10))/100;this.b=Math.min(100,parseInt(e[3],10))/100;handleAlpha(e[4]);return this}break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const t=parseFloat(e[1])/360;const n=parseInt(e[2],10)/100;const r=parseInt(e[3],10)/100;handleAlpha(e[4]);return this.setHSL(t,n,r)}break}}else if(t=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=t[1];const n=e.length;if(3===n){this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255;this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255;this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255;return this}if(6===n){this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255;this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255;this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255;return this}}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Fr[e.toLowerCase()];void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e);return this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){this.r=e.r;this.g=e.g;this.b=e.b;return this}copySRGBToLinear(e){this.r=SRGBToLinear(e.r);this.g=SRGBToLinear(e.g);this.b=SRGBToLinear(e.b);return this}copyLinearToSRGB(e){this.r=LinearToSRGB(e.r);this.g=LinearToSRGB(e.g);this.b=LinearToSRGB(e.b);return this}convertSRGBToLinear(){this.copySRGBToLinear(this);return this}convertLinearToSRGB(){this.copyLinearToSRGB(this);return this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,n=this.g,r=this.b;const i=Math.max(t,n,r);const s=Math.min(t,n,r);let a,o;const l=(s+i)/2;if(s===i){a=0;o=0}else{const e=i-s;o=l<=.5?e/(i+s):e/(2-i-s);switch(i){case t:a=(n-r)/e+(n<r?6:0);break;case n:a=(r-t)/e+2;break;case r:a=(t-n)/e+4;break}a/=6}e.h=a;e.s=o;e.l=l;return e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){this.getHSL(Or);Or.h+=e;Or.s+=t;Or.l+=n;this.setHSL(Or.h,Or.s,Or.l);return this}add(e){this.r+=e.r;this.g+=e.g;this.b+=e.b;return this}addColors(e,t){this.r=e.r+t.r;this.g=e.g+t.g;this.b=e.b+t.b;return this}addScalar(e){this.r+=e;this.g+=e;this.b+=e;return this}sub(e){this.r=Math.max(0,this.r-e.r);this.g=Math.max(0,this.g-e.g);this.b=Math.max(0,this.b-e.b);return this}multiply(e){this.r*=e.r;this.g*=e.g;this.b*=e.b;return this}multiplyScalar(e){this.r*=e;this.g*=e;this.b*=e;return this}lerp(e,t){this.r+=(e.r-this.r)*t;this.g+=(e.g-this.g)*t;this.b+=(e.b-this.b)*t;return this}lerpColors(e,t,n){this.r=e.r+(t.r-e.r)*n;this.g=e.g+(t.g-e.g)*n;this.b=e.b+(t.b-e.b)*n;return this}lerpHSL(e,t){this.getHSL(Or);e.getHSL(Hr);const n=lerp(Or.h,Hr.h,t);const r=lerp(Or.s,Hr.s,t);const i=lerp(Or.l,Hr.l,t);this.setHSL(n,r,i);return this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){this.r=e[t];this.g=e[t+1];this.b=e[t+2];return this}toArray(e=[],t=0){e[t]=this.r;e[t+1]=this.g;e[t+2]=this.b;return e}fromBufferAttribute(e,t){this.r=e.getX(t);this.g=e.getY(t);this.b=e.getZ(t);if(true===e.normalized){this.r/=255;this.g/=255;this.b/=255}return this}toJSON(){return this.getHex()}}Color.NAMES=Fr;Color.prototype.isColor=true;Color.prototype.r=1;Color.prototype.g=1;Color.prototype.b=1;class MeshBasicMaterial extends Material{constructor(e){super();this.type="MeshBasicMaterial";this.color=new Color(16777215);this.map=null;this.lightMap=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=X;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap="round";this.wireframeLinejoin="round";this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.map=e.map;this.lightMap=e.lightMap;this.lightMapIntensity=e.lightMapIntensity;this.aoMap=e.aoMap;this.aoMapIntensity=e.aoMapIntensity;this.specularMap=e.specularMap;this.alphaMap=e.alphaMap;this.envMap=e.envMap;this.combine=e.combine;this.reflectivity=e.reflectivity;this.refractionRatio=e.refractionRatio;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.wireframeLinecap=e.wireframeLinecap;this.wireframeLinejoin=e.wireframeLinejoin;return this}}MeshBasicMaterial.prototype.isMeshBasicMaterial=true;const kr=new Vector3;const Wr=new Vector2;class BufferAttribute{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="";this.array=e;this.itemSize=t;this.count=void 0!==e?e.length/t:0;this.normalized=true===n;this.usage=gn;this.updateRange={offset:0,count:-1};this.version=0}onUploadCallback(){}set needsUpdate(e){true===e&&this.version++}setUsage(e){this.usage=e;return this}copy(e){this.name=e.name;this.array=new e.array.constructor(e.array);this.itemSize=e.itemSize;this.count=e.count;this.normalized=e.normalized;this.usage=e.usage;return this}copyAt(e,t,n){e*=this.itemSize;n*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){this.array.set(e);return this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];if(void 0===i){console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r);i=new Color}t[n++]=i.r;t[n++]=i.g;t[n++]=i.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];if(void 0===i){console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r);i=new Vector2}t[n++]=i.x;t[n++]=i.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];if(void 0===i){console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r);i=new Vector3}t[n++]=i.x;t[n++]=i.y;t[n++]=i.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];if(void 0===i){console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r);i=new Vector4}t[n++]=i.x;t[n++]=i.y;t[n++]=i.z;t[n++]=i.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++){Wr.fromBufferAttribute(this,t);Wr.applyMatrix3(e);this.setXY(t,Wr.x,Wr.y)}else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++){kr.fromBufferAttribute(this,t);kr.applyMatrix3(e);this.setXYZ(t,kr.x,kr.y,kr.z)}return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++){kr.x=this.getX(t);kr.y=this.getY(t);kr.z=this.getZ(t);kr.applyMatrix4(e);this.setXYZ(t,kr.x,kr.y,kr.z)}return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++){kr.x=this.getX(t);kr.y=this.getY(t);kr.z=this.getZ(t);kr.applyNormalMatrix(e);this.setXYZ(t,kr.x,kr.y,kr.z)}return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++){kr.x=this.getX(t);kr.y=this.getY(t);kr.z=this.getZ(t);kr.transformDirection(e);this.setXYZ(t,kr.x,kr.y,kr.z)}return this}set(e,t=0){this.array.set(e,t);return this}getX(e){return this.array[e*this.itemSize]}setX(e,t){this.array[e*this.itemSize]=t;return this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){this.array[e*this.itemSize+1]=t;return this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){this.array[e*this.itemSize+2]=t;return this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){this.array[e*this.itemSize+3]=t;return this}setXY(e,t,n){e*=this.itemSize;this.array[e+0]=t;this.array[e+1]=n;return this}setXYZ(e,t,n,r){e*=this.itemSize;this.array[e+0]=t;this.array[e+1]=n;this.array[e+2]=r;return this}setXYZW(e,t,n,r,i){e*=this.itemSize;this.array[e+0]=t;this.array[e+1]=n;this.array[e+2]=r;this.array[e+3]=i;return this}onUpload(e){this.onUploadCallback=e;return this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};""!==this.name&&(e.name=this.name);this.usage!==gn&&(e.usage=this.usage);0===this.updateRange.offset&&-1===this.updateRange.count||(e.updateRange=this.updateRange);return e}}BufferAttribute.prototype.isBufferAttribute=true;class Int8BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Int8Array(e),t,n)}}class Uint8BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class Int16BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Int16Array(e),t,n)}}class Uint16BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Int32BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Int32Array(e),t,n)}}class Uint32BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Float16BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Uint16Array(e),t,n)}}Float16BufferAttribute.prototype.isFloat16BufferAttribute=true;class Float32BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Float32Array(e),t,n)}}class Float64BufferAttribute extends BufferAttribute{constructor(e,t,n){super(new Float64Array(e),t,n)}}let jr=0;const qr=new Matrix4;const Xr=new Object3D;const Jr=new Vector3;const Yr=new Box3;const Zr=new Box3;const Qr=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super();Object.defineProperty(this,"id",{value:jr++});this.uuid=generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=false;this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};this.userData={}}getIndex(){return this.index}setIndex(e){Array.isArray(e)?this.index=new(arrayMax(e)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e;return this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){this.attributes[e]=t;return this}deleteAttribute(e){delete this.attributes[e];return this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e;this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;if(void 0!==t){t.applyMatrix4(e);t.needsUpdate=true}const n=this.attributes.normal;if(void 0!==n){const t=(new Matrix3).getNormalMatrix(e);n.applyNormalMatrix(t);n.needsUpdate=true}const r=this.attributes.tangent;if(void 0!==r){r.transformDirection(e);r.needsUpdate=true}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this}applyQuaternion(e){qr.makeRotationFromQuaternion(e);this.applyMatrix4(qr);return this}rotateX(e){qr.makeRotationX(e);this.applyMatrix4(qr);return this}rotateY(e){qr.makeRotationY(e);this.applyMatrix4(qr);return this}rotateZ(e){qr.makeRotationZ(e);this.applyMatrix4(qr);return this}translate(e,t,n){qr.makeTranslation(e,t,n);this.applyMatrix4(qr);return this}scale(e,t,n){qr.makeScale(e,t,n);this.applyMatrix4(qr);return this}lookAt(e){Xr.lookAt(e);Xr.updateMatrix();this.applyMatrix4(Xr.matrix);return this}center(){this.computeBoundingBox();this.boundingBox.getCenter(Jr).negate();this.translate(Jr.x,Jr.y,Jr.z);return this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}this.setAttribute("position",new Float32BufferAttribute(t,3));return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const e=this.attributes.position;const t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(Infinity,Infinity,Infinity))}else{if(void 0!==e){this.boundingBox.setFromBufferAttribute(e);if(t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Yr.setFromBufferAttribute(n);if(this.morphTargetsRelative){Qr.addVectors(this.boundingBox.min,Yr.min);this.boundingBox.expandByPoint(Qr);Qr.addVectors(this.boundingBox.max,Yr.max);this.boundingBox.expandByPoint(Qr)}else{this.boundingBox.expandByPoint(Yr.min);this.boundingBox.expandByPoint(Yr.max)}}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const e=this.attributes.position;const t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingSphere.set(new Vector3,Infinity)}else if(e){const n=this.boundingSphere.center;Yr.setFromBufferAttribute(e);if(t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Zr.setFromBufferAttribute(n);if(this.morphTargetsRelative){Qr.addVectors(Yr.min,Zr.min);Yr.expandByPoint(Qr);Qr.addVectors(Yr.max,Zr.max);Yr.expandByPoint(Qr)}else{Yr.expandByPoint(Zr.min);Yr.expandByPoint(Zr.max)}}Yr.getCenter(n);let r=0;for(let t=0,i=e.count;t<i;t++){Qr.fromBufferAttribute(e,t);r=Math.max(r,n.distanceToSquared(Qr))}if(t)for(let i=0,s=t.length;i<s;i++){const s=t[i];const a=this.morphTargetsRelative;for(let t=0,i=s.count;t<i;t++){Qr.fromBufferAttribute(s,t);if(a){Jr.fromBufferAttribute(e,t);Qr.add(Jr)}r=Math.max(r,n.distanceToSquared(Qr))}}this.boundingSphere.radius=Math.sqrt(r);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index;const t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array;const r=t.position.array;const i=t.normal.array;const s=t.uv.array;const a=r.length/3;void 0===t.tangent&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*a),4));const o=t.tangent.array;const l=[],c=[];for(let e=0;e<a;e++){l[e]=new Vector3;c[e]=new Vector3}const u=new Vector3,h=new Vector3,d=new Vector3,p=new Vector2,f=new Vector2,m=new Vector2,g=new Vector3,y=new Vector3;function handleTriangle(e,t,n){u.fromArray(r,3*e);h.fromArray(r,3*t);d.fromArray(r,3*n);p.fromArray(s,2*e);f.fromArray(s,2*t);m.fromArray(s,2*n);h.sub(u);d.sub(u);f.sub(p);m.sub(p);const i=1/(f.x*m.y-m.x*f.y);if(isFinite(i)){g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i);y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(i);l[e].add(g);l[t].add(g);l[n].add(g);c[e].add(y);c[t].add(y);c[n].add(y)}}let x=this.groups;0===x.length&&(x=[{start:0,count:n.length}]);for(let e=0,t=x.length;e<t;++e){const t=x[e];const r=t.start;const i=t.count;for(let e=r,t=r+i;e<t;e+=3)handleTriangle(n[e+0],n[e+1],n[e+2])}const b=new Vector3,_=new Vector3;const M=new Vector3,w=new Vector3;function handleVertex(e){M.fromArray(i,3*e);w.copy(M);const t=l[e];b.copy(t);b.sub(M.multiplyScalar(M.dot(t))).normalize();_.crossVectors(w,t);const n=_.dot(c[e]);const r=n<0?-1:1;o[4*e]=b.x;o[4*e+1]=b.y;o[4*e+2]=b.z;o[4*e+3]=r}for(let e=0,t=x.length;e<t;++e){const t=x[e];const r=t.start;const i=t.count;for(let e=r,t=r+i;e<t;e+=3){handleVertex(n[e+0]);handleVertex(n[e+1]);handleVertex(n[e+2])}}}computeVertexNormals(){const e=this.index;const t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n){n=new BufferAttribute(new Float32Array(3*t.count),3);this.setAttribute("normal",n)}else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const r=new Vector3,i=new Vector3,s=new Vector3;const a=new Vector3,o=new Vector3,l=new Vector3;const c=new Vector3,u=new Vector3;if(e)for(let h=0,d=e.count;h<d;h+=3){const d=e.getX(h+0);const p=e.getX(h+1);const f=e.getX(h+2);r.fromBufferAttribute(t,d);i.fromBufferAttribute(t,p);s.fromBufferAttribute(t,f);c.subVectors(s,i);u.subVectors(r,i);c.cross(u);a.fromBufferAttribute(n,d);o.fromBufferAttribute(n,p);l.fromBufferAttribute(n,f);a.add(c);o.add(c);l.add(c);n.setXYZ(d,a.x,a.y,a.z);n.setXYZ(p,o.x,o.y,o.z);n.setXYZ(f,l.x,l.y,l.z)}else for(let e=0,a=t.count;e<a;e+=3){r.fromBufferAttribute(t,e+0);i.fromBufferAttribute(t,e+1);s.fromBufferAttribute(t,e+2);c.subVectors(s,i);u.subVectors(r,i);c.cross(u);n.setXYZ(e+0,c.x,c.y,c.z);n.setXYZ(e+1,c.x,c.y,c.z);n.setXYZ(e+2,c.x,c.y,c.z)}this.normalizeNormals();n.needsUpdate=true}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}if(void 0===t){t=0;console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")}const n=this.attributes;for(const r in n){if(void 0===e.attributes[r])continue;const i=n[r];const s=i.array;const a=e.attributes[r];const o=a.array;const l=a.itemSize*t;const c=Math.min(o.length,s.length-l);for(let e=0,t=l;e<c;e++,t++)s[t]=o[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++){Qr.fromBufferAttribute(e,t);Qr.normalize();e.setXYZ(t,Qr.x,Qr.y,Qr.z)}}toNonIndexed(){function convertBufferAttribute(e,t){const n=e.array;const r=e.itemSize;const i=e.normalized;const s=new n.constructor(t.length*r);let a=0,o=0;for(let i=0,l=t.length;i<l;i++){a=e.isInterleavedBufferAttribute?t[i]*e.data.stride+e.offset:t[i]*r;for(let e=0;e<r;e++)s[o++]=n[a++]}return new BufferAttribute(s,r,i)}if(null===this.index){console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");return this}const e=new BufferGeometry;const t=this.index.array;const n=this.attributes;for(const r in n){const i=n[r];const s=convertBufferAttribute(i,t);e.setAttribute(r,s)}const r=this.morphAttributes;for(const n in r){const i=[];const s=r[n];for(let e=0,n=s.length;e<n;e++){const n=s[e];const r=convertBufferAttribute(n,t);i.push(r)}e.morphAttributes[n]=i}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let t=0,n=i.length;t<n;t++){const n=i[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};e.uuid=this.uuid;e.type=this.type;""!==this.name&&(e.name=this.name);Object.keys(this.userData).length>0&&(e.userData=this.userData);if(void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const r=n[t];e.data.attributes[t]=r.toJSON(e.data)}const r={};let i=false;for(const t in this.morphAttributes){const n=this.morphAttributes[t];const s=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];s.push(r.toJSON(e.data))}if(s.length>0){r[t]=s;i=true}}if(i){e.data.morphAttributes=r;e.data.morphTargetsRelative=this.morphTargetsRelative}const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius});return e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const r=e.attributes;for(const e in r){const n=r[e];this.setAttribute(e,n.clone(t))}const i=e.morphAttributes;for(const e in i){const n=[];const r=i[e];for(let e=0,i=r.length;e<i;e++)n.push(r[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let e=0,t=s.length;e<t;e++){const t=s[e];this.addGroup(t.start,t.count,t.materialIndex)}const a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=e.boundingSphere;null!==o&&(this.boundingSphere=o.clone());this.drawRange.start=e.drawRange.start;this.drawRange.count=e.drawRange.count;this.userData=e.userData;void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters));return this}dispose(){this.dispatchEvent({type:"dispose"})}}BufferGeometry.prototype.isBufferGeometry=true;const Kr=new Matrix4;const $r=new Ray;const ei=new Sphere;const ti=new Vector3;const ni=new Vector3;const ri=new Vector3;const ii=new Vector3;const si=new Vector3;const ai=new Vector3;const oi=new Vector3;const li=new Vector3;const ci=new Vector3;const ui=new Vector2;const hi=new Vector2;const di=new Vector2;const pi=new Vector3;const fi=new Vector3;class Mesh extends Object3D{constructor(e=new BufferGeometry,t=new MeshBasicMaterial){super();this.type="Mesh";this.geometry=e;this.material=t;this.updateMorphTargets()}copy(e){super.copy(e);void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice());void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary));this.material=e.material;this.geometry=e.geometry;return this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes;const n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0);this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry;const r=this.material;const i=this.matrixWorld;if(void 0===r)return;null===n.boundingSphere&&n.computeBoundingSphere();ei.copy(n.boundingSphere);ei.applyMatrix4(i);if(false===e.ray.intersectsSphere(ei))return;Kr.copy(i).invert();$r.copy(e.ray).applyMatrix4(Kr);if(null!==n.boundingBox&&false===$r.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const i=n.index;const a=n.attributes.position;const o=n.morphAttributes.position;const l=n.morphTargetsRelative;const c=n.attributes.uv;const u=n.attributes.uv2;const h=n.groups;const d=n.drawRange;if(null!==i)if(Array.isArray(r))for(let n=0,p=h.length;n<p;n++){const p=h[n];const f=r[p.materialIndex];const m=Math.max(p.start,d.start);const g=Math.min(i.count,Math.min(p.start+p.count,d.start+d.count));for(let n=m,r=g;n<r;n+=3){const r=i.getX(n);const h=i.getX(n+1);const d=i.getX(n+2);s=checkBufferGeometryIntersection(this,f,e,$r,a,o,l,c,u,r,h,d);if(s){s.faceIndex=Math.floor(n/3);s.face.materialIndex=p.materialIndex;t.push(s)}}}else{const n=Math.max(0,d.start);const h=Math.min(i.count,d.start+d.count);for(let d=n,p=h;d<p;d+=3){const n=i.getX(d);const h=i.getX(d+1);const p=i.getX(d+2);s=checkBufferGeometryIntersection(this,r,e,$r,a,o,l,c,u,n,h,p);if(s){s.faceIndex=Math.floor(d/3);t.push(s)}}}else if(void 0!==a)if(Array.isArray(r))for(let n=0,i=h.length;n<i;n++){const i=h[n];const p=r[i.materialIndex];const f=Math.max(i.start,d.start);const m=Math.min(a.count,Math.min(i.start+i.count,d.start+d.count));for(let n=f,r=m;n<r;n+=3){const r=n;const h=n+1;const d=n+2;s=checkBufferGeometryIntersection(this,p,e,$r,a,o,l,c,u,r,h,d);if(s){s.faceIndex=Math.floor(n/3);s.face.materialIndex=i.materialIndex;t.push(s)}}}else{const n=Math.max(0,d.start);const i=Math.min(a.count,d.start+d.count);for(let h=n,d=i;h<d;h+=3){const n=h;const i=h+1;const d=h+2;s=checkBufferGeometryIntersection(this,r,e,$r,a,o,l,c,u,n,i,d);if(s){s.faceIndex=Math.floor(h/3);t.push(s)}}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Mesh.prototype.isMesh=true;function checkIntersection(e,t,n,r,i,s,a,o){let l;l=t.side===d?r.intersectTriangle(a,s,i,true,o):r.intersectTriangle(i,s,a,t.side!==p,o);if(null===l)return null;fi.copy(o);fi.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(fi);return c<n.near||c>n.far?null:{distance:c,point:fi.clone(),object:e}}function checkBufferGeometryIntersection(e,t,n,r,i,s,a,o,l,c,u,h){ti.fromBufferAttribute(i,c);ni.fromBufferAttribute(i,u);ri.fromBufferAttribute(i,h);const d=e.morphTargetInfluences;if(s&&d){oi.set(0,0,0);li.set(0,0,0);ci.set(0,0,0);for(let e=0,t=s.length;e<t;e++){const t=d[e];const n=s[e];if(0!==t){ii.fromBufferAttribute(n,c);si.fromBufferAttribute(n,u);ai.fromBufferAttribute(n,h);if(a){oi.addScaledVector(ii,t);li.addScaledVector(si,t);ci.addScaledVector(ai,t)}else{oi.addScaledVector(ii.sub(ti),t);li.addScaledVector(si.sub(ni),t);ci.addScaledVector(ai.sub(ri),t)}}}ti.add(oi);ni.add(li);ri.add(ci)}if(e.isSkinnedMesh){e.boneTransform(c,ti);e.boneTransform(u,ni);e.boneTransform(h,ri)}const p=checkIntersection(e,t,n,r,ti,ni,ri,pi);if(p){if(o){ui.fromBufferAttribute(o,c);hi.fromBufferAttribute(o,u);di.fromBufferAttribute(o,h);p.uv=Triangle.getUV(pi,ti,ni,ri,ui,hi,di,new Vector2)}if(l){ui.fromBufferAttribute(l,c);hi.fromBufferAttribute(l,u);di.fromBufferAttribute(l,h);p.uv2=Triangle.getUV(pi,ti,ni,ri,ui,hi,di,new Vector2)}const e={a:c,b:u,c:h,normal:new Vector3,materialIndex:0};Triangle.getNormal(ti,ni,ri,e.normal);p.face=e}return p}class BoxGeometry extends BufferGeometry{constructor(e=1,t=1,n=1,r=1,i=1,s=1){super();this.type="BoxGeometry";this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const a=this;r=Math.floor(r);i=Math.floor(i);s=Math.floor(s);const o=[];const l=[];const c=[];const u=[];let h=0;let d=0;buildPlane("z","y","x",-1,-1,n,t,e,s,i,0);buildPlane("z","y","x",1,-1,n,t,-e,s,i,1);buildPlane("x","z","y",1,1,e,n,t,r,s,2);buildPlane("x","z","y",1,-1,e,n,-t,r,s,3);buildPlane("x","y","z",1,-1,e,t,n,r,i,4);buildPlane("x","y","z",-1,-1,e,t,-n,r,i,5);this.setIndex(o);this.setAttribute("position",new Float32BufferAttribute(l,3));this.setAttribute("normal",new Float32BufferAttribute(c,3));this.setAttribute("uv",new Float32BufferAttribute(u,2));function buildPlane(e,t,n,r,i,s,p,f,m,g,y){const x=s/m;const b=p/g;const _=s/2;const M=p/2;const w=f/2;const S=m+1;const T=g+1;let E=0;let A=0;const L=new Vector3;for(let s=0;s<T;s++){const a=s*b-M;for(let o=0;o<S;o++){const h=o*x-_;L[e]=h*r;L[t]=a*i;L[n]=w;l.push(L.x,L.y,L.z);L[e]=0;L[t]=0;L[n]=f>0?1:-1;c.push(L.x,L.y,L.z);u.push(o/m);u.push(1-s/g);E+=1}}for(let e=0;e<g;e++)for(let t=0;t<m;t++){const n=h+t+S*e;const r=h+t+S*(e+1);const i=h+(t+1)+S*(e+1);const s=h+(t+1)+S*e;o.push(n,r,s);o.push(r,i,s);A+=6}a.addGroup(d,A,y);d+=A;h+=E}}static fromJSON(e){return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function cloneUniforms(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const i=e[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[n][r]=i.clone():Array.isArray(i)?t[n][r]=i.slice():t[n][r]=i}}return t}function mergeUniforms(e){const t={};for(let n=0;n<e.length;n++){const r=cloneUniforms(e[n]);for(const e in r)t[e]=r[e]}return t}const mi={clone:cloneUniforms,merge:mergeUniforms};var gi="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var yi="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";class ShaderMaterial extends Material{constructor(e){super();this.type="ShaderMaterial";this.defines={};this.uniforms={};this.vertexShader=gi;this.fragmentShader=yi;this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.clipping=false;this.extensions={derivatives:false,fragDepth:false,drawBuffers:false,shaderTextureLOD:false};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.uniformsNeedUpdate=false;this.glslVersion=null;if(void 0!==e){void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");this.setValues(e)}}copy(e){super.copy(e);this.fragmentShader=e.fragmentShader;this.vertexShader=e.vertexShader;this.uniforms=cloneUniforms(e.uniforms);this.defines=Object.assign({},e.defines);this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.lights=e.lights;this.clipping=e.clipping;this.extensions=Object.assign({},e.extensions);this.glslVersion=e.glslVersion;return this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion;t.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n];const i=r.value;i&&i.isTexture?t.uniforms[n]={type:"t",value:i.toJSON(e).uuid}:i&&i.isColor?t.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?t.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?t.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?t.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?t.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?t.uniforms[n]={type:"m4",value:i.toArray()}:t.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(t.defines=this.defines);t.vertexShader=this.vertexShader;t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)true===this.extensions[e]&&(n[e]=true);Object.keys(n).length>0&&(t.extensions=n);return t}}ShaderMaterial.prototype.isShaderMaterial=true;class Camera extends Object3D{constructor(){super();this.type="Camera";this.matrixWorldInverse=new Matrix4;this.projectionMatrix=new Matrix4;this.projectionMatrixInverse=new Matrix4}copy(e,t){super.copy(e,t);this.matrixWorldInverse.copy(e.matrixWorldInverse);this.projectionMatrix.copy(e.projectionMatrix);this.projectionMatrixInverse.copy(e.projectionMatrixInverse);return this}getWorldDirection(e){this.updateWorldMatrix(true,false);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e);this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t);this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Camera.prototype.isCamera=true;class PerspectiveCamera extends Camera{constructor(e=50,t=1,n=.1,r=2e3){super();this.type="PerspectiveCamera";this.fov=e;this.zoom=1;this.near=n;this.far=r;this.focus=10;this.aspect=t;this.view=null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()}copy(e,t){super.copy(e,t);this.fov=e.fov;this.zoom=e.zoom;this.near=e.near;this.far=e.far;this.focus=e.focus;this.aspect=e.aspect;this.view=null===e.view?null:Object.assign({},e.view);this.filmGauge=e.filmGauge;this.filmOffset=e.filmOffset;return this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*Rn*Math.atan(t);this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*Cn*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*Rn*Math.atan(Math.tan(.5*Cn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,i,s){this.aspect=e/t;null===this.view&&(this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=true;this.view.fullWidth=e;this.view.fullHeight=t;this.view.offsetX=n;this.view.offsetY=r;this.view.width=i;this.view.height=s;this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=false);this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*Cn*this.fov)/this.zoom;let n=2*t;let r=this.aspect*n;let i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const e=s.fullWidth,a=s.fullHeight;i+=s.offsetX*r/e;t-=s.offsetY*n/a;r*=s.width/e;n*=s.height/a}const a=this.filmOffset;0!==a&&(i+=e*a/this.getFilmWidth());this.projectionMatrix.makePerspective(i,i+r,t,t-n,e,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);t.object.fov=this.fov;t.object.zoom=this.zoom;t.object.near=this.near;t.object.far=this.far;t.object.focus=this.focus;t.object.aspect=this.aspect;null!==this.view&&(t.object.view=Object.assign({},this.view));t.object.filmGauge=this.filmGauge;t.object.filmOffset=this.filmOffset;return t}}PerspectiveCamera.prototype.isPerspectiveCamera=true;const vi=90,xi=1;class CubeCamera extends Object3D{constructor(e,t,n){super();this.type="CubeCamera";if(true!==n.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new PerspectiveCamera(vi,xi,e,t);r.layers=this.layers;r.up.set(0,-1,0);r.lookAt(new Vector3(1,0,0));this.add(r);const i=new PerspectiveCamera(vi,xi,e,t);i.layers=this.layers;i.up.set(0,-1,0);i.lookAt(new Vector3(-1,0,0));this.add(i);const s=new PerspectiveCamera(vi,xi,e,t);s.layers=this.layers;s.up.set(0,0,1);s.lookAt(new Vector3(0,1,0));this.add(s);const a=new PerspectiveCamera(vi,xi,e,t);a.layers=this.layers;a.up.set(0,0,-1);a.lookAt(new Vector3(0,-1,0));this.add(a);const o=new PerspectiveCamera(vi,xi,e,t);o.layers=this.layers;o.up.set(0,-1,0);o.lookAt(new Vector3(0,0,1));this.add(o);const l=new PerspectiveCamera(vi,xi,e,t);l.layers=this.layers;l.up.set(0,-1,0);l.lookAt(new Vector3(0,0,-1));this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget;const[r,i,s,a,o,l]=this.children;const c=e.xr.enabled;const u=e.getRenderTarget();e.xr.enabled=false;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=false;e.setRenderTarget(n,0);e.render(t,r);e.setRenderTarget(n,1);e.render(t,i);e.setRenderTarget(n,2);e.render(t,s);e.setRenderTarget(n,3);e.render(t,a);e.setRenderTarget(n,4);e.render(t,o);n.texture.generateMipmaps=h;e.setRenderTarget(n,5);e.render(t,l);e.setRenderTarget(u);e.xr.enabled=c}}class CubeTexture extends Texture{constructor(e,t,n,r,i,s,a,o,l,c){e=void 0!==e?e:[];t=void 0!==t?t:re;super(e,t,n,r,i,s,a,o,l,c);this.flipY=false}get images(){return this.image}set images(e){this.image=e}}CubeTexture.prototype.isCubeTexture=true;class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(e,t,n){if(Number.isInteger(t)){console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");t=n}super(e,e,t);t=t||{};this.texture=new CubeTexture(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding);this.texture.isRenderTargetTexture=true;this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps;this.texture.minFilter=void 0!==t.minFilter?t.minFilter:ye;this.texture._needsFlipEnvMap=false}fromEquirectangularTexture(e,t){this.texture.type=t.type;this.texture.format=Ne;this.texture.encoding=t.encoding;this.texture.generateMipmaps=t.generateMipmaps;this.texture.minFilter=t.minFilter;this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"};const r=new BoxGeometry(5,5,5);const i=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:d,blending:g});i.uniforms.tEquirect.value=t;const s=new Mesh(r,i);const a=t.minFilter;t.minFilter===be&&(t.minFilter=ye);const o=new CubeCamera(1,10,this);o.update(e,s);t.minFilter=a;s.geometry.dispose();s.material.dispose();return this}clear(e,t,n,r){const i=e.getRenderTarget();for(let i=0;i<6;i++){e.setRenderTarget(this,i);e.clear(t,n,r)}e.setRenderTarget(i)}}WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=true;const bi=new Vector3;const _i=new Vector3;const Mi=new Matrix3;class Plane{constructor(e=new Vector3(1,0,0),t=0){this.normal=e;this.constant=t}set(e,t){this.normal.copy(e);this.constant=t;return this}setComponents(e,t,n,r){this.normal.set(e,t,n);this.constant=r;return this}setFromNormalAndCoplanarPoint(e,t){this.normal.copy(e);this.constant=-t.dot(this.normal);return this}setFromCoplanarPoints(e,t,n){const r=bi.subVectors(n,t).cross(_i.subVectors(e,t)).normalize();this.setFromNormalAndCoplanarPoint(r,e);return this}copy(e){this.normal.copy(e.normal);this.constant=e.constant;return this}normalize(){const e=1/this.normal.length();this.normal.multiplyScalar(e);this.constant*=e;return this}negate(){this.constant*=-1;this.normal.negate();return this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(bi);const r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start);const n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||Mi.getNormalMatrix(e);const r=this.coplanarPoint(bi).applyMatrix4(e);const i=this.normal.applyMatrix3(n).normalize();this.constant=-r.dot(i);return this}translate(e){this.constant-=e.dot(this.normal);return this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Plane.prototype.isPlane=true;const wi=new Sphere;const Si=new Vector3;class Frustum{constructor(e=new Plane,t=new Plane,n=new Plane,r=new Plane,i=new Plane,s=new Plane){this.planes=[e,t,n,r,i,s]}set(e,t,n,r,i,s){const a=this.planes;a[0].copy(e);a[1].copy(t);a[2].copy(n);a[3].copy(r);a[4].copy(i);a[5].copy(s);return this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes;const n=e.elements;const r=n[0],i=n[1],s=n[2],a=n[3];const o=n[4],l=n[5],c=n[6],u=n[7];const h=n[8],d=n[9],p=n[10],f=n[11];const m=n[12],g=n[13],y=n[14],x=n[15];t[0].setComponents(a-r,u-o,f-h,x-m).normalize();t[1].setComponents(a+r,u+o,f+h,x+m).normalize();t[2].setComponents(a+i,u+l,f+d,x+g).normalize();t[3].setComponents(a-i,u-l,f-d,x-g).normalize();t[4].setComponents(a-s,u-c,f-p,x-y).normalize();t[5].setComponents(a+s,u+c,f+p,x+y).normalize();return this}intersectsObject(e){const t=e.geometry;null===t.boundingSphere&&t.computeBoundingSphere();wi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);return this.intersectsSphere(wi)}intersectsSprite(e){wi.center.set(0,0,0);wi.radius=.7071067811865476;wi.applyMatrix4(e.matrixWorld);return this.intersectsSphere(wi)}intersectsSphere(e){const t=this.planes;const n=e.center;const r=-e.radius;for(let e=0;e<6;e++){const i=t[e].distanceToPoint(n);if(i<r)return false}return true}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];Si.x=r.normal.x>0?e.max.x:e.min.x;Si.y=r.normal.y>0?e.max.y:e.min.y;Si.z=r.normal.z>0?e.max.z:e.min.z;if(r.distanceToPoint(Si)<0)return false}return true}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return false;return true}clone(){return(new this.constructor).copy(this)}}function WebGLAnimation(){let e=null;let t=false;let n=null;let r=null;function onAnimationFrame(t,i){n(t,i);r=e.requestAnimationFrame(onAnimationFrame)}return{start:function(){if(true!==t&&null!==n){r=e.requestAnimationFrame(onAnimationFrame);t=true}},stop:function(){e.cancelAnimationFrame(r);t=false},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function WebGLAttributes(e,t){const n=t.isWebGL2;const r=new WeakMap;function createBuffer(t,r){const i=t.array;const s=t.usage;const a=e.createBuffer();e.bindBuffer(r,a);e.bufferData(r,i,s);t.onUploadCallback();let o=5126;i instanceof Float32Array?o=5126:i instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):i instanceof Uint16Array?t.isFloat16BufferAttribute?n?o=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):o=5123:i instanceof Int16Array?o=5122:i instanceof Uint32Array?o=5125:i instanceof Int32Array?o=5124:i instanceof Int8Array?o=5120:(i instanceof Uint8Array||i instanceof Uint8ClampedArray)&&(o=5121);return{buffer:a,type:o,bytesPerElement:i.BYTES_PER_ELEMENT,version:t.version}}function updateBuffer(t,r,i){const s=r.array;const a=r.updateRange;e.bindBuffer(i,t);if(-1===a.count)e.bufferSubData(i,0,s);else{n?e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count));a.count=-1}}function get(e){e.isInterleavedBufferAttribute&&(e=e.data);return r.get(e)}function remove(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=r.get(t);if(n){e.deleteBuffer(n.buffer);r.delete(t)}}function update(e,t){if(e.isGLBufferAttribute){const t=r.get(e);(!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version});return}e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);if(void 0===n)r.set(e,createBuffer(e,t));else if(n.version<e.version){updateBuffer(n.buffer,e,t);n.version=e.version}}return{get:get,remove:remove,update:update}}class PlaneGeometry extends BufferGeometry{constructor(e=1,t=1,n=1,r=1){super();this.type="PlaneGeometry";this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const i=e/2;const s=t/2;const a=Math.floor(n);const o=Math.floor(r);const l=a+1;const c=o+1;const u=e/a;const h=t/o;const d=[];const p=[];const f=[];const m=[];for(let e=0;e<c;e++){const t=e*h-s;for(let n=0;n<l;n++){const r=n*u-i;p.push(r,-t,0);f.push(0,0,1);m.push(n/a);m.push(1-e/o)}}for(let e=0;e<o;e++)for(let t=0;t<a;t++){const n=t+l*e;const r=t+l*(e+1);const i=t+1+l*(e+1);const s=t+1+l*e;d.push(n,r,s);d.push(r,i,s)}this.setIndex(d);this.setAttribute("position",new Float32BufferAttribute(p,3));this.setAttribute("normal",new Float32BufferAttribute(f,3));this.setAttribute("uv",new Float32BufferAttribute(m,2))}static fromJSON(e){return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)}}var Ti="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var Ei="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var Ai="#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";var Li="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var Ci="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var Ri="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var Pi="vec3 transformed = vec3( position );";var Ii="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var Di="vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";var Bi="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var Vi="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var Ni="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var Ui="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var zi="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var Gi="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var Fi="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var Oi="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";var Hi="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";var ki="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";var Wi="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var ji="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var qi="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var Xi="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var Ji="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var Yi="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var Zi="gl_FragColor = linearToOutputTexel( gl_FragColor );";var Qi="vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";var Ki="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var $i="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var es="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var ts="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var ns="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var rs="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var is="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var ss="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var as="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var os="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";var ls="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";var cs="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var us="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";var hs="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var ds="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";var ps="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var fs="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var ms="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var gs="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var ys="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";var vs="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var xs="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var bs="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var _s="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var Ms="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var ws="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var Ss="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var Ts="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var Es="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";var As="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var Ls="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var Cs="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var Rs="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var Ps="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var Is="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";var Ds="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";var Bs="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";var Vs="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var Ns="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var Us="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var zs="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var Gs="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var Fs="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";var Os="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var Hs="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";var ks="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var Ws="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var js="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var qs="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var Xs="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var Js="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var Ys="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var Zs="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var Qs="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var Ks="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var $s="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var ea="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var ta="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var na="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var ra="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";var ia="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var sa="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var aa="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var oa="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var la="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var ca="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var ua="#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";var ha="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";var da="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var pa="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var fa="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var ma="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var ga="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var ya="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var va="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";const xa="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";const ba="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";const _a="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";const Ma="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";const wa="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";const Sa="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";const Ta="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";const Ea="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";const Aa="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";const La="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";const Ca="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const Ra="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const Pa="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";const Ia="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const Da="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const Ba="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const Va="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";const Na="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const Ua="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";const za="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";const Ga="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const Fa="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const Oa="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";const Ha="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const ka="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const Wa="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";const ja="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";const qa="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";const Xa="#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";const Ja="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";const Ya="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const Za="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";const Qa={alphamap_fragment:Ti,alphamap_pars_fragment:Ei,alphatest_fragment:Ai,alphatest_pars_fragment:Li,aomap_fragment:Ci,aomap_pars_fragment:Ri,begin_vertex:Pi,beginnormal_vertex:Ii,bsdfs:Di,bumpmap_pars_fragment:Bi,clipping_planes_fragment:Vi,clipping_planes_pars_fragment:Ni,clipping_planes_pars_vertex:Ui,clipping_planes_vertex:zi,color_fragment:Gi,color_pars_fragment:Fi,color_pars_vertex:Oi,color_vertex:Hi,common:ki,cube_uv_reflection_fragment:Wi,defaultnormal_vertex:ji,displacementmap_pars_vertex:qi,displacementmap_vertex:Xi,emissivemap_fragment:Ji,emissivemap_pars_fragment:Yi,encodings_fragment:Zi,encodings_pars_fragment:Qi,envmap_fragment:Ki,envmap_common_pars_fragment:$i,envmap_pars_fragment:es,envmap_pars_vertex:ts,envmap_physical_pars_fragment:ds,envmap_vertex:ns,fog_vertex:rs,fog_pars_vertex:is,fog_fragment:ss,fog_pars_fragment:as,gradientmap_pars_fragment:os,lightmap_fragment:ls,lightmap_pars_fragment:cs,lights_lambert_vertex:us,lights_pars_begin:hs,lights_toon_fragment:ps,lights_toon_pars_fragment:fs,lights_phong_fragment:ms,lights_phong_pars_fragment:gs,lights_physical_fragment:ys,lights_physical_pars_fragment:vs,lights_fragment_begin:xs,lights_fragment_maps:bs,lights_fragment_end:_s,logdepthbuf_fragment:Ms,logdepthbuf_pars_fragment:ws,logdepthbuf_pars_vertex:Ss,logdepthbuf_vertex:Ts,map_fragment:Es,map_pars_fragment:As,map_particle_fragment:Ls,map_particle_pars_fragment:Cs,metalnessmap_fragment:Rs,metalnessmap_pars_fragment:Ps,morphnormal_vertex:Is,morphtarget_pars_vertex:Ds,morphtarget_vertex:Bs,normal_fragment_begin:Vs,normal_fragment_maps:Ns,normal_pars_fragment:Us,normal_pars_vertex:zs,normal_vertex:Gs,normalmap_pars_fragment:Fs,clearcoat_normal_fragment_begin:Os,clearcoat_normal_fragment_maps:Hs,clearcoat_pars_fragment:ks,output_fragment:Ws,packing:js,premultiplied_alpha_fragment:qs,project_vertex:Xs,dithering_fragment:Js,dithering_pars_fragment:Ys,roughnessmap_fragment:Zs,roughnessmap_pars_fragment:Qs,shadowmap_pars_fragment:Ks,shadowmap_pars_vertex:$s,shadowmap_vertex:ea,shadowmask_pars_fragment:ta,skinbase_vertex:na,skinning_pars_vertex:ra,skinning_vertex:ia,skinnormal_vertex:sa,specularmap_fragment:aa,specularmap_pars_fragment:oa,tonemapping_fragment:la,tonemapping_pars_fragment:ca,transmission_fragment:ua,transmission_pars_fragment:ha,uv_pars_fragment:da,uv_pars_vertex:pa,uv_vertex:fa,uv2_pars_fragment:ma,uv2_pars_vertex:ga,uv2_vertex:ya,worldpos_vertex:va,background_vert:xa,background_frag:ba,cube_vert:_a,cube_frag:Ma,depth_vert:wa,depth_frag:Sa,distanceRGBA_vert:Ta,distanceRGBA_frag:Ea,equirect_vert:Aa,equirect_frag:La,linedashed_vert:Ca,linedashed_frag:Ra,meshbasic_vert:Pa,meshbasic_frag:Ia,meshlambert_vert:Da,meshlambert_frag:Ba,meshmatcap_vert:Va,meshmatcap_frag:Na,meshnormal_vert:Ua,meshnormal_frag:za,meshphong_vert:Ga,meshphong_frag:Fa,meshphysical_vert:Oa,meshphysical_frag:Ha,meshtoon_vert:ka,meshtoon_frag:Wa,points_vert:ja,points_frag:qa,shadow_vert:Xa,shadow_frag:Ja,sprite_vert:Ya,sprite_frag:Za};const Ka={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Matrix3},uv2Transform:{value:new Matrix3},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}}};const $a={basic:{uniforms:mergeUniforms([Ka.common,Ka.specularmap,Ka.envmap,Ka.aomap,Ka.lightmap,Ka.fog]),vertexShader:Qa.meshbasic_vert,fragmentShader:Qa.meshbasic_frag},lambert:{uniforms:mergeUniforms([Ka.common,Ka.specularmap,Ka.envmap,Ka.aomap,Ka.lightmap,Ka.emissivemap,Ka.fog,Ka.lights,{emissive:{value:new Color(0)}}]),vertexShader:Qa.meshlambert_vert,fragmentShader:Qa.meshlambert_frag},phong:{uniforms:mergeUniforms([Ka.common,Ka.specularmap,Ka.envmap,Ka.aomap,Ka.lightmap,Ka.emissivemap,Ka.bumpmap,Ka.normalmap,Ka.displacementmap,Ka.fog,Ka.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:Qa.meshphong_vert,fragmentShader:Qa.meshphong_frag},standard:{uniforms:mergeUniforms([Ka.common,Ka.envmap,Ka.aomap,Ka.lightmap,Ka.emissivemap,Ka.bumpmap,Ka.normalmap,Ka.displacementmap,Ka.roughnessmap,Ka.metalnessmap,Ka.fog,Ka.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Qa.meshphysical_vert,fragmentShader:Qa.meshphysical_frag},toon:{uniforms:mergeUniforms([Ka.common,Ka.aomap,Ka.lightmap,Ka.emissivemap,Ka.bumpmap,Ka.normalmap,Ka.displacementmap,Ka.gradientmap,Ka.fog,Ka.lights,{emissive:{value:new Color(0)}}]),vertexShader:Qa.meshtoon_vert,fragmentShader:Qa.meshtoon_frag},matcap:{uniforms:mergeUniforms([Ka.common,Ka.bumpmap,Ka.normalmap,Ka.displacementmap,Ka.fog,{matcap:{value:null}}]),vertexShader:Qa.meshmatcap_vert,fragmentShader:Qa.meshmatcap_frag},points:{uniforms:mergeUniforms([Ka.points,Ka.fog]),vertexShader:Qa.points_vert,fragmentShader:Qa.points_frag},dashed:{uniforms:mergeUniforms([Ka.common,Ka.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Qa.linedashed_vert,fragmentShader:Qa.linedashed_frag},depth:{uniforms:mergeUniforms([Ka.common,Ka.displacementmap]),vertexShader:Qa.depth_vert,fragmentShader:Qa.depth_frag},normal:{uniforms:mergeUniforms([Ka.common,Ka.bumpmap,Ka.normalmap,Ka.displacementmap,{opacity:{value:1}}]),vertexShader:Qa.meshnormal_vert,fragmentShader:Qa.meshnormal_frag},sprite:{uniforms:mergeUniforms([Ka.sprite,Ka.fog]),vertexShader:Qa.sprite_vert,fragmentShader:Qa.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null}},vertexShader:Qa.background_vert,fragmentShader:Qa.background_frag},cube:{uniforms:mergeUniforms([Ka.envmap,{opacity:{value:1}}]),vertexShader:Qa.cube_vert,fragmentShader:Qa.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Qa.equirect_vert,fragmentShader:Qa.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([Ka.common,Ka.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Qa.distanceRGBA_vert,fragmentShader:Qa.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([Ka.lights,Ka.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:Qa.shadow_vert,fragmentShader:Qa.shadow_frag}};$a.physical={uniforms:mergeUniforms([$a.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Qa.meshphysical_vert,fragmentShader:Qa.meshphysical_frag};function WebGLBackground(e,t,n,r,i){const s=new Color(0);let a=0;let o;let l;let c=null;let u=0;let p=null;function render(n,i){let f=false;let m=true===i.isScene?i.background:null;m&&m.isTexture&&(m=t.get(m));const g=e.xr;const y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null);if(null===m)setClear(s,a);else if(m&&m.isColor){setClear(m,1);f=true}(e.autoClear||f)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil);if(m&&(m.isCubeTexture||m.mapping===oe)){if(void 0===l){l=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms($a.cube.uniforms),vertexShader:$a.cube.vertexShader,fragmentShader:$a.cube.fragmentShader,side:d,depthTest:false,depthWrite:false,fog:false}));l.geometry.deleteAttribute("normal");l.geometry.deleteAttribute("uv");l.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)};Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}});r.update(l)}l.material.uniforms.envMap.value=m;l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&false===m.isRenderTargetTexture?-1:1;if(c!==m||u!==m.version||p!==e.toneMapping){l.material.needsUpdate=true;c=m;u=m.version;p=e.toneMapping}n.unshift(l,l.geometry,l.material,0,0,null)}else if(m&&m.isTexture){if(void 0===o){o=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms($a.background.uniforms),vertexShader:$a.background.vertexShader,fragmentShader:$a.background.fragmentShader,side:h,depthTest:false,depthWrite:false,fog:false}));o.geometry.deleteAttribute("normal");Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}});r.update(o)}o.material.uniforms.t2D.value=m;true===m.matrixAutoUpdate&&m.updateMatrix();o.material.uniforms.uvTransform.value.copy(m.matrix);if(c!==m||u!==m.version||p!==e.toneMapping){o.material.needsUpdate=true;c=m;u=m.version;p=e.toneMapping}n.unshift(o,o.geometry,o.material,0,0,null)}}function setClear(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,i)}return{getClearColor:function(){return s},setClearColor:function(e,t=1){s.set(e);a=t;setClear(s,a)},getClearAlpha:function(){return a},setClearAlpha:function(e){a=e;setClear(s,a)},render:render}}function WebGLBindingStates(e,t,n,r){const i=e.getParameter(34921);const s=r.isWebGL2?null:t.get("OES_vertex_array_object");const a=r.isWebGL2||null!==s;const o={};const l=createBindingState(null);let c=l;function setup(t,r,i,s,o){let l=false;if(a){const e=getBindingState(s,i,r);if(c!==e){c=e;bindVertexArrayObject(c.object)}l=needsUpdate(s,o);l&&saveCache(s,o)}else{const e=true===r.wireframe;if(c.geometry!==s.id||c.program!==i.id||c.wireframe!==e){c.geometry=s.id;c.program=i.id;c.wireframe=e;l=true}}true===t.isInstancedMesh&&(l=true);null!==o&&n.update(o,34963);if(l){setupVertexAttributes(t,r,i,s);null!==o&&e.bindBuffer(34963,n.get(o).buffer)}}function createVertexArrayObject(){return r.isWebGL2?e.createVertexArray():s.createVertexArrayOES()}function bindVertexArrayObject(t){return r.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function deleteVertexArrayObject(t){return r.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function getBindingState(e,t,n){const r=true===n.wireframe;let i=o[e.id];if(void 0===i){i={};o[e.id]=i}let s=i[t.id];if(void 0===s){s={};i[t.id]=s}let a=s[r];if(void 0===a){a=createBindingState(createVertexArrayObject());s[r]=a}return a}function createBindingState(e){const t=[];const n=[];const r=[];for(let e=0;e<i;e++){t[e]=0;n[e]=0;r[e]=0}return{geometry:null,program:null,wireframe:false,newAttributes:t,enabledAttributes:n,attributeDivisors:r,object:e,attributes:{},index:null}}function needsUpdate(e,t){const n=c.attributes;const r=e.attributes;let i=0;for(const e in r){const t=n[e];const s=r[e];if(void 0===t)return true;if(t.attribute!==s)return true;if(t.data!==s.data)return true;i++}return c.attributesNum!==i||c.index!==t}function saveCache(e,t){const n={};const r=e.attributes;let i=0;for(const e in r){const t=r[e];const s={};s.attribute=t;t.data&&(s.data=t.data);n[e]=s;i++}c.attributes=n;c.attributesNum=i;c.index=t}function initAttributes(){const e=c.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function enableAttribute(e){enableAttributeAndDivisor(e,0)}function enableAttributeAndDivisor(n,i){const s=c.newAttributes;const a=c.enabledAttributes;const o=c.attributeDivisors;s[n]=1;if(0===a[n]){e.enableVertexAttribArray(n);a[n]=1}if(o[n]!==i){const s=r.isWebGL2?e:t.get("ANGLE_instanced_arrays");s[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i);o[n]=i}}function disableUnusedAttributes(){const t=c.newAttributes;const n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)if(n[r]!==t[r]){e.disableVertexAttribArray(r);n[r]=0}}function vertexAttribPointer(t,n,i,s,a,o){true!==r.isWebGL2||5124!==i&&5125!==i?e.vertexAttribPointer(t,n,i,s,a,o):e.vertexAttribIPointer(t,n,i,a,o)}function setupVertexAttributes(i,s,a,o){if(false===r.isWebGL2&&(i.isInstancedMesh||o.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;initAttributes();const l=o.attributes;const c=a.getAttributes();const u=s.defaultAttributeValues;for(const t in c){const r=c[t];if(r.location>=0){let s=l[t];if(void 0===s){"instanceMatrix"===t&&i.instanceMatrix&&(s=i.instanceMatrix);"instanceColor"===t&&i.instanceColor&&(s=i.instanceColor)}if(void 0!==s){const t=s.normalized;const a=s.itemSize;const l=n.get(s);if(void 0===l)continue;const c=l.buffer;const u=l.type;const h=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data;const l=n.stride;const d=s.offset;if(n&&n.isInstancedInterleavedBuffer){for(let e=0;e<r.locationSize;e++)enableAttributeAndDivisor(r.location+e,n.meshPerAttribute);true!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let e=0;e<r.locationSize;e++)enableAttribute(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)vertexAttribPointer(r.location+e,a/r.locationSize,u,t,l*h,(d+a/r.locationSize*e)*h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<r.locationSize;e++)enableAttributeAndDivisor(r.location+e,s.meshPerAttribute);true!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<r.locationSize;e++)enableAttribute(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)vertexAttribPointer(r.location+e,a/r.locationSize,u,t,a*h,a/r.locationSize*e*h)}}else if(void 0!==u){const n=u[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(r.location,n);break;case 3:e.vertexAttrib3fv(r.location,n);break;case 4:e.vertexAttrib4fv(r.location,n);break;default:e.vertexAttrib1fv(r.location,n)}}}}disableUnusedAttributes()}function dispose(){reset();for(const e in o){const t=o[e];for(const e in t){const n=t[e];for(const e in n){deleteVertexArrayObject(n[e].object);delete n[e]}delete t[e]}delete o[e]}}function releaseStatesOfGeometry(e){if(void 0===o[e.id])return;const t=o[e.id];for(const e in t){const n=t[e];for(const e in n){deleteVertexArrayObject(n[e].object);delete n[e]}delete t[e]}delete o[e.id]}function releaseStatesOfProgram(e){for(const t in o){const n=o[t];if(void 0===n[e.id])continue;const r=n[e.id];for(const e in r){deleteVertexArrayObject(r[e].object);delete r[e]}delete n[e.id]}}function reset(){resetDefaultState();if(c!==l){c=l;bindVertexArrayObject(c.object)}}function resetDefaultState(){l.geometry=null;l.program=null;l.wireframe=false}return{setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes}}function WebGLBufferRenderer(e,t,n,r){const i=r.isWebGL2;let s;function setMode(e){s=e}function render(t,r){e.drawArrays(s,t,r);n.update(r,s,1)}function renderInstances(r,a,o){if(0===o)return;let l,c;if(i){l=e;c="drawArraysInstanced"}else{l=t.get("ANGLE_instanced_arrays");c="drawArraysInstancedANGLE";if(null===l){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}}l[c](s,r,a,o);n.update(a,s,o)}this.setMode=setMode;this.render=render;this.renderInstances=renderInstances}function WebGLCapabilities(e,t,n){let r;function getMaxAnisotropy(){if(void 0!==r)return r;if(true===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function getMaxPrecision(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const i="undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let s=void 0!==n.precision?n.precision:"highp";const a=getMaxPrecision(s);if(a!==s){console.warn("THREE.WebGLRenderer:",s,"not supported, using",a,"instead.");s=a}const o=i||t.has("WEBGL_draw_buffers");const l=true===n.logarithmicDepthBuffer;const c=e.getParameter(34930);const u=e.getParameter(35660);const h=e.getParameter(3379);const d=e.getParameter(34076);const p=e.getParameter(34921);const f=e.getParameter(36347);const m=e.getParameter(36348);const g=e.getParameter(36349);const y=u>0;const x=i||t.has("OES_texture_float");const b=y&&x;const _=i?e.getParameter(36183):0;return{isWebGL2:i,drawBuffers:o,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:s,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:f,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:x,floatVertexTextures:b,maxSamples:_}}function WebGLClipping(e){const t=this;let n=null,r=0,i=false,s=false;const a=new Plane,o=new Matrix3,l={value:null,needsUpdate:false};this.uniform=l;this.numPlanes=0;this.numIntersection=0;this.init=function(e,t,s){const a=0!==e.length||t||0!==r||i;i=t;n=projectPlanes(e,s,0);r=e.length;return a};this.beginShadows=function(){s=true;projectPlanes(null)};this.endShadows=function(){s=false;resetGlobalState()};this.setState=function(t,a,o){const c=t.clippingPlanes,u=t.clipIntersection,h=t.clipShadows;const d=e.get(t);if(!i||null===c||0===c.length||s&&!h)s?projectPlanes(null):resetGlobalState();else{const e=s?0:r,t=4*e;let i=d.clippingState||null;l.value=i;i=projectPlanes(c,a,t,o);for(let e=0;e!==t;++e)i[e]=n[e];d.clippingState=i;this.numIntersection=u?this.numPlanes:0;this.numPlanes+=e}};function resetGlobalState(){if(l.value!==n){l.value=n;l.needsUpdate=r>0}t.numPlanes=r;t.numIntersection=0}function projectPlanes(e,n,r,i){const s=null!==e?e.length:0;let c=null;if(0!==s){c=l.value;if(true!==i||null===c){const t=r+4*s,i=n.matrixWorldInverse;o.getNormalMatrix(i);(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=r;t!==s;++t,n+=4){a.copy(e[t]).applyMatrix4(i,o);a.normal.toArray(c,n);c[n+3]=a.constant}}l.value=c;l.needsUpdate=true}t.numPlanes=s;t.numIntersection=0;return c}}function WebGLCubeMaps(e){let t=new WeakMap;function mapTextureMapping(e,t){t===se?e.mapping=re:t===ae&&(e.mapping=ie);return e}function get(n){if(n&&n.isTexture&&false===n.isRenderTargetTexture){const r=n.mapping;if(r===se||r===ae){if(t.has(n)){const e=t.get(n).texture;return mapTextureMapping(e,n.mapping)}{const r=n.image;if(r&&r.height>0){const i=e.getRenderTarget();const s=new WebGLCubeRenderTarget(r.height/2);s.fromEquirectangularTexture(e,n);t.set(n,s);e.setRenderTarget(i);n.addEventListener("dispose",onTextureDispose);return mapTextureMapping(s.texture,n.mapping)}return null}}}return n}function onTextureDispose(e){const n=e.target;n.removeEventListener("dispose",onTextureDispose);const r=t.get(n);if(void 0!==r){t.delete(n);r.dispose()}}function dispose(){t=new WeakMap}return{get:get,dispose:dispose}}class OrthographicCamera extends Camera{constructor(e=-1,t=1,n=1,r=-1,i=.1,s=2e3){super();this.type="OrthographicCamera";this.zoom=1;this.view=null;this.left=e;this.right=t;this.top=n;this.bottom=r;this.near=i;this.far=s;this.updateProjectionMatrix()}copy(e,t){super.copy(e,t);this.left=e.left;this.right=e.right;this.top=e.top;this.bottom=e.bottom;this.near=e.near;this.far=e.far;this.zoom=e.zoom;this.view=null===e.view?null:Object.assign({},e.view);return this}setViewOffset(e,t,n,r,i,s){null===this.view&&(this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=true;this.view.fullWidth=e;this.view.fullHeight=t;this.view.offsetX=n;this.view.offsetY=r;this.view.width=i;this.view.height=s;this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=false);this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom);const t=(this.top-this.bottom)/(2*this.zoom);const n=(this.right+this.left)/2;const r=(this.top+this.bottom)/2;let i=n-e;let s=n+e;let a=r+t;let o=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom;const t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=e*this.view.offsetX;s=i+e*this.view.width;a-=t*this.view.offsetY;o=a-t*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,o,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);t.object.zoom=this.zoom;t.object.left=this.left;t.object.right=this.right;t.object.top=this.top;t.object.bottom=this.bottom;t.object.near=this.near;t.object.far=this.far;null!==this.view&&(t.object.view=Object.assign({},this.view));return t}}OrthographicCamera.prototype.isOrthographicCamera=true;class RawShaderMaterial extends ShaderMaterial{constructor(e){super(e);this.type="RawShaderMaterial"}}RawShaderMaterial.prototype.isRawShaderMaterial=true;const eo=4;const to=8;const no=Math.pow(2,to);const ro=[.125,.215,.35,.446,.526,.582];const io=to-eo+1+ro.length;const so=20;const ao={[Xt]:0,[Jt]:1};const oo=new OrthographicCamera;const{_lodPlanes:lo,_sizeLods:co,_sigmas:uo}=_createPlanes();const ho=new Color;let po=null;const fo=(1+Math.sqrt(5))/2;const mo=1/fo;const go=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,fo,mo),new Vector3(0,fo,-mo),new Vector3(mo,0,fo),new Vector3(-mo,0,fo),new Vector3(fo,mo,0),new Vector3(-fo,mo,0)];class PMREMGenerator{constructor(e){this._renderer=e;this._pingPongRenderTarget=null;this._blurMaterial=_getBlurShader(so);this._equirectShader=null;this._cubemapShader=null;this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){po=this._renderer.getRenderTarget();const i=this._allocateTargets();this._sceneToCubeUV(e,n,r,i);t>0&&this._blur(i,0,0,t);this._applyPMREM(i);this._cleanup(i);return i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){if(null===this._cubemapShader){this._cubemapShader=_getCubemapShader();this._compileMaterial(this._cubemapShader)}}compileEquirectangularShader(){if(null===this._equirectShader){this._equirectShader=_getEquirectShader();this._compileMaterial(this._equirectShader)}}dispose(){this._blurMaterial.dispose();null!==this._cubemapShader&&this._cubemapShader.dispose();null!==this._equirectShader&&this._equirectShader.dispose();for(let e=0;e<lo.length;e++)lo[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose();this._renderer.setRenderTarget(po);e.scissorTest=false;_setViewport(e,0,0,e.width,e.height)}_fromTexture(e){po=this._renderer.getRenderTarget();const t=this._allocateTargets(e);this._textureToCubeUV(e,t);this._applyPMREM(t);this._cleanup(t);return t}_allocateTargets(e){const t={magFilter:ye,minFilter:ye,generateMipmaps:false,type:Ce,format:Ne,encoding:Xt,depthBuffer:false};const n=_createRenderTarget(t);n.depthBuffer=!e;this._pingPongRenderTarget=_createRenderTarget(t);return n}_compileMaterial(e){const t=new Mesh(lo[0],e);this._renderer.compile(t,oo)}_sceneToCubeUV(e,t,n,r){const i=90;const s=1;const a=new PerspectiveCamera(i,s,t,n);const o=[1,-1,1,1,1,1];const l=[1,1,1,-1,-1,-1];const c=this._renderer;const u=c.autoClear;const h=c.toneMapping;c.getClearColor(ho);c.toneMapping=Z;c.autoClear=false;const p=new MeshBasicMaterial({name:"PMREM.Background",side:d,depthWrite:false,depthTest:false});const f=new Mesh(new BoxGeometry,p);let m=false;const g=e.background;if(g){if(g.isColor){p.color.copy(g);e.background=null;m=true}}else{p.color.copy(ho);m=true}for(let t=0;t<6;t++){const n=t%3;if(0==n){a.up.set(0,o[t],0);a.lookAt(l[t],0,0)}else if(1==n){a.up.set(0,0,o[t]);a.lookAt(0,l[t],0)}else{a.up.set(0,o[t],0);a.lookAt(0,0,l[t])}_setViewport(r,n*no,t>2?no:0,no,no);c.setRenderTarget(r);m&&c.render(f,a);c.render(e,a)}f.geometry.dispose();f.material.dispose();c.toneMapping=h;c.autoClear=u;e.background=g}_setEncoding(e,t){true===this._renderer.capabilities.isWebGL2&&t.format===Ne&&t.type===Me&&t.encoding===Jt?e.value=ao[Xt]:e.value=ao[t.encoding]}_textureToCubeUV(e,t){const n=this._renderer;const r=e.mapping===re||e.mapping===ie;r?null==this._cubemapShader&&(this._cubemapShader=_getCubemapShader()):null==this._equirectShader&&(this._equirectShader=_getEquirectShader());const i=r?this._cubemapShader:this._equirectShader;const s=new Mesh(lo[0],i);const a=i.uniforms;a.envMap.value=e;r||a.texelSize.value.set(1/e.image.width,1/e.image.height);this._setEncoding(a.inputEncoding,e);_setViewport(t,0,0,3*no,2*no);n.setRenderTarget(t);n.render(s,oo)}_applyPMREM(e){const t=this._renderer;const n=t.autoClear;t.autoClear=false;for(let t=1;t<io;t++){const n=Math.sqrt(uo[t]*uo[t]-uo[t-1]*uo[t-1]);const r=go[(t-1)%go.length];this._blur(e,t-1,t,n,r)}t.autoClear=n}_blur(e,t,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,n,r,"latitudinal",i);this._halfBlur(s,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,s,a){const o=this._renderer;const l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3;const u=new Mesh(lo[r],l);const h=l.uniforms;const d=co[n]-1;const p=isFinite(i)?Math.PI/(2*d):2*Math.PI/(2*so-1);const f=i/p;const m=isFinite(i)?1+Math.floor(c*f):so;m>so&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${so}`);const g=[];let y=0;for(let e=0;e<so;++e){const t=e/f;const n=Math.exp(-t*t/2);g.push(n);0==e?y+=n:e<m&&(y+=2*n)}for(let e=0;e<g.length;e++)g[e]=g[e]/y;h.envMap.value=e.texture;h.samples.value=m;h.weights.value=g;h.latitudinal.value="latitudinal"===s;a&&(h.poleAxis.value=a);h.dTheta.value=p;h.mipInt.value=to-n;const x=co[r];const b=3*Math.max(0,no-2*x);const _=(0===r?0:2*no)+2*x*(r>to-eo?r-to+eo:0);_setViewport(t,b,_,3*x,2*x);o.setRenderTarget(t);o.render(u,oo)}}function _createPlanes(){const e=[];const t=[];const n=[];let r=to;for(let i=0;i<io;i++){const s=Math.pow(2,r);t.push(s);let a=1/s;i>to-eo?a=ro[i-to+eo-1]:0==i&&(a=0);n.push(a);const o=1/(s-1);const l=-o/2;const c=1+o/2;const u=[l,l,c,l,c,c,l,l,c,c,l,c];const h=6;const d=6;const p=3;const f=2;const m=1;const g=new Float32Array(p*d*h);const y=new Float32Array(f*d*h);const x=new Float32Array(m*d*h);for(let e=0;e<h;e++){const t=e%3*2/3-1;const n=e>2?0:-1;const r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];g.set(r,p*d*e);y.set(u,f*d*e);const i=[e,e,e,e,e,e];x.set(i,m*d*e)}const b=new BufferGeometry;b.setAttribute("position",new BufferAttribute(g,p));b.setAttribute("uv",new BufferAttribute(y,f));b.setAttribute("faceIndex",new BufferAttribute(x,m));e.push(b);r>eo&&r--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function _createRenderTarget(e){const t=new WebGLRenderTarget(3*no,3*no,e);t.texture.mapping=oe;t.texture.name="PMREM.cubeUv";t.scissorTest=true;return t}function _setViewport(e,t,n,r,i){e.viewport.set(t,n,r,i);e.scissor.set(t,n,r,i)}function _getBlurShader(e){const t=new Float32Array(e);const n=new Vector3(0,1,0);const r=new RawShaderMaterial({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:false},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,blending:g,depthTest:false,depthWrite:false});return r}function _getEquirectShader(){const e=new Vector2(1,1);const t=new RawShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:ao[Xt]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t`,blending:g,depthTest:false,depthWrite:false});return t}function _getCubemapShader(){const e=new RawShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:ao[Xt]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n\t\t\t}\n\t\t`,blending:g,depthTest:false,depthWrite:false});return e}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function _getEncodings(){return"\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function WebGLCubeUVMaps(e){let t=new WeakMap;let n=null;function get(r){if(r&&r.isTexture&&false===r.isRenderTargetTexture){const i=r.mapping;const s=i===se||i===ae;const a=i===re||i===ie;if(s||a){if(t.has(r))return t.get(r).texture;{const i=r.image;if(s&&i&&i.height>0||a&&i&&isCubeTextureComplete(i)){const i=e.getRenderTarget();null===n&&(n=new PMREMGenerator(e));const a=s?n.fromEquirectangular(r):n.fromCubemap(r);t.set(r,a);e.setRenderTarget(i);r.addEventListener("dispose",onTextureDispose);return a.texture}return null}}}return r}function isCubeTextureComplete(e){let t=0;const n=6;for(let r=0;r<n;r++)void 0!==e[r]&&t++;return t===n}function onTextureDispose(e){const n=e.target;n.removeEventListener("dispose",onTextureDispose);const r=t.get(n);if(void 0!==r){t.delete(n);r.dispose()}}function dispose(){t=new WeakMap;if(null!==n){n.dispose();n=null}}return{get:get,dispose:dispose}}function WebGLExtensions(e){const t={};function getExtension(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}t[n]=r;return r}return{has:function(e){return null!==getExtension(e)},init:function(e){if(e.isWebGL2)getExtension("EXT_color_buffer_float");else{getExtension("WEBGL_depth_texture");getExtension("OES_texture_float");getExtension("OES_texture_half_float");getExtension("OES_texture_half_float_linear");getExtension("OES_standard_derivatives");getExtension("OES_element_index_uint");getExtension("OES_vertex_array_object");getExtension("ANGLE_instanced_arrays")}getExtension("OES_texture_float_linear");getExtension("EXT_color_buffer_half_float");getExtension("WEBGL_multisampled_render_to_texture")},get:function(e){const t=getExtension(e);null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported.");return t}}}function WebGLGeometries(e,t,n,r){const i={};const s=new WeakMap;function onGeometryDispose(e){const a=e.target;null!==a.index&&t.remove(a.index);for(const e in a.attributes)t.remove(a.attributes[e]);a.removeEventListener("dispose",onGeometryDispose);delete i[a.id];const o=s.get(a);if(o){t.remove(o);s.delete(a)}r.releaseStatesOfGeometry(a);true===a.isInstancedBufferGeometry&&delete a._maxInstanceCount;n.memory.geometries--}function get(e,t){if(true===i[t.id])return t;t.addEventListener("dispose",onGeometryDispose);i[t.id]=true;n.memory.geometries++;return t}function update(e){const n=e.attributes;for(const e in n)t.update(n[e],34962);const r=e.morphAttributes;for(const e in r){const n=r[e];for(let e=0,r=n.length;e<r;e++)t.update(n[e],34962)}}function updateWireframeAttribute(e){const n=[];const r=e.index;const i=e.attributes.position;let a=0;if(null!==r){const e=r.array;a=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0];const i=e[t+1];const s=e[t+2];n.push(r,i,i,s,s,r)}}else{const e=i.array;a=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0;const r=t+1;const i=t+2;n.push(e,r,r,i,i,e)}}const o=new(arrayMax(n)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(n,1);o.version=a;const l=s.get(e);l&&t.remove(l);s.set(e,o)}function getWireframeAttribute(e){const t=s.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&updateWireframeAttribute(e)}else updateWireframeAttribute(e);return s.get(e)}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute}}function WebGLIndexedBufferRenderer(e,t,n,r){const i=r.isWebGL2;let s;function setMode(e){s=e}let a,o;function setIndex(e){a=e.type;o=e.bytesPerElement}function render(t,r){e.drawElements(s,r,a,t*o);n.update(r,s,1)}function renderInstances(r,l,c){if(0===c)return;let u,h;if(i){u=e;h="drawElementsInstanced"}else{u=t.get("ANGLE_instanced_arrays");h="drawElementsInstancedANGLE";if(null===u){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}}u[h](s,l,a,r*o,c);n.update(l,s,c)}this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances}function WebGLInfo(e){const t={geometries:0,textures:0};const n={frame:0,calls:0,triangles:0,points:0,lines:0};function update(e,t,r){n.calls++;switch(t){case 4:n.triangles+=r*(e/3);break;case 1:n.lines+=r*(e/2);break;case 3:n.lines+=r*(e-1);break;case 2:n.lines+=r*e;break;case 0:n.points+=r*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t);break}}function reset(){n.frame++;n.calls=0;n.triangles=0;n.points=0;n.lines=0}return{memory:t,render:n,programs:null,autoReset:true,reset:reset,update:update}}class DataTexture2DArray extends Texture{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r};this.magFilter=de;this.minFilter=de;this.wrapR=ue;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1}}DataTexture2DArray.prototype.isDataTexture2DArray=true;function numericalSort(e,t){return e[0]-t[0]}function absNumericalSort(e,t){return Math.abs(t[1])-Math.abs(e[1])}function denormalize(e,t){let n=1;const r=t.isInterleavedBufferAttribute?t.data.array:t.array;r instanceof Int8Array?n=127:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r);e.divideScalar(n)}function WebGLMorphtargets(e,t,n){const r={};const i=new Float32Array(8);const s=new WeakMap;const a=new Vector3;const o=[];for(let e=0;e<8;e++)o[e]=[e,0];function update(l,c,u,h){const d=l.morphTargetInfluences;if(true===t.isWebGL2){const r=c.morphAttributes.position.length;let i=s.get(c);if(void 0===i||i.count!==r){void 0!==i&&i.texture.dispose();const e=void 0!==c.morphAttributes.normal;const n=c.morphAttributes.position;const o=c.morphAttributes.normal||[];const l=c.attributes.position.count;const u=true===e?2:1;let h=l*u;let d=1;if(h>t.maxTextureSize){d=Math.ceil(h/t.maxTextureSize);h=t.maxTextureSize}const p=new Float32Array(h*d*4*r);const f=new DataTexture2DArray(p,h,d,r);f.format=Ne;f.type=Le;f.needsUpdate=true;const m=4*u;for(let t=0;t<r;t++){const r=n[t];const i=o[t];const s=h*d*4*t;for(let t=0;t<r.count;t++){a.fromBufferAttribute(r,t);true===r.normalized&&denormalize(a,r);const n=t*m;p[s+n+0]=a.x;p[s+n+1]=a.y;p[s+n+2]=a.z;p[s+n+3]=0;if(true===e){a.fromBufferAttribute(i,t);true===i.normalized&&denormalize(a,i);p[s+n+4]=a.x;p[s+n+5]=a.y;p[s+n+6]=a.z;p[s+n+7]=0}}}i={count:r,texture:f,size:new Vector2(h,d)};s.set(c,i)}let o=0;for(let e=0;e<d.length;e++)o+=d[e];const l=c.morphTargetsRelative?1:1-o;h.getUniforms().setValue(e,"morphTargetBaseInfluence",l);h.getUniforms().setValue(e,"morphTargetInfluences",d);h.getUniforms().setValue(e,"morphTargetsTexture",i.texture,n);h.getUniforms().setValue(e,"morphTargetsTextureSize",i.size)}else{const t=void 0===d?0:d.length;let n=r[c.id];if(void 0===n||n.length!==t){n=[];for(let e=0;e<t;e++)n[e]=[e,0];r[c.id]=n}for(let e=0;e<t;e++){const t=n[e];t[0]=e;t[1]=d[e]}n.sort(absNumericalSort);for(let e=0;e<8;e++)if(e<t&&n[e][1]){o[e][0]=n[e][0];o[e][1]=n[e][1]}else{o[e][0]=Number.MAX_SAFE_INTEGER;o[e][1]=0}o.sort(numericalSort);const s=c.morphAttributes.position;const a=c.morphAttributes.normal;let l=0;for(let e=0;e<8;e++){const t=o[e];const n=t[0];const r=t[1];if(n!==Number.MAX_SAFE_INTEGER&&r){s&&c.getAttribute("morphTarget"+e)!==s[n]&&c.setAttribute("morphTarget"+e,s[n]);a&&c.getAttribute("morphNormal"+e)!==a[n]&&c.setAttribute("morphNormal"+e,a[n]);i[e]=r;l+=r}else{s&&true===c.hasAttribute("morphTarget"+e)&&c.deleteAttribute("morphTarget"+e);a&&true===c.hasAttribute("morphNormal"+e)&&c.deleteAttribute("morphNormal"+e);i[e]=0}}const u=c.morphTargetsRelative?1:1-l;h.getUniforms().setValue(e,"morphTargetBaseInfluence",u);h.getUniforms().setValue(e,"morphTargetInfluences",i)}}return{update:update}}function WebGLObjects(e,t,n,r){let i=new WeakMap;function update(e){const s=r.render.frame;const a=e.geometry;const o=t.get(e,a);if(i.get(o)!==s){t.update(o);i.set(o,s)}if(e.isInstancedMesh){false===e.hasEventListener("dispose",onInstancedMeshDispose)&&e.addEventListener("dispose",onInstancedMeshDispose);n.update(e.instanceMatrix,34962);null!==e.instanceColor&&n.update(e.instanceColor,34962)}return o}function dispose(){i=new WeakMap}function onInstancedMeshDispose(e){const t=e.target;t.removeEventListener("dispose",onInstancedMeshDispose);n.remove(t.instanceMatrix);null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:update,dispose:dispose}}class DataTexture3D extends Texture{constructor(e=null,t=1,n=1,r=1){super(null);this.image={data:e,width:t,height:n,depth:r};this.magFilter=de;this.minFilter=de;this.wrapR=ue;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1}}DataTexture3D.prototype.isDataTexture3D=true;const yo=new Texture;const vo=new DataTexture2DArray;const xo=new DataTexture3D;const bo=new CubeTexture;const _o=[];const Mo=[];const wo=new Float32Array(16);const So=new Float32Array(9);const To=new Float32Array(4);function flatten(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let s=_o[i];if(void 0===s){s=new Float32Array(i);_o[i]=s}if(0!==t){r.toArray(s,0);for(let r=1,i=0;r!==t;++r){i+=n;e[r].toArray(s,i)}}return s}function arraysEqual(e,t){if(e.length!==t.length)return false;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return false;return true}function copyArray(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function allocTexUnits(e,t){let n=Mo[t];if(void 0===n){n=new Int32Array(t);Mo[t]=n}for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function setValueV1f(e,t){const n=this.cache;if(n[0]!==t){e.uniform1f(this.addr,t);n[0]=t}}function setValueV2f(e,t){const n=this.cache;if(void 0!==t.x){if(n[0]!==t.x||n[1]!==t.y){e.uniform2f(this.addr,t.x,t.y);n[0]=t.x;n[1]=t.y}}else{if(arraysEqual(n,t))return;e.uniform2fv(this.addr,t);copyArray(n,t)}}function setValueV3f(e,t){const n=this.cache;if(void 0!==t.x){if(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z){e.uniform3f(this.addr,t.x,t.y,t.z);n[0]=t.x;n[1]=t.y;n[2]=t.z}}else if(void 0!==t.r){if(n[0]!==t.r||n[1]!==t.g||n[2]!==t.b){e.uniform3f(this.addr,t.r,t.g,t.b);n[0]=t.r;n[1]=t.g;n[2]=t.b}}else{if(arraysEqual(n,t))return;e.uniform3fv(this.addr,t);copyArray(n,t)}}function setValueV4f(e,t){const n=this.cache;if(void 0!==t.x){if(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z||n[3]!==t.w){e.uniform4f(this.addr,t.x,t.y,t.z,t.w);n[0]=t.x;n[1]=t.y;n[2]=t.z;n[3]=t.w}}else{if(arraysEqual(n,t))return;e.uniform4fv(this.addr,t);copyArray(n,t)}}function setValueM2(e,t){const n=this.cache;const r=t.elements;if(void 0===r){if(arraysEqual(n,t))return;e.uniformMatrix2fv(this.addr,false,t);copyArray(n,t)}else{if(arraysEqual(n,r))return;To.set(r);e.uniformMatrix2fv(this.addr,false,To);copyArray(n,r)}}function setValueM3(e,t){const n=this.cache;const r=t.elements;if(void 0===r){if(arraysEqual(n,t))return;e.uniformMatrix3fv(this.addr,false,t);copyArray(n,t)}else{if(arraysEqual(n,r))return;So.set(r);e.uniformMatrix3fv(this.addr,false,So);copyArray(n,r)}}function setValueM4(e,t){const n=this.cache;const r=t.elements;if(void 0===r){if(arraysEqual(n,t))return;e.uniformMatrix4fv(this.addr,false,t);copyArray(n,t)}else{if(arraysEqual(n,r))return;wo.set(r);e.uniformMatrix4fv(this.addr,false,wo);copyArray(n,r)}}function setValueV1i(e,t){const n=this.cache;if(n[0]!==t){e.uniform1i(this.addr,t);n[0]=t}}function setValueV2i(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform2iv(this.addr,t);copyArray(n,t)}}function setValueV3i(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform3iv(this.addr,t);copyArray(n,t)}}function setValueV4i(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform4iv(this.addr,t);copyArray(n,t)}}function setValueV1ui(e,t){const n=this.cache;if(n[0]!==t){e.uniform1ui(this.addr,t);n[0]=t}}function setValueV2ui(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform2uiv(this.addr,t);copyArray(n,t)}}function setValueV3ui(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform3uiv(this.addr,t);copyArray(n,t)}}function setValueV4ui(e,t){const n=this.cache;if(!arraysEqual(n,t)){e.uniform4uiv(this.addr,t);copyArray(n,t)}}function setValueT1(e,t,n){const r=this.cache;const i=n.allocateTextureUnit();if(r[0]!==i){e.uniform1i(this.addr,i);r[0]=i}n.safeSetTexture2D(t||yo,i)}function setValueT3D1(e,t,n){const r=this.cache;const i=n.allocateTextureUnit();if(r[0]!==i){e.uniform1i(this.addr,i);r[0]=i}n.setTexture3D(t||xo,i)}function setValueT6(e,t,n){const r=this.cache;const i=n.allocateTextureUnit();if(r[0]!==i){e.uniform1i(this.addr,i);r[0]=i}n.safeSetTextureCube(t||bo,i)}function setValueT2DArray1(e,t,n){const r=this.cache;const i=n.allocateTextureUnit();if(r[0]!==i){e.uniform1i(this.addr,i);r[0]=i}n.setTexture2DArray(t||vo,i)}function getSingularSetter(e){switch(e){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(e,t){e.uniform1fv(this.addr,t)}function setValueV2fArray(e,t){const n=flatten(t,this.size,2);e.uniform2fv(this.addr,n)}function setValueV3fArray(e,t){const n=flatten(t,this.size,3);e.uniform3fv(this.addr,n)}function setValueV4fArray(e,t){const n=flatten(t,this.size,4);e.uniform4fv(this.addr,n)}function setValueM2Array(e,t){const n=flatten(t,this.size,4);e.uniformMatrix2fv(this.addr,false,n)}function setValueM3Array(e,t){const n=flatten(t,this.size,9);e.uniformMatrix3fv(this.addr,false,n)}function setValueM4Array(e,t){const n=flatten(t,this.size,16);e.uniformMatrix4fv(this.addr,false,n)}function setValueV1iArray(e,t){e.uniform1iv(this.addr,t)}function setValueV2iArray(e,t){e.uniform2iv(this.addr,t)}function setValueV3iArray(e,t){e.uniform3iv(this.addr,t)}function setValueV4iArray(e,t){e.uniform4iv(this.addr,t)}function setValueV1uiArray(e,t){e.uniform1uiv(this.addr,t)}function setValueV2uiArray(e,t){e.uniform2uiv(this.addr,t)}function setValueV3uiArray(e,t){e.uniform3uiv(this.addr,t)}function setValueV4uiArray(e,t){e.uniform4uiv(this.addr,t)}function setValueT1Array(e,t,n){const r=t.length;const i=allocTexUnits(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.safeSetTexture2D(t[e]||yo,i[e])}function setValueT3DArray(e,t,n){const r=t.length;const i=allocTexUnits(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture3D(t[e]||xo,i[e])}function setValueT6Array(e,t,n){const r=t.length;const i=allocTexUnits(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.safeSetTextureCube(t[e]||bo,i[e])}function setValueT2DArrayArray(e,t,n){const r=t.length;const i=allocTexUnits(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2DArray(t[e]||vo,i[e])}function getPureArraySetter(e){switch(e){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}function SingleUniform(e,t,n){this.id=e;this.addr=n;this.cache=[];this.setValue=getSingularSetter(t.type)}function PureArrayUniform(e,t,n){this.id=e;this.addr=n;this.cache=[];this.size=t.size;this.setValue=getPureArraySetter(t.type)}PureArrayUniform.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length));copyArray(t,e)};function StructuredUniform(e){this.id=e;this.seq=[];this.map={}}StructuredUniform.prototype.setValue=function(e,t,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(e,t[s.id],n)}};const Eo=/(\w+)(\])?(\[|\.)?/g;function addUniform(e,t){e.seq.push(t);e.map[t.id]=t}function parseUniform(e,t,n){const r=e.name,i=r.length;Eo.lastIndex=0;while(true){const s=Eo.exec(r),a=Eo.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];l&&(o|=0);if(void 0===c||"["===c&&a+2===i){addUniform(n,void 0===c?new SingleUniform(o,e,t):new PureArrayUniform(o,e,t));break}{const e=n.map;let t=e[o];if(void 0===t){t=new StructuredUniform(o);addUniform(n,t)}n=t}}}function WebGLUniforms(e,t){this.seq=[];this.map={};const n=e.getProgramParameter(t,35718);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r),i=e.getUniformLocation(t,n.name);parseUniform(n,i,this)}}WebGLUniforms.prototype.setValue=function(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)};WebGLUniforms.prototype.setOptional=function(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)};WebGLUniforms.upload=function(e,t,n,r){for(let i=0,s=t.length;i!==s;++i){const s=t[i],a=n[s.id];false!==a.needsUpdate&&s.setValue(e,a.value,r)}};WebGLUniforms.seqWithValue=function(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n};function WebGLShader(e,t,n){const r=e.createShader(t);e.shaderSource(r,n);e.compileShader(r);return r}let Ao=0;function addLineNumbers(e){const t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join("\n")}function getEncodingComponents(e){switch(e){case Xt:return["Linear","( value )"];case Jt:return["sRGB","( value )"];default:console.warn("THREE.WebGLProgram: Unsupported encoding:",e);return["Linear","( value )"]}}function getShaderErrors(e,t,n){const r=e.getShaderParameter(t,35713);const i=e.getShaderInfoLog(t).trim();return r&&""===i?"":n.toUpperCase()+"\n\n"+i+"\n\n"+addLineNumbers(e.getShaderSource(t))}function getTexelDecodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function getTexelEncodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function getToneMappingFunction(e,t){let n;switch(t){case Q:n="Linear";break;case K:n="Reinhard";break;case $:n="OptimizedCineon";break;case ee:n="ACESFilmic";break;case te:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t);n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function generateExtensions(e){const t=[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return t.filter(filterEmptyLine).join("\n")}function generateDefines(e){const t=[];for(const n in e){const r=e[n];false!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}function fetchAttributeLocations(e,t){const n={};const r=e.getProgramParameter(t,35721);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i);const s=r.name;let a=1;35674===r.type&&(a=2);35675===r.type&&(a=3);35676===r.type&&(a=4);n[s]={type:r.type,location:e.getAttribLocation(t,s),locationSize:a}}return n}function filterEmptyLine(e){return""!==e}function replaceLightNums(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function replaceClippingPlaneNums(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Lo=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(e){return e.replace(Lo,includeReplacer)}function includeReplacer(e,t){const n=Qa[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return resolveIncludes(n)}const Co=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;const Ro=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(e){return e.replace(Ro,loopReplacer).replace(Co,deprecatedLoopReplacer)}function deprecatedLoopReplacer(e,t,n,r){console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");return loopReplacer(e,t,n,r)}function loopReplacer(e,t,n,r){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}function generatePrecision(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION");return t}function generateShadowMapTypeDefine(e){let t="SHADOWMAP_TYPE_BASIC";e.shadowMapType===l?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===c?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===u&&(t="SHADOWMAP_TYPE_VSM");return t}function generateEnvMapTypeDefine(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case re:case ie:t="ENVMAP_TYPE_CUBE";break;case oe:case le:t="ENVMAP_TYPE_CUBE_UV";break}return t}function generateEnvMapModeDefine(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case ie:case le:t="ENVMAP_MODE_REFRACTION";break}return t}function generateEnvMapBlendingDefine(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case X:t="ENVMAP_BLENDING_MULTIPLY";break;case J:t="ENVMAP_BLENDING_MIX";break;case Y:t="ENVMAP_BLENDING_ADD";break}return t}function WebGLProgram(e,t,n,r){const i=e.getContext();const s=n.defines;let a=n.vertexShader;let o=n.fragmentShader;const l=generateShadowMapTypeDefine(n);const c=generateEnvMapTypeDefine(n);const u=generateEnvMapModeDefine(n);const h=generateEnvMapBlendingDefine(n);const d=n.isWebGL2?"":generateExtensions(n);const p=generateDefines(s);const f=i.createProgram();let m,g;let y=n.glslVersion?"#version "+n.glslVersion+"\n":"";if(n.isRawShaderMaterial){m=[p].filter(filterEmptyLine).join("\n");m.length>0&&(m+="\n");g=[d,p].filter(filterEmptyLine).join("\n");g.length>0&&(g+="\n")}else{m=[generatePrecision(n),"#define SHADER_NAME "+n.shaderName,p,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&false===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(filterEmptyLine).join("\n");g=[d,generatePrecision(n),"#define SHADER_NAME "+n.shaderName,p,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Z?"#define TONE_MAPPING":"",n.toneMapping!==Z?Qa.tonemapping_pars_fragment:"",n.toneMapping!==Z?getToneMappingFunction("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.format===Ve?"#define OPAQUE":"",Qa.encodings_pars_fragment,n.map?getTexelDecodingFunction("mapTexelToLinear",n.mapEncoding):"",n.matcap?getTexelDecodingFunction("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?getTexelDecodingFunction("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?getTexelDecodingFunction("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.specularColorMap?getTexelDecodingFunction("specularColorMapTexelToLinear",n.specularColorMapEncoding):"",n.sheenColorMap?getTexelDecodingFunction("sheenColorMapTexelToLinear",n.sheenColorMapEncoding):"",n.lightMap?getTexelDecodingFunction("lightMapTexelToLinear",n.lightMapEncoding):"",getTexelEncodingFunction("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(filterEmptyLine).join("\n")}a=resolveIncludes(a);a=replaceLightNums(a,n);a=replaceClippingPlaneNums(a,n);o=resolveIncludes(o);o=replaceLightNums(o,n);o=replaceClippingPlaneNums(o,n);a=unrollLoops(a);o=unrollLoops(o);if(n.isWebGL2&&true!==n.isRawShaderMaterial){y="#version 300 es\n";m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+m;g=["#define varying in",n.glslVersion===En?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===En?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+g}const x=y+m+a;const b=y+g+o;const _=WebGLShader(i,35633,x);const M=WebGLShader(i,35632,b);i.attachShader(f,_);i.attachShader(f,M);void 0!==n.index0AttributeName?i.bindAttribLocation(f,0,n.index0AttributeName):true===n.morphTargets&&i.bindAttribLocation(f,0,"position");i.linkProgram(f);if(e.debug.checkShaderErrors){const e=i.getProgramInfoLog(f).trim();const t=i.getShaderInfoLog(_).trim();const n=i.getShaderInfoLog(M).trim();let r=true;let s=true;if(false===i.getProgramParameter(f,35714)){r=false;const t=getShaderErrors(i,_,"vertex");const n=getShaderErrors(i,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(f,35715)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==t&&""!==n||(s=false);s&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:m},fragmentShader:{log:n,prefix:g}})}i.deleteShader(_);i.deleteShader(M);let w;this.getUniforms=function(){void 0===w&&(w=new WebGLUniforms(i,f));return w};let S;this.getAttributes=function(){void 0===S&&(S=fetchAttributeLocations(i,f));return S};this.destroy=function(){r.releaseStatesOfProgram(this);i.deleteProgram(f);this.program=void 0};this.name=n.shaderName;this.id=Ao++;this.cacheKey=t;this.usedTimes=1;this.program=f;this.vertexShader=_;this.fragmentShader=M;return this}let Po=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map;this.materialCache=new Map}update(e){const t=e.vertexShader;const n=e.fragmentShader;const r=this._getShaderStage(t);const i=this._getShaderStage(n);const s=this._getShaderCacheForMaterial(e);if(false===s.has(r)){s.add(r);r.usedTimes++}if(false===s.has(i)){s.add(i);i.usedTimes++}return this}remove(e){const t=this.materialCache.get(e);for(const e of t){e.usedTimes--;0===e.usedTimes&&this.shaderCache.delete(e)}this.materialCache.delete(e);return this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear();this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;false===t.has(e)&&t.set(e,new Set);return t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(false===t.has(e)){const n=new WebGLShaderStage;t.set(e,n)}return t.get(e)}}class WebGLShaderStage{constructor(){this.id=Po++;this.usedTimes=0}}function WebGLPrograms(e,t,n,r,i,s,a){const o=new Layers;const l=new WebGLShaderCache;const c=[];const u=i.isWebGL2;const h=i.logarithmicDepthBuffer;const f=i.floatVertexTextures;const m=i.maxVertexUniforms;const g=i.vertexTextures;let y=i.precision;const x={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function getMaxBones(e){const t=e.skeleton;const n=t.bones;if(f)return 1024;{const e=m;const t=Math.floor((e-20)/4);const r=Math.min(t,n.length);if(r<n.length){console.warn("THREE.WebGLRenderer: Skeleton has "+n.length+" bones. This GPU supports "+r+".");return 0}return r}}function getTextureEncodingFromMap(e){let t;if(e&&e.isTexture)t=e.encoding;else if(e&&e.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");t=e.texture.encoding}else t=Xt;u&&e&&e.isTexture&&e.format===Ne&&e.type===Me&&e.encoding===Jt&&(t=Xt);return t}function getParameters(s,o,c,m,b){const _=m.fog;const M=s.isMeshStandardMaterial?m.environment:null;const w=(s.isMeshStandardMaterial?n:t).get(s.envMap||M);const S=x[s.type];const T=b.isSkinnedMesh?getMaxBones(b):0;if(null!==s.precision){y=i.getMaxPrecision(s.precision);y!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",y,"instead.")}let E,A;let L,C;if(S){const e=$a[S];E=e.vertexShader;A=e.fragmentShader}else{E=s.vertexShader;A=s.fragmentShader;l.update(s);L=l.getVertexShaderID(s);C=l.getFragmentShaderID(s)}const R=e.getRenderTarget();const P=s.alphaTest>0;const I=s.clearcoat>0;const D={isWebGL2:u,shaderID:S,shaderName:s.type,vertexShader:E,fragmentShader:A,defines:s.defines,customVertexShaderID:L,customFragmentShaderID:C,isRawShaderMaterial:true===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:y,instancing:true===b.isInstancedMesh,instancingColor:true===b.isInstancedMesh&&null!==b.instanceColor,supportsVertexTextures:g,outputEncoding:null!==R?getTextureEncodingFromMap(R.texture):e.outputEncoding,map:!!s.map,mapEncoding:getTextureEncodingFromMap(s.map),matcap:!!s.matcap,matcapEncoding:getTextureEncodingFromMap(s.matcap),envMap:!!w,envMapMode:w&&w.mapping,envMapEncoding:getTextureEncodingFromMap(w),envMapCubeUV:!!w&&(w.mapping===oe||w.mapping===le),lightMap:!!s.lightMap,lightMapEncoding:getTextureEncodingFromMap(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:s.normalMapType===Kt,tangentSpaceNormalMap:s.normalMapType===Qt,clearcoat:I,clearcoatMap:I&&!!s.clearcoatMap,clearcoatRoughnessMap:I&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:I&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,specularColorMapEncoding:getTextureEncodingFromMap(s.specularColorMap),alphaMap:!!s.alphaMap,alphaTest:P,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenColorMapEncoding:getTextureEncodingFromMap(s.sheenColorMap),sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!b.geometry&&!!b.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:true===s.vertexColors&&!!b.geometry&&!!b.geometry.attributes.color&&4===b.geometry.attributes.color.itemSize,vertexUvs:!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatMap||!!s.clearcoatRoughnessMap||!!s.clearcoatNormalMap||!!s.displacementMap||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularColorMap||!!s.sheenColorMap||!!s.sheenRoughnessMap,uvsVertexOnly:!(!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatNormalMap||s.transmission>0||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularColorMap||s.sheen>0||!!s.sheenColorMap||!!s.sheenRoughnessMap)&&!!s.displacementMap,fog:!!_,useFog:s.fog,fogExp2:_&&_.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:h,skinning:true===b.isSkinnedMesh&&T>0,maxBones:T,useVertexTexture:f,morphTargets:!!b.geometry&&!!b.geometry.morphAttributes.position,morphNormals:!!b.geometry&&!!b.geometry.morphAttributes.normal,morphTargetsCount:!b.geometry||!b.geometry.morphAttributes.position?0:b.geometry.morphAttributes.position.length,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:s.format,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&c.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:Z,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===p,flipSided:s.side===d,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()};return D}function getProgramCacheKey(t){const n=[];if(t.shaderID)n.push(t.shaderID);else{n.push(t.customVertexShaderID);n.push(t.customFragmentShaderID)}if(void 0!==t.defines)for(const e in t.defines){n.push(e);n.push(t.defines[e])}if(false===t.isRawShaderMaterial){getProgramCacheKeyParameters(n,t);getProgramCacheKeyBooleans(n,t);n.push(e.outputEncoding)}n.push(t.customProgramCacheKey);return n.join()}function getProgramCacheKeyParameters(e,t){e.push(t.precision);e.push(t.outputEncoding);e.push(t.mapEncoding);e.push(t.matcapEncoding);e.push(t.envMapMode);e.push(t.envMapEncoding);e.push(t.lightMapEncoding);e.push(t.emissiveMapEncoding);e.push(t.combine);e.push(t.vertexUvs);e.push(t.fogExp2);e.push(t.sizeAttenuation);e.push(t.maxBones);e.push(t.morphTargetsCount);e.push(t.numDirLights);e.push(t.numPointLights);e.push(t.numSpotLights);e.push(t.numHemiLights);e.push(t.numRectAreaLights);e.push(t.numDirLightShadows);e.push(t.numPointLightShadows);e.push(t.numSpotLightShadows);e.push(t.shadowMapType);e.push(t.toneMapping);e.push(t.numClippingPlanes);e.push(t.numClipIntersection);e.push(t.format);e.push(t.specularColorMapEncoding);e.push(t.sheenColorMapEncoding)}function getProgramCacheKeyBooleans(e,t){o.disableAll();t.isWebGL2&&o.enable(0);t.supportsVertexTextures&&o.enable(1);t.instancing&&o.enable(2);t.instancingColor&&o.enable(3);t.map&&o.enable(4);t.matcap&&o.enable(5);t.envMap&&o.enable(6);t.envMapCubeUV&&o.enable(7);t.lightMap&&o.enable(8);t.aoMap&&o.enable(9);t.emissiveMap&&o.enable(10);t.bumpMap&&o.enable(11);t.normalMap&&o.enable(12);t.objectSpaceNormalMap&&o.enable(13);t.tangentSpaceNormalMap&&o.enable(14);t.clearcoat&&o.enable(15);t.clearcoatMap&&o.enable(16);t.clearcoatRoughnessMap&&o.enable(17);t.clearcoatNormalMap&&o.enable(18);t.displacementMap&&o.enable(19);t.specularMap&&o.enable(20);t.roughnessMap&&o.enable(21);t.metalnessMap&&o.enable(22);t.gradientMap&&o.enable(23);t.alphaMap&&o.enable(24);t.alphaTest&&o.enable(25);t.vertexColors&&o.enable(26);t.vertexAlphas&&o.enable(27);t.vertexUvs&&o.enable(28);t.vertexTangents&&o.enable(29);t.uvsVertexOnly&&o.enable(30);t.fog&&o.enable(31);e.push(o.mask);o.disableAll();t.useFog&&o.enable(0);t.flatShading&&o.enable(1);t.logarithmicDepthBuffer&&o.enable(2);t.skinning&&o.enable(3);t.useVertexTexture&&o.enable(4);t.morphTargets&&o.enable(5);t.morphNormals&&o.enable(6);t.premultipliedAlpha&&o.enable(7);t.shadowMapEnabled&&o.enable(8);t.physicallyCorrectLights&&o.enable(9);t.doubleSided&&o.enable(10);t.flipSided&&o.enable(11);t.depthPacking&&o.enable(12);t.dithering&&o.enable(13);t.specularIntensityMap&&o.enable(14);t.specularColorMap&&o.enable(15);t.transmission&&o.enable(16);t.transmissionMap&&o.enable(17);t.thicknessMap&&o.enable(18);t.sheen&&o.enable(19);t.sheenColorMap&&o.enable(20);t.sheenRoughnessMap&&o.enable(21);e.push(o.mask)}function getUniforms(e){const t=x[e.type];let n;if(t){const e=$a[t];n=mi.clone(e.uniforms)}else n=e.uniforms;return n}function acquireProgram(t,n){let r;for(let e=0,t=c.length;e<t;e++){const t=c[e];if(t.cacheKey===n){r=t;++r.usedTimes;break}}if(void 0===r){r=new WebGLProgram(e,n,t,s);c.push(r)}return r}function releaseProgram(e){if(0===--e.usedTimes){const t=c.indexOf(e);c[t]=c[c.length-1];c.pop();e.destroy()}}function releaseShaderCache(e){l.remove(e)}function dispose(){l.dispose()}return{getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,releaseShaderCache:releaseShaderCache,programs:c,dispose:dispose}}function WebGLProperties(){let e=new WeakMap;function get(t){let n=e.get(t);if(void 0===n){n={};e.set(t,n)}return n}function remove(t){e.delete(t)}function update(t,n,r){e.get(t)[n]=r}function dispose(){e=new WeakMap}return{get:get,remove:remove,update:update,dispose:dispose}}function painterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function reversePainterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WebGLRenderList(){const e=[];let t=0;const n=[];const r=[];const i=[];function init(){t=0;n.length=0;r.length=0;i.length=0}function getNextRenderItem(n,r,i,s,a,o){let l=e[t];if(void 0===l){l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:a,group:o};e[t]=l}else{l.id=n.id;l.object=n;l.geometry=r;l.material=i;l.groupOrder=s;l.renderOrder=n.renderOrder;l.z=a;l.group=o}t++;return l}function push(e,t,s,a,o,l){const c=getNextRenderItem(e,t,s,a,o,l);s.transmission>0?r.push(c):true===s.transparent?i.push(c):n.push(c)}function unshift(e,t,s,a,o,l){const c=getNextRenderItem(e,t,s,a,o,l);s.transmission>0?r.unshift(c):true===s.transparent?i.unshift(c):n.unshift(c)}function sort(e,t){n.length>1&&n.sort(e||painterSortStable);r.length>1&&r.sort(t||reversePainterSortStable);i.length>1&&i.sort(t||reversePainterSortStable)}function finish(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null;t.object=null;t.geometry=null;t.material=null;t.group=null}}return{opaque:n,transmissive:r,transparent:i,init:init,push:push,unshift:unshift,finish:finish,sort:sort}}function WebGLRenderLists(){let e=new WeakMap;function get(t,n){let r;if(false===e.has(t)){r=new WebGLRenderList;e.set(t,[r])}else if(n>=e.get(t).length){r=new WebGLRenderList;e.get(t).push(r)}else r=e.get(t)[n];return r}function dispose(){e=new WeakMap}return{get:get,dispose:dispose}}function UniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new Vector3,color:new Color};break;case"SpotLight":n={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":n={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}e[t.id]=n;return n}}}function ShadowUniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}e[t.id]=n;return n}}}let Io=0;function shadowCastingLightsFirst(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function WebGLLights(e,t){const n=new UniformsCache;const r=ShadowUniformsCache();const i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)i.probe.push(new Vector3);const s=new Vector3;const a=new Matrix4;const o=new Matrix4;function setup(s,a){let o=0,l=0,c=0;for(let e=0;e<9;e++)i.probe[e].set(0,0,0);let u=0;let h=0;let d=0;let p=0;let f=0;let m=0;let g=0;let y=0;s.sort(shadowCastingLightsFirst);const x=true!==a?Math.PI:1;for(let e=0,t=s.length;e<t;e++){const t=s[e];const a=t.color;const b=t.intensity;const _=t.distance;const M=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight){o+=a.r*b*x;l+=a.g*b*x;c+=a.b*b*x}else if(t.isLightProbe)for(let e=0;e<9;e++)i.probe[e].addScaledVector(t.sh.coefficients[e],b);else if(t.isDirectionalLight){const e=n.get(t);e.color.copy(t.color).multiplyScalar(t.intensity*x);if(t.castShadow){const e=t.shadow;const n=r.get(t);n.shadowBias=e.bias;n.shadowNormalBias=e.normalBias;n.shadowRadius=e.radius;n.shadowMapSize=e.mapSize;i.directionalShadow[u]=n;i.directionalShadowMap[u]=M;i.directionalShadowMatrix[u]=t.shadow.matrix;m++}i.directional[u]=e;u++}else if(t.isSpotLight){const e=n.get(t);e.position.setFromMatrixPosition(t.matrixWorld);e.color.copy(a).multiplyScalar(b*x);e.distance=_;e.coneCos=Math.cos(t.angle);e.penumbraCos=Math.cos(t.angle*(1-t.penumbra));e.decay=t.decay;if(t.castShadow){const e=t.shadow;const n=r.get(t);n.shadowBias=e.bias;n.shadowNormalBias=e.normalBias;n.shadowRadius=e.radius;n.shadowMapSize=e.mapSize;i.spotShadow[d]=n;i.spotShadowMap[d]=M;i.spotShadowMatrix[d]=t.shadow.matrix;y++}i.spot[d]=e;d++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(a).multiplyScalar(b);e.halfWidth.set(.5*t.width,0,0);e.halfHeight.set(0,.5*t.height,0);i.rectArea[p]=e;p++}else if(t.isPointLight){const e=n.get(t);e.color.copy(t.color).multiplyScalar(t.intensity*x);e.distance=t.distance;e.decay=t.decay;if(t.castShadow){const e=t.shadow;const n=r.get(t);n.shadowBias=e.bias;n.shadowNormalBias=e.normalBias;n.shadowRadius=e.radius;n.shadowMapSize=e.mapSize;n.shadowCameraNear=e.camera.near;n.shadowCameraFar=e.camera.far;i.pointShadow[h]=n;i.pointShadowMap[h]=M;i.pointShadowMatrix[h]=t.shadow.matrix;g++}i.point[h]=e;h++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(b*x);e.groundColor.copy(t.groundColor).multiplyScalar(b*x);i.hemi[f]=e;f++}}if(p>0)if(t.isWebGL2){i.rectAreaLTC1=Ka.LTC_FLOAT_1;i.rectAreaLTC2=Ka.LTC_FLOAT_2}else if(true===e.has("OES_texture_float_linear")){i.rectAreaLTC1=Ka.LTC_FLOAT_1;i.rectAreaLTC2=Ka.LTC_FLOAT_2}else if(true===e.has("OES_texture_half_float_linear")){i.rectAreaLTC1=Ka.LTC_HALF_1;i.rectAreaLTC2=Ka.LTC_HALF_2}else console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");i.ambient[0]=o;i.ambient[1]=l;i.ambient[2]=c;const b=i.hash;if(b.directionalLength!==u||b.pointLength!==h||b.spotLength!==d||b.rectAreaLength!==p||b.hemiLength!==f||b.numDirectionalShadows!==m||b.numPointShadows!==g||b.numSpotShadows!==y){i.directional.length=u;i.spot.length=d;i.rectArea.length=p;i.point.length=h;i.hemi.length=f;i.directionalShadow.length=m;i.directionalShadowMap.length=m;i.pointShadow.length=g;i.pointShadowMap.length=g;i.spotShadow.length=y;i.spotShadowMap.length=y;i.directionalShadowMatrix.length=m;i.pointShadowMatrix.length=g;i.spotShadowMatrix.length=y;b.directionalLength=u;b.pointLength=h;b.spotLength=d;b.rectAreaLength=p;b.hemiLength=f;b.numDirectionalShadows=m;b.numPointShadows=g;b.numSpotShadows=y;i.version=Io++}}function setupView(e,t){let n=0;let r=0;let l=0;let c=0;let u=0;const h=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){const d=e[t];if(d.isDirectionalLight){const e=i.directional[n];e.direction.setFromMatrixPosition(d.matrixWorld);s.setFromMatrixPosition(d.target.matrixWorld);e.direction.sub(s);e.direction.transformDirection(h);n++}else if(d.isSpotLight){const e=i.spot[l];e.position.setFromMatrixPosition(d.matrixWorld);e.position.applyMatrix4(h);e.direction.setFromMatrixPosition(d.matrixWorld);s.setFromMatrixPosition(d.target.matrixWorld);e.direction.sub(s);e.direction.transformDirection(h);l++}else if(d.isRectAreaLight){const e=i.rectArea[c];e.position.setFromMatrixPosition(d.matrixWorld);e.position.applyMatrix4(h);o.identity();a.copy(d.matrixWorld);a.premultiply(h);o.extractRotation(a);e.halfWidth.set(.5*d.width,0,0);e.halfHeight.set(0,.5*d.height,0);e.halfWidth.applyMatrix4(o);e.halfHeight.applyMatrix4(o);c++}else if(d.isPointLight){const e=i.point[r];e.position.setFromMatrixPosition(d.matrixWorld);e.position.applyMatrix4(h);r++}else if(d.isHemisphereLight){const e=i.hemi[u];e.direction.setFromMatrixPosition(d.matrixWorld);e.direction.transformDirection(h);e.direction.normalize();u++}}}return{setup:setup,setupView:setupView,state:i}}function WebGLRenderState(e,t){const n=new WebGLLights(e,t);const r=[];const i=[];function init(){r.length=0;i.length=0}function pushLight(e){r.push(e)}function pushShadow(e){i.push(e)}function setupLights(e){n.setup(r,e)}function setupLightsView(e){n.setupView(r,e)}const s={lightsArray:r,shadowsArray:i,lights:n};return{init:init,state:s,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow}}function WebGLRenderStates(e,t){let n=new WeakMap;function get(r,i=0){let s;if(false===n.has(r)){s=new WebGLRenderState(e,t);n.set(r,[s])}else if(i>=n.get(r).length){s=new WebGLRenderState(e,t);n.get(r).push(s)}else s=n.get(r)[i];return s}function dispose(){n=new WeakMap}return{get:get,dispose:dispose}}class MeshDepthMaterial extends Material{constructor(e){super();this.type="MeshDepthMaterial";this.depthPacking=Yt;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.setValues(e)}copy(e){super.copy(e);this.depthPacking=e.depthPacking;this.map=e.map;this.alphaMap=e.alphaMap;this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;return this}}MeshDepthMaterial.prototype.isMeshDepthMaterial=true;class MeshDistanceMaterial extends Material{constructor(e){super();this.type="MeshDistanceMaterial";this.referencePosition=new Vector3;this.nearDistance=1;this.farDistance=1e3;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.setValues(e)}copy(e){super.copy(e);this.referencePosition.copy(e.referencePosition);this.nearDistance=e.nearDistance;this.farDistance=e.farDistance;this.map=e.map;this.alphaMap=e.alphaMap;this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;return this}}MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;const Do="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";const Bo="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(e,t,n){let r=new Frustum;const i=new Vector2,s=new Vector2,a=new Vector4,o=new MeshDepthMaterial({depthPacking:Zt}),c=new MeshDistanceMaterial,f={},m=n.maxTextureSize;const y={0:d,1:h,2:p};const x=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:Do,fragmentShader:Bo});const b=x.clone();b.defines.HORIZONTAL_PASS=1;const _=new BufferGeometry;_.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const M=new Mesh(_,x);const w=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=l;this.render=function(t,n,o){if(false===w.enabled)return;if(false===w.autoUpdate&&false===w.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget();const c=e.getActiveCubeFace();const h=e.getActiveMipmapLevel();const d=e.state;d.setBlending(g);d.buffers.color.setClear(1,1,1,1);d.buffers.depth.setTest(true);d.setScissorTest(false);for(let l=0,c=t.length;l<c;l++){const c=t[l];const h=c.shadow;if(void 0===h){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(false===h.autoUpdate&&false===h.needsUpdate)continue;i.copy(h.mapSize);const p=h.getFrameExtents();i.multiply(p);s.copy(h.mapSize);if(i.x>m||i.y>m){if(i.x>m){s.x=Math.floor(m/p.x);i.x=s.x*p.x;h.mapSize.x=s.x}if(i.y>m){s.y=Math.floor(m/p.y);i.y=s.y*p.y;h.mapSize.y=s.y}}if(null===h.map&&!h.isPointLightShadow&&this.type===u){const e={minFilter:ye,magFilter:ye,format:Ne};h.map=new WebGLRenderTarget(i.x,i.y,e);h.map.texture.name=c.name+".shadowMap";h.mapPass=new WebGLRenderTarget(i.x,i.y,e);h.camera.updateProjectionMatrix()}if(null===h.map){const e={minFilter:de,magFilter:de,format:Ne};h.map=new WebGLRenderTarget(i.x,i.y,e);h.map.texture.name=c.name+".shadowMap";h.camera.updateProjectionMatrix()}e.setRenderTarget(h.map);e.clear();const f=h.getViewportCount();for(let e=0;e<f;e++){const t=h.getViewport(e);a.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w);d.viewport(a);h.updateMatrices(c,e);r=h.getFrustum();renderObject(n,o,h.camera,c,this.type)}h.isPointLightShadow||this.type!==u||VSMPass(h,o);h.needsUpdate=false}w.needsUpdate=false;e.setRenderTarget(l,c,h)};function VSMPass(n,r){const i=t.update(M);if(x.defines.VSM_SAMPLES!==n.blurSamples){x.defines.VSM_SAMPLES=n.blurSamples;b.defines.VSM_SAMPLES=n.blurSamples;x.needsUpdate=true;b.needsUpdate=true}x.uniforms.shadow_pass.value=n.map.texture;x.uniforms.resolution.value=n.mapSize;x.uniforms.radius.value=n.radius;e.setRenderTarget(n.mapPass);e.clear();e.renderBufferDirect(r,null,i,x,M,null);b.uniforms.shadow_pass.value=n.mapPass.texture;b.uniforms.resolution.value=n.mapSize;b.uniforms.radius.value=n.radius;e.setRenderTarget(n.map);e.clear();e.renderBufferDirect(r,null,i,b,M,null)}function getDepthMaterial(t,n,r,i,s,a,l){let h=null;const d=true===i.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;h=void 0!==d?d:true===i.isPointLight?c:o;if(e.localClippingEnabled&&true===r.clipShadows&&0!==r.clippingPlanes.length||r.displacementMap&&0!==r.displacementScale||r.alphaMap&&r.alphaTest>0){const e=h.uuid,t=r.uuid;let n=f[e];if(void 0===n){n={};f[e]=n}let i=n[t];if(void 0===i){i=h.clone();n[t]=i}h=i}h.visible=r.visible;h.wireframe=r.wireframe;h.side=l===u?null!==r.shadowSide?r.shadowSide:r.side:null!==r.shadowSide?r.shadowSide:y[r.side];h.alphaMap=r.alphaMap;h.alphaTest=r.alphaTest;h.clipShadows=r.clipShadows;h.clippingPlanes=r.clippingPlanes;h.clipIntersection=r.clipIntersection;h.displacementMap=r.displacementMap;h.displacementScale=r.displacementScale;h.displacementBias=r.displacementBias;h.wireframeLinewidth=r.wireframeLinewidth;h.linewidth=r.linewidth;if(true===i.isPointLight&&true===h.isMeshDistanceMaterial){h.referencePosition.setFromMatrixPosition(i.matrixWorld);h.nearDistance=s;h.farDistance=a}return h}function renderObject(n,i,s,a,o){if(false===n.visible)return;const l=n.layers.test(i.layers);if(l&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&o===u)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=t.update(n);const i=n.material;if(Array.isArray(i)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l];const u=i[c.materialIndex];if(u&&u.visible){const t=getDepthMaterial(n,r,u,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,c)}}}else if(i.visible){const t=getDepthMaterial(n,r,i,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,null)}}const c=n.children;for(let e=0,t=c.length;e<t;e++)renderObject(c[e],i,s,a,o)}}function WebGLState(e,t,n){const a=n.isWebGL2;function ColorBuffer(){let t=false;const n=new Vector4;let r=null;const i=new Vector4(0,0,0,0);return{setMask:function(n){if(r!==n&&!t){e.colorMask(n,n,n,n);r=n}},setLocked:function(e){t=e},setClear:function(t,r,s,a,o){if(true===o){t*=a;r*=a;s*=a}n.set(t,r,s,a);if(false===i.equals(n)){e.clearColor(t,r,s,a);i.copy(n)}},reset:function(){t=false;r=null;i.set(-1,0,0,0)}}}function DepthBuffer(){let t=false;let n=null;let r=null;let i=null;return{setTest:function(e){e?enable(2929):disable(2929)},setMask:function(r){if(n!==r&&!t){e.depthMask(r);n=r}},setFunc:function(t){if(r!==t){if(t)switch(t){case G:e.depthFunc(512);break;case F:e.depthFunc(519);break;case O:e.depthFunc(513);break;case H:e.depthFunc(515);break;case k:e.depthFunc(514);break;case W:e.depthFunc(518);break;case j:e.depthFunc(516);break;case q:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);r=t}},setLocked:function(e){t=e},setClear:function(t){if(i!==t){e.clearDepth(t);i=t}},reset:function(){t=false;n=null;r=null;i=null}}}function StencilBuffer(){let t=false;let n=null;let r=null;let i=null;let s=null;let a=null;let o=null;let l=null;let c=null;return{setTest:function(e){t||(e?enable(2960):disable(2960))},setMask:function(r){if(n!==r&&!t){e.stencilMask(r);n=r}},setFunc:function(t,n,a){if(r!==t||i!==n||s!==a){e.stencilFunc(t,n,a);r=t;i=n;s=a}},setOp:function(t,n,r){if(a!==t||o!==n||l!==r){e.stencilOp(t,n,r);a=t;o=n;l=r}},setLocked:function(e){t=e},setClear:function(t){if(c!==t){e.clearStencil(t);c=t}},reset:function(){t=false;n=null;r=null;i=null;s=null;a=null;o=null;l=null;c=null}}}const o=new ColorBuffer;const l=new DepthBuffer;const c=new StencilBuffer;let u={};let h={};let f=null;let m=false;let X=null;let J=null;let Y=null;let Z=null;let Q=null;let K=null;let $=null;let ee=false;let te=null;let ne=null;let re=null;let ie=null;let se=null;const ae=e.getParameter(35661);let oe=false;let le=0;const ce=e.getParameter(7938);if(-1!==ce.indexOf("WebGL")){le=parseFloat(/^WebGL (\d)/.exec(ce)[1]);oe=le>=1}else if(-1!==ce.indexOf("OpenGL ES")){le=parseFloat(/^OpenGL ES (\d)/.exec(ce)[1]);oe=le>=2}let ue=null;let he={};const de=e.getParameter(3088);const pe=e.getParameter(2978);const fe=(new Vector4).fromArray(de);const me=(new Vector4).fromArray(pe);function createTexture(t,n,r){const i=new Uint8Array(4);const s=e.createTexture();e.bindTexture(t,s);e.texParameteri(t,10241,9728);e.texParameteri(t,10240,9728);for(let t=0;t<r;t++)e.texImage2D(n+t,0,6408,1,1,0,6408,5121,i);return s}const ge={};ge[3553]=createTexture(3553,3553,1);ge[34067]=createTexture(34067,34069,6);o.setClear(0,0,0,1);l.setClear(1);c.setClear(0);enable(2929);l.setFunc(H);setFlipSided(false);setCullFace(i);enable(2884);setBlending(g);function enable(t){if(true!==u[t]){e.enable(t);u[t]=true}}function disable(t){if(false!==u[t]){e.disable(t);u[t]=false}}function bindFramebuffer(t,n){if(h[t]!==n){e.bindFramebuffer(t,n);h[t]=n;if(a){36009===t&&(h[36160]=n);36160===t&&(h[36009]=n)}return true}return false}function useProgram(t){if(f!==t){e.useProgram(t);f=t;return true}return false}const ye={[w]:32774,[S]:32778,[T]:32779};if(a){ye[E]=32775;ye[A]=32776}else{const e=t.get("EXT_blend_minmax");if(null!==e){ye[E]=e.MIN_EXT;ye[A]=e.MAX_EXT}}const ve={[L]:0,[C]:1,[R]:768,[I]:770,[z]:776,[N]:774,[B]:772,[P]:769,[D]:771,[U]:775,[V]:773};function setBlending(t,n,r,i,s,a,o,l){if(t!==g){if(false===m){enable(3042);m=true}if(t===M){s=s||n;a=a||r;o=o||i;if(n!==J||s!==Q){e.blendEquationSeparate(ye[n],ye[s]);J=n;Q=s}if(r!==Y||i!==Z||a!==K||o!==$){e.blendFuncSeparate(ve[r],ve[i],ve[a],ve[o]);Y=r;Z=i;K=a;$=o}X=t;ee=null}else if(t!==X||l!==ee){if(J!==w||Q!==w){e.blendEquation(32774);J=w;Q=w}if(l)switch(t){case y:e.blendFuncSeparate(1,771,1,771);break;case x:e.blendFunc(1,1);break;case b:e.blendFuncSeparate(0,0,769,771);break;case _:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}else switch(t){case y:e.blendFuncSeparate(770,771,1,771);break;case x:e.blendFunc(770,1);break;case b:e.blendFunc(0,769);break;case _:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}Y=null;Z=null;K=null;$=null;X=t;ee=l}}else if(true===m){disable(3042);m=false}}function setMaterial(e,t){e.side===p?disable(2884):enable(2884);let n=e.side===d;t&&(n=!n);setFlipSided(n);e.blending===y&&false===e.transparent?setBlending(g):setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha);l.setFunc(e.depthFunc);l.setTest(e.depthTest);l.setMask(e.depthWrite);o.setMask(e.colorWrite);const r=e.stencilWrite;c.setTest(r);if(r){c.setMask(e.stencilWriteMask);c.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask);c.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)}setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits);true===e.alphaToCoverage?enable(32926):disable(32926)}function setFlipSided(t){if(te!==t){t?e.frontFace(2304):e.frontFace(2305);te=t}}function setCullFace(t){if(t!==r){enable(2884);t!==ne&&(t===i?e.cullFace(1029):t===s?e.cullFace(1028):e.cullFace(1032))}else disable(2884);ne=t}function setLineWidth(t){if(t!==re){oe&&e.lineWidth(t);re=t}}function setPolygonOffset(t,n,r){if(t){enable(32823);if(ie!==n||se!==r){e.polygonOffset(n,r);ie=n;se=r}}else disable(32823)}function setScissorTest(e){e?enable(3089):disable(3089)}function activeTexture(t){void 0===t&&(t=33984+ae-1);if(ue!==t){e.activeTexture(t);ue=t}}function bindTexture(t,n){null===ue&&activeTexture();let r=he[ue];if(void 0===r){r={type:void 0,texture:void 0};he[ue]=r}if(r.type!==t||r.texture!==n){e.bindTexture(t,n||ge[t]);r.type=t;r.texture=n}}function unbindTexture(){const t=he[ue];if(void 0!==t&&void 0!==t.type){e.bindTexture(t.type,null);t.type=void 0;t.texture=void 0}}function compressedTexImage2D(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texSubImage2D(){try{e.texSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texSubImage3D(){try{e.texSubImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function compressedTexSubImage2D(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texStorage2D(){try{e.texStorage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texStorage3D(){try{e.texStorage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texImage2D(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function texImage3D(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function scissor(t){if(false===fe.equals(t)){e.scissor(t.x,t.y,t.z,t.w);fe.copy(t)}}function viewport(t){if(false===me.equals(t)){e.viewport(t.x,t.y,t.z,t.w);me.copy(t)}}function reset(){e.disable(3042);e.disable(2884);e.disable(2929);e.disable(32823);e.disable(3089);e.disable(2960);e.disable(32926);e.blendEquation(32774);e.blendFunc(1,0);e.blendFuncSeparate(1,0,1,0);e.colorMask(true,true,true,true);e.clearColor(0,0,0,0);e.depthMask(true);e.depthFunc(513);e.clearDepth(1);e.stencilMask(4294967295);e.stencilFunc(519,0,4294967295);e.stencilOp(7680,7680,7680);e.clearStencil(0);e.cullFace(1029);e.frontFace(2305);e.polygonOffset(0,0);e.activeTexture(33984);e.bindFramebuffer(36160,null);if(true===a){e.bindFramebuffer(36009,null);e.bindFramebuffer(36008,null)}e.useProgram(null);e.lineWidth(1);e.scissor(0,0,e.canvas.width,e.canvas.height);e.viewport(0,0,e.canvas.width,e.canvas.height);u={};ue=null;he={};h={};f=null;m=false;X=null;J=null;Y=null;Z=null;Q=null;K=null;$=null;ee=false;te=null;ne=null;re=null;ie=null;se=null;fe.set(0,0,e.canvas.width,e.canvas.height);me.set(0,0,e.canvas.width,e.canvas.height);o.reset();l.reset();c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,texStorage2D:texStorage2D,texStorage3D:texStorage3D,texSubImage2D:texSubImage2D,texSubImage3D:texSubImage3D,compressedTexSubImage2D:compressedTexSubImage2D,scissor:scissor,viewport:viewport,reset:reset}}function WebGLTextures(e,t,n,r,i,s,a){const o=i.isWebGL2;const l=i.maxTextures;const c=i.maxCubemapSize;const u=i.maxTextureSize;const h=i.maxSamples;const d=t.has("WEBGL_multisampled_render_to_texture");const p=d?t.get("WEBGL_multisampled_render_to_texture"):void 0;const f=new WeakMap;let m;let g=false;try{g="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function createCanvas(e,t){return g?new OffscreenCanvas(e,t):createElementNS("canvas")}function resizeImage(e,t,n,r){let i=1;(e.width>r||e.height>r)&&(i=r/Math.max(e.width,e.height));if(i<1||true===t){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap){const r=t?floorPowerOfTwo:Math.floor;const s=r(i*e.width);const a=r(i*e.height);void 0===m&&(m=createCanvas(s,a));const o=n?createCanvas(s,a):m;o.width=s;o.height=a;const l=o.getContext("2d");l.drawImage(e,0,0,s,a);console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+a+").");return o}"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+").");return e}return e}function isPowerOfTwo$1(e){return isPowerOfTwo(e.width)&&isPowerOfTwo(e.height)}function textureNeedsPowerOfTwo(e){return!o&&(e.wrapS!==ue||e.wrapT!==ue||e.minFilter!==de&&e.minFilter!==ye)}function textureNeedsGenerateMipmaps(e,t){return e.generateMipmaps&&t&&e.minFilter!==de&&e.minFilter!==ye}function generateMipmap(t){e.generateMipmap(t)}function getInternalFormat(n,r,i,s){if(false===o)return r;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let a=r;if(6403===r){5126===i&&(a=33326);5131===i&&(a=33325);5121===i&&(a=33321)}if(6407===r){5126===i&&(a=34837);5131===i&&(a=34843);5121===i&&(a=32849)}if(6408===r){5126===i&&(a=34836);5131===i&&(a=34842);5121===i&&(a=s===Jt?35907:32856)}33325!==a&&33326!==a&&34842!==a&&34836!==a||t.get("EXT_color_buffer_float");return a}function getMipLevels(e,t,n){return true===textureNeedsGenerateMipmaps(e,n)||e.isFramebufferTexture&&e.minFilter!==de&&e.minFilter!==ye?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function filterFallback(e){return e===de||e===pe||e===me?9728:9729}function onTextureDispose(e){const t=e.target;t.removeEventListener("dispose",onTextureDispose);deallocateTexture(t);t.isVideoTexture&&f.delete(t);a.memory.textures--}function onRenderTargetDispose(e){const t=e.target;t.removeEventListener("dispose",onRenderTargetDispose);deallocateRenderTarget(t)}function deallocateTexture(t){const n=r.get(t);if(void 0!==n.__webglInit){e.deleteTexture(n.__webglTexture);r.remove(t)}}function deallocateRenderTarget(t){const n=t.texture;const i=r.get(t);const s=r.get(n);if(t){if(void 0!==s.__webglTexture){e.deleteTexture(s.__webglTexture);a.memory.textures--}t.depthTexture&&t.depthTexture.dispose();if(t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++){e.deleteFramebuffer(i.__webglFramebuffer[t]);i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer[t])}else{e.deleteFramebuffer(i.__webglFramebuffer);i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer);i.__webglMultisampledFramebuffer&&e.deleteFramebuffer(i.__webglMultisampledFramebuffer);i.__webglColorRenderbuffer&&e.deleteRenderbuffer(i.__webglColorRenderbuffer);i.__webglDepthRenderbuffer&&e.deleteRenderbuffer(i.__webglDepthRenderbuffer)}if(t.isWebGLMultipleRenderTargets)for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);if(i.__webglTexture){e.deleteTexture(i.__webglTexture);a.memory.textures--}r.remove(n[t])}r.remove(n);r.remove(t)}}let y=0;function resetTextureUnits(){y=0}function allocateTextureUnit(){const e=y;e>=l&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+l);y+=1;return e}function setTexture2D(e,t){const i=r.get(e);e.isVideoTexture&&updateVideoTexture(e);if(e.version>0&&i.__version!==e.version){const n=e.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(false!==n.complete){uploadTexture(i,e,t);return}console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t);n.bindTexture(3553,i.__webglTexture)}function setTexture2DArray(e,t){const i=r.get(e);if(e.version>0&&i.__version!==e.version)uploadTexture(i,e,t);else{n.activeTexture(33984+t);n.bindTexture(35866,i.__webglTexture)}}function setTexture3D(e,t){const i=r.get(e);if(e.version>0&&i.__version!==e.version)uploadTexture(i,e,t);else{n.activeTexture(33984+t);n.bindTexture(32879,i.__webglTexture)}}function setTextureCube(e,t){const i=r.get(e);if(e.version>0&&i.__version!==e.version)uploadCubeTexture(i,e,t);else{n.activeTexture(33984+t);n.bindTexture(34067,i.__webglTexture)}}const x={[ce]:10497,[ue]:33071,[he]:33648};const b={[de]:9728,[pe]:9984,[me]:9986,[ye]:9729,[ve]:9985,[be]:9987};function setTextureParameters(n,s,a){if(a){e.texParameteri(n,10242,x[s.wrapS]);e.texParameteri(n,10243,x[s.wrapT]);32879!==n&&35866!==n||e.texParameteri(n,32882,x[s.wrapR]);e.texParameteri(n,10240,b[s.magFilter]);e.texParameteri(n,10241,b[s.minFilter])}else{e.texParameteri(n,10242,33071);e.texParameteri(n,10243,33071);32879!==n&&35866!==n||e.texParameteri(n,32882,33071);s.wrapS===ue&&s.wrapT===ue||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");e.texParameteri(n,10240,filterFallback(s.magFilter));e.texParameteri(n,10241,filterFallback(s.minFilter));s.minFilter!==de&&s.minFilter!==ye&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")}if(true===t.has("EXT_texture_filter_anisotropic")){const a=t.get("EXT_texture_filter_anisotropic");if(s.type===Le&&false===t.has("OES_texture_float_linear"))return;if(false===o&&s.type===Ce&&false===t.has("OES_texture_half_float_linear"))return;if(s.anisotropy>1||r.get(s).__currentAnisotropy){e.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy()));r.get(s).__currentAnisotropy=s.anisotropy}}}function initTexture(t,n){if(void 0===t.__webglInit){t.__webglInit=true;n.addEventListener("dispose",onTextureDispose);t.__webglTexture=e.createTexture();a.memory.textures++}}function uploadTexture(t,r,i){let a=3553;r.isDataTexture2DArray&&(a=35866);r.isDataTexture3D&&(a=32879);initTexture(t,r);n.activeTexture(33984+i);n.bindTexture(a,t.__webglTexture);e.pixelStorei(37440,r.flipY);e.pixelStorei(37441,r.premultiplyAlpha);e.pixelStorei(3317,r.unpackAlignment);e.pixelStorei(37443,0);const l=textureNeedsPowerOfTwo(r)&&false===isPowerOfTwo$1(r.image);const c=resizeImage(r.image,l,false,u);const h=isPowerOfTwo$1(c)||o,d=s.convert(r.format);let p=s.convert(r.type),f=getInternalFormat(r.internalFormat,d,p,r.encoding);setTextureParameters(a,r,h);let m;const g=r.mipmaps;const y=o&&true!==r.isVideoTexture;const x=void 0===t.__version;const b=getMipLevels(r,c,h);if(r.isDepthTexture){f=6402;o?f=r.type===Le?36012:r.type===Ae?33190:r.type===De?35056:33189:r.type===Le&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");if(r.format===Ge&&6402===f&&r.type!==Te&&r.type!==Ae){console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");r.type=Te;p=s.convert(r.type)}if(r.format===Fe&&6402===f){f=34041;if(r.type!==De){console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");r.type=De;p=s.convert(r.type)}}y&&x?n.texStorage2D(3553,1,f,c.width,c.height):n.texImage2D(3553,0,f,c.width,c.height,0,d,p,null)}else if(r.isDataTexture)if(g.length>0&&h){y&&x&&n.texStorage2D(3553,b,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++){m=g[e];y?n.texSubImage2D(3553,0,0,0,m.width,m.height,d,p,m.data):n.texImage2D(3553,e,f,m.width,m.height,0,d,p,m.data)}r.generateMipmaps=false}else if(y){x&&n.texStorage2D(3553,b,f,c.width,c.height);n.texSubImage2D(3553,0,0,0,c.width,c.height,d,p,c.data)}else n.texImage2D(3553,0,f,c.width,c.height,0,d,p,c.data);else if(r.isCompressedTexture){y&&x&&n.texStorage2D(3553,b,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++){m=g[e];r.format!==Ne&&r.format!==Ve?null!==d?y?n.compressedTexSubImage2D(3553,e,0,0,m.width,m.height,d,m.data):n.compressedTexImage2D(3553,e,f,m.width,m.height,0,m.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):y?n.texSubImage2D(3553,e,0,0,m.width,m.height,d,p,m.data):n.texImage2D(3553,e,f,m.width,m.height,0,d,p,m.data)}}else if(r.isDataTexture2DArray)if(y){x&&n.texStorage3D(35866,b,f,c.width,c.height,c.depth);n.texSubImage3D(35866,0,0,0,0,c.width,c.height,c.depth,d,p,c.data)}else n.texImage3D(35866,0,f,c.width,c.height,c.depth,0,d,p,c.data);else if(r.isDataTexture3D)if(y){x&&n.texStorage3D(32879,b,f,c.width,c.height,c.depth);n.texSubImage3D(32879,0,0,0,0,c.width,c.height,c.depth,d,p,c.data)}else n.texImage3D(32879,0,f,c.width,c.height,c.depth,0,d,p,c.data);else if(r.isFramebufferTexture)y&&x?n.texStorage2D(3553,b,f,c.width,c.height):n.texImage2D(3553,0,f,c.width,c.height,0,d,p,null);else if(g.length>0&&h){y&&x&&n.texStorage2D(3553,b,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++){m=g[e];y?n.texSubImage2D(3553,e,0,0,d,p,m):n.texImage2D(3553,e,f,d,p,m)}r.generateMipmaps=false}else if(y){x&&n.texStorage2D(3553,b,f,c.width,c.height);n.texSubImage2D(3553,0,0,0,d,p,c)}else n.texImage2D(3553,0,f,d,p,c);textureNeedsGenerateMipmaps(r,h)&&generateMipmap(a);t.__version=r.version;r.onUpdate&&r.onUpdate(r)}function uploadCubeTexture(t,r,i){if(6!==r.image.length)return;initTexture(t,r);n.activeTexture(33984+i);n.bindTexture(34067,t.__webglTexture);e.pixelStorei(37440,r.flipY);e.pixelStorei(37441,r.premultiplyAlpha);e.pixelStorei(3317,r.unpackAlignment);e.pixelStorei(37443,0);const a=r&&(r.isCompressedTexture||r.image[0].isCompressedTexture);const l=r.image[0]&&r.image[0].isDataTexture;const u=[];for(let e=0;e<6;e++)u[e]=a||l?l?r.image[e].image:r.image[e]:resizeImage(r.image[e],false,true,c);const h=u[0],d=isPowerOfTwo$1(h)||o,p=s.convert(r.format),f=s.convert(r.type),m=getInternalFormat(r.internalFormat,p,f,r.encoding);const g=o&&true!==r.isVideoTexture;const y=void 0===t.__version;let x=getMipLevels(r,h,d);setTextureParameters(34067,r,d);let b;if(a){g&&y&&n.texStorage2D(34067,x,m,h.width,h.height);for(let e=0;e<6;e++){b=u[e].mipmaps;for(let t=0;t<b.length;t++){const i=b[t];r.format!==Ne&&r.format!==Ve?null!==p?g?n.compressedTexSubImage2D(34069+e,t,0,0,i.width,i.height,p,i.data):n.compressedTexImage2D(34069+e,t,m,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+e,t,0,0,i.width,i.height,p,f,i.data):n.texImage2D(34069+e,t,m,i.width,i.height,0,p,f,i.data)}}}else{b=r.mipmaps;if(g&&y){b.length>0&&x++;n.texStorage2D(34067,x,m,u[0].width,u[0].height)}for(let e=0;e<6;e++)if(l){g?n.texSubImage2D(34069+e,0,0,0,u[e].width,u[e].height,p,f,u[e].data):n.texImage2D(34069+e,0,m,u[e].width,u[e].height,0,p,f,u[e].data);for(let t=0;t<b.length;t++){const r=b[t];const i=r.image[e].image;g?n.texSubImage2D(34069+e,t+1,0,0,i.width,i.height,p,f,i.data):n.texImage2D(34069+e,t+1,m,i.width,i.height,0,p,f,i.data)}}else{g?n.texSubImage2D(34069+e,0,0,0,p,f,u[e]):n.texImage2D(34069+e,0,m,p,f,u[e]);for(let t=0;t<b.length;t++){const r=b[t];g?n.texSubImage2D(34069+e,t+1,0,0,p,f,r.image[e]):n.texImage2D(34069+e,t+1,m,p,f,r.image[e])}}}textureNeedsGenerateMipmaps(r,d)&&generateMipmap(34067);t.__version=r.version;r.onUpdate&&r.onUpdate(r)}function setupFrameBufferTexture(t,i,a,o,l){const c=s.convert(a.format);const u=s.convert(a.type);const h=getInternalFormat(a.internalFormat,c,u,a.encoding);const d=r.get(i);d.__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,h,i.width,i.height,i.depth,0,c,u,null):n.texImage2D(l,0,h,i.width,i.height,0,c,u,null));n.bindFramebuffer(36160,t);i.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,getRenderTargetSamples(i)):e.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0);n.bindFramebuffer(36160,null)}function setupRenderBufferStorage(t,n,r){e.bindRenderbuffer(36161,t);if(n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r||n.useRenderToTexture){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===Le?i=36012:t.type===Ae&&(i=33190));const r=getRenderTargetSamples(n);n.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,r,i,n.width,n.height):e.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else e.renderbufferStorage(36161,i,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){const i=getRenderTargetSamples(n);r&&n.useRenderbuffer?e.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):n.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):e.renderbufferStorage(36161,34041,n.width,n.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=true===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture;const i=s.convert(t.format);const a=s.convert(t.type);const o=getInternalFormat(t.internalFormat,i,a,t.encoding);const l=getRenderTargetSamples(n);r&&n.useRenderbuffer?e.renderbufferStorageMultisample(36161,l,o,n.width,n.height):n.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,l,o,n.width,n.height):e.renderbufferStorage(36161,o,n.width,n.height)}e.bindRenderbuffer(36161,null)}function setupDepthTexture(t,i){const s=i&&i.isWebGLCubeRenderTarget;if(s)throw new Error("Depth Texture with cube render targets is not supported");n.bindFramebuffer(36160,t);if(!(i.depthTexture&&i.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");if(!r.get(i.depthTexture).__webglTexture||i.depthTexture.image.width!==i.width||i.depthTexture.image.height!==i.height){i.depthTexture.image.width=i.width;i.depthTexture.image.height=i.height;i.depthTexture.needsUpdate=true}setTexture2D(i.depthTexture,0);const a=r.get(i.depthTexture).__webglTexture;const o=getRenderTargetSamples(i);if(i.depthTexture.format===Ge)i.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,a,0,o):e.framebufferTexture2D(36160,36096,3553,a,0);else{if(i.depthTexture.format!==Fe)throw new Error("Unknown depthTexture format");i.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,a,0,o):e.framebufferTexture2D(36160,33306,3553,a,0)}}function setupDepthRenderbuffer(t){const i=r.get(t);const s=true===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");setupDepthTexture(i.__webglFramebuffer,t)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++){n.bindFramebuffer(36160,i.__webglFramebuffer[r]);i.__webglDepthbuffer[r]=e.createRenderbuffer();setupRenderBufferStorage(i.__webglDepthbuffer[r],t,false)}}else{n.bindFramebuffer(36160,i.__webglFramebuffer);i.__webglDepthbuffer=e.createRenderbuffer();setupRenderBufferStorage(i.__webglDepthbuffer,t,false)}n.bindFramebuffer(36160,null)}function rebindTextures(e,t,n){const i=r.get(e);void 0!==t&&setupFrameBufferTexture(i.__webglFramebuffer,e,e.texture,36064,3553);void 0!==n&&setupDepthRenderbuffer(e)}function setupRenderTarget(t){const l=t.texture;const c=r.get(t);const u=r.get(l);t.addEventListener("dispose",onRenderTargetDispose);if(true!==t.isWebGLMultipleRenderTargets){void 0===u.__webglTexture&&(u.__webglTexture=e.createTexture());u.__version=l.version;a.memory.textures++}const h=true===t.isWebGLCubeRenderTarget;const d=true===t.isWebGLMultipleRenderTargets;const p=l.isDataTexture3D||l.isDataTexture2DArray;const f=isPowerOfTwo$1(t)||o;if(o&&l.format===Ve&&(l.type===Le||l.type===Ce)){l.format=Ne;console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")}if(h){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else{c.__webglFramebuffer=e.createFramebuffer();if(d)if(i.drawBuffers){const n=t.texture;for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);if(void 0===i.__webglTexture){i.__webglTexture=e.createTexture();a.memory.textures++}}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(t.useRenderbuffer)if(o){c.__webglMultisampledFramebuffer=e.createFramebuffer();c.__webglColorRenderbuffer=e.createRenderbuffer();e.bindRenderbuffer(36161,c.__webglColorRenderbuffer);const r=s.convert(l.format);const i=s.convert(l.type);const a=getInternalFormat(l.internalFormat,r,i,l.encoding);const o=getRenderTargetSamples(t);e.renderbufferStorageMultisample(36161,o,a,t.width,t.height);n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);e.framebufferRenderbuffer(36160,36064,36161,c.__webglColorRenderbuffer);e.bindRenderbuffer(36161,null);if(t.depthBuffer){c.__webglDepthRenderbuffer=e.createRenderbuffer();setupRenderBufferStorage(c.__webglDepthRenderbuffer,t,true)}n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}if(h){n.bindTexture(34067,u.__webglTexture);setTextureParameters(34067,l,f);for(let e=0;e<6;e++)setupFrameBufferTexture(c.__webglFramebuffer[e],t,l,36064,34069+e);textureNeedsGenerateMipmaps(l,f)&&generateMipmap(34067);n.unbindTexture()}else if(d){const e=t.texture;for(let i=0,s=e.length;i<s;i++){const s=e[i];const a=r.get(s);n.bindTexture(3553,a.__webglTexture);setTextureParameters(3553,s,f);setupFrameBufferTexture(c.__webglFramebuffer,t,s,36064+i,3553);textureNeedsGenerateMipmaps(s,f)&&generateMipmap(3553)}n.unbindTexture()}else{let e=3553;if(p)if(o){const t=l.isDataTexture3D;e=t?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");n.bindTexture(e,u.__webglTexture);setTextureParameters(e,l,f);setupFrameBufferTexture(c.__webglFramebuffer,t,l,36064,e);textureNeedsGenerateMipmaps(l,f)&&generateMipmap(e);n.unbindTexture()}t.depthBuffer&&setupDepthRenderbuffer(t)}function updateRenderTargetMipmap(e){const t=isPowerOfTwo$1(e)||o;const i=true===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,a=i.length;s<a;s++){const a=i[s];if(textureNeedsGenerateMipmaps(a,t)){const t=e.isWebGLCubeRenderTarget?34067:3553;const i=r.get(a).__webglTexture;n.bindTexture(t,i);generateMipmap(t);n.unbindTexture()}}}function updateMultisampleRenderTarget(t){if(t.useRenderbuffer)if(o){const i=t.width;const s=t.height;let a=16384;const o=[36064];const l=t.stencilBuffer?33306:36096;t.depthBuffer&&o.push(l);if(!t.ignoreDepthForMultisampleCopy){t.depthBuffer&&(a|=256);t.stencilBuffer&&(a|=1024)}const c=r.get(t);n.bindFramebuffer(36008,c.__webglMultisampledFramebuffer);n.bindFramebuffer(36009,c.__webglFramebuffer);if(t.ignoreDepthForMultisampleCopy){e.invalidateFramebuffer(36008,[l]);e.invalidateFramebuffer(36009,[l])}e.blitFramebuffer(0,0,i,s,0,0,i,s,a,9728);e.invalidateFramebuffer(36008,o);n.bindFramebuffer(36008,null);n.bindFramebuffer(36009,c.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function getRenderTargetSamples(e){return o&&(e.useRenderbuffer||e.useRenderToTexture)?Math.min(h,e.samples):0}function updateVideoTexture(e){const t=a.render.frame;if(f.get(e)!==t){f.set(e,t);e.update()}}let _=false;let M=false;function safeSetTexture2D(e,t){if(e&&e.isWebGLRenderTarget){if(false===_){console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");_=true}e=e.texture}setTexture2D(e,t)}function safeSetTextureCube(e,t){if(e&&e.isWebGLCubeRenderTarget){if(false===M){console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");M=true}e=e.texture}setTextureCube(e,t)}this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.rebindTextures=rebindTextures;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.setupDepthRenderbuffer=setupDepthRenderbuffer;this.setupFrameBufferTexture=setupFrameBufferTexture;this.safeSetTexture2D=safeSetTexture2D;this.safeSetTextureCube=safeSetTextureCube}function WebGLUtils(e,t,n){const r=n.isWebGL2;function convert(e){let n;if(e===Me)return 5121;if(e===Re)return 32819;if(e===Pe)return 32820;if(e===Ie)return 33635;if(e===we)return 5120;if(e===Se)return 5122;if(e===Te)return 5123;if(e===Ee)return 5124;if(e===Ae)return 5125;if(e===Le)return 5126;if(e===Ce){if(r)return 5131;n=t.get("OES_texture_half_float");return null!==n?n.HALF_FLOAT_OES:null}if(e===Be)return 6406;if(e===Ve)return 6407;if(e===Ne)return 6408;if(e===Ue)return 6409;if(e===ze)return 6410;if(e===Ge)return 6402;if(e===Fe)return 34041;if(e===Oe)return 6403;if(e===He)return 36244;if(e===ke)return 33319;if(e===We)return 33320;if(e===je)return 36248;if(e===qe)return 36249;if(e===Xe||e===Je||e===Ye||e===Ze){n=t.get("WEBGL_compressed_texture_s3tc");if(null===n)return null;if(e===Xe)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===Je)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===Ye)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===Ze)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===Qe||e===Ke||e===$e||e===et){n=t.get("WEBGL_compressed_texture_pvrtc");if(null===n)return null;if(e===Qe)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===Ke)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===$e)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===et)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===tt){n=t.get("WEBGL_compressed_texture_etc1");return null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null}if(e===nt||e===rt){n=t.get("WEBGL_compressed_texture_etc");if(null!==n){if(e===nt)return n.COMPRESSED_RGB8_ETC2;if(e===rt)return n.COMPRESSED_RGBA8_ETC2_EAC}}if(e===it||e===st||e===at||e===ot||e===lt||e===ct||e===ut||e===ht||e===dt||e===pt||e===ft||e===mt||e===gt||e===yt||e===xt||e===bt||e===_t||e===Mt||e===wt||e===St||e===Tt||e===Et||e===At||e===Lt||e===Ct||e===Rt||e===Pt||e===It){n=t.get("WEBGL_compressed_texture_astc");return null!==n?e:null}if(e===vt){n=t.get("EXT_texture_compression_bptc");return null!==n?e:null}if(e===De){if(r)return 34042;n=t.get("WEBGL_depth_texture");return null!==n?n.UNSIGNED_INT_24_8_WEBGL:null}}return{convert:convert}}class ArrayCamera extends PerspectiveCamera{constructor(e=[]){super();this.cameras=e}}ArrayCamera.prototype.isArrayCamera=true;class Group extends Object3D{constructor(){super();this.type="Group"}}Group.prototype.isGroup=true;const Vo={type:"move"};class WebXRController{constructor(){this._targetRay=null;this._grip=null;this._hand=null}getHandSpace(){if(null===this._hand){this._hand=new Group;this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false}}return this._hand}getTargetRaySpace(){if(null===this._targetRay){this._targetRay=new Group;this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3;this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3}return this._targetRay}getGripSpace(){if(null===this._grip){this._grip=new Group;this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3;this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3}return this._grip}dispatchEvent(e){null!==this._targetRay&&this._targetRay.dispatchEvent(e);null!==this._grip&&this._grip.dispatchEvent(e);null!==this._hand&&this._hand.dispatchEvent(e);return this}disconnect(e){this.dispatchEvent({type:"disconnected",data:e});null!==this._targetRay&&(this._targetRay.visible=false);null!==this._grip&&(this._grip.visible=false);null!==this._hand&&(this._hand.visible=false);return this}update(e,t,n){let r=null;let i=null;let s=null;const a=this._targetRay;const o=this._grip;const l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState){if(null!==a){r=t.getPose(e.targetRaySpace,n);if(null!==r){a.matrix.fromArray(r.transform.matrix);a.matrix.decompose(a.position,a.rotation,a.scale);if(r.linearVelocity){a.hasLinearVelocity=true;a.linearVelocity.copy(r.linearVelocity)}else a.hasLinearVelocity=false;if(r.angularVelocity){a.hasAngularVelocity=true;a.angularVelocity.copy(r.angularVelocity)}else a.hasAngularVelocity=false;this.dispatchEvent(Vo)}}if(l&&e.hand){s=true;for(const r of e.hand.values()){const e=t.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const e=new Group;e.matrixAutoUpdate=false;e.visible=false;l.joints[r.jointName]=e;l.add(e)}const i=l.joints[r.jointName];if(null!==e){i.matrix.fromArray(e.transform.matrix);i.matrix.decompose(i.position,i.rotation,i.scale);i.jointRadius=e.radius}i.visible=null!==e}const r=l.joints["index-finger-tip"];const i=l.joints["thumb-tip"];const a=r.position.distanceTo(i.position);const o=.02;const c=.005;if(l.inputState.pinching&&a>o+c){l.inputState.pinching=false;this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})}else if(!l.inputState.pinching&&a<=o-c){l.inputState.pinching=true;this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this})}}else if(null!==o&&e.gripSpace){i=t.getPose(e.gripSpace,n);if(null!==i){o.matrix.fromArray(i.transform.matrix);o.matrix.decompose(o.position,o.rotation,o.scale);if(i.linearVelocity){o.hasLinearVelocity=true;o.linearVelocity.copy(i.linearVelocity)}else o.hasLinearVelocity=false;if(i.angularVelocity){o.hasAngularVelocity=true;o.angularVelocity.copy(i.angularVelocity)}else o.hasAngularVelocity=false}}}null!==a&&(a.visible=null!==r);null!==o&&(o.visible=null!==i);null!==l&&(l.visible=null!==s);return this}}class DepthTexture extends Texture{constructor(e,t,n,r,i,s,a,o,l,c){c=void 0!==c?c:Ge;if(c!==Ge&&c!==Fe)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===Ge&&(n=Te);void 0===n&&c===Fe&&(n=De);super(null,r,i,s,a,o,c,n,l);this.image={width:e,height:t};this.magFilter=void 0!==a?a:de;this.minFilter=void 0!==o?o:de;this.flipY=false;this.generateMipmaps=false}}DepthTexture.prototype.isDepthTexture=true;class WebXRManager extends EventDispatcher{constructor(e,t){super();const n=this;let r=null;let i=1;let s=null;let a="local-floor";const o=e.extensions.has("WEBGL_multisampled_render_to_texture");let l=null;let c=null;let u=null;let h=null;let d=false;let p=null;const f=t.getContextAttributes();let m=null;let g=null;const y=[];const x=new Map;const b=new PerspectiveCamera;b.layers.enable(1);b.viewport=new Vector4;const _=new PerspectiveCamera;_.layers.enable(2);_.viewport=new Vector4;const M=[b,_];const w=new ArrayCamera;w.layers.enable(1);w.layers.enable(2);let S=null;let T=null;this.cameraAutoUpdate=true;this.enabled=false;this.isPresenting=false;this.getController=function(e){let t=y[e];if(void 0===t){t=new WebXRController;y[e]=t}return t.getTargetRaySpace()};this.getControllerGrip=function(e){let t=y[e];if(void 0===t){t=new WebXRController;y[e]=t}return t.getGripSpace()};this.getHand=function(e){let t=y[e];if(void 0===t){t=new WebXRController;y[e]=t}return t.getHandSpace()};function onSessionEvent(e){const t=x.get(e.inputSource);t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function onSessionEnd(){x.forEach((function(e,t){e.disconnect(t)}));x.clear();S=null;T=null;e.setRenderTarget(m);h=null;u=null;c=null;r=null;g=null;C.stop();n.isPresenting=false;n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(e){i=e;true===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")};this.setReferenceSpaceType=function(e){a=e;true===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")};this.getReferenceSpace=function(){return s};this.getBaseLayer=function(){return null!==u?u:h};this.getBinding=function(){return c};this.getFrame=function(){return p};this.getSession=function(){return r};this.setSession=async function(l){r=l;if(null!==r){m=e.getRenderTarget();r.addEventListener("select",onSessionEvent);r.addEventListener("selectstart",onSessionEvent);r.addEventListener("selectend",onSessionEvent);r.addEventListener("squeeze",onSessionEvent);r.addEventListener("squeezestart",onSessionEvent);r.addEventListener("squeezeend",onSessionEvent);r.addEventListener("end",onSessionEnd);r.addEventListener("inputsourceschange",onInputSourcesChange);true!==f.xrCompatible&&await t.makeXRCompatible();if(void 0===r.renderState.layers||false===e.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||f.antialias,alpha:f.alpha,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:i};h=new XRWebGLLayer(r,t,n);r.updateRenderState({baseLayer:h});g=new WebGLRenderTarget(h.framebufferWidth,h.framebufferHeight,{format:Ne,type:Me,encoding:e.outputEncoding})}else{d=f.antialias;let n=null;let s=null;let a=null;if(f.depth){a=f.stencil?35056:33190;n=f.stencil?Fe:Ge;s=f.stencil?De:Te}const l={colorFormat:f.alpha||d?32856:32849,depthFormat:a,scaleFactor:i};c=new XRWebGLBinding(r,t);u=c.createProjectionLayer(l);r.updateRenderState({layers:[u]});g=d?new WebGLMultisampleRenderTarget(u.textureWidth,u.textureHeight,{format:Ne,type:Me,depthTexture:new DepthTexture(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:f.stencil,ignoreDepth:u.ignoreDepthValues,useRenderToTexture:o,encoding:e.outputEncoding}):new WebGLRenderTarget(u.textureWidth,u.textureHeight,{format:f.alpha?Ne:Ve,type:Me,depthTexture:new DepthTexture(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:f.stencil,ignoreDepth:u.ignoreDepthValues,encoding:e.outputEncoding})}this.setFoveation(1);s=await r.requestReferenceSpace(a);C.setContext(r);C.start();n.isPresenting=true;n.dispatchEvent({type:"sessionstart"})}};function onInputSourcesChange(e){const t=r.inputSources;for(let e=0;e<y.length;e++)x.set(t[e],y[e]);for(let t=0;t<e.removed.length;t++){const n=e.removed[t];const r=x.get(n);if(r){r.dispatchEvent({type:"disconnected",data:n});x.delete(n)}}for(let t=0;t<e.added.length;t++){const n=e.added[t];const r=x.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}const E=new Vector3;const A=new Vector3;function setProjectionFromUnion(e,t,n){E.setFromMatrixPosition(t.matrixWorld);A.setFromMatrixPosition(n.matrixWorld);const r=E.distanceTo(A);const i=t.projectionMatrix.elements;const s=n.projectionMatrix.elements;const a=i[14]/(i[10]-1);const o=i[14]/(i[10]+1);const l=(i[9]+1)/i[5];const c=(i[9]-1)/i[5];const u=(i[8]-1)/i[0];const h=(s[8]+1)/s[0];const d=a*u;const p=a*h;const f=r/(-u+h);const m=f*-u;t.matrixWorld.decompose(e.position,e.quaternion,e.scale);e.translateX(m);e.translateZ(f);e.matrixWorld.compose(e.position,e.quaternion,e.scale);e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=a+f;const y=o+f;const x=d-m;const b=p+(r-m);const _=l*o/y*g;const M=c*o/y*g;e.projectionMatrix.makePerspective(x,b,_,M,g,y)}function updateCamera(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix);e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===r)return;w.near=_.near=b.near=e.near;w.far=_.far=b.far=e.far;if(S!==w.near||T!==w.far){r.updateRenderState({depthNear:w.near,depthFar:w.far});S=w.near;T=w.far}const t=e.parent;const n=w.cameras;updateCamera(w,t);for(let e=0;e<n.length;e++)updateCamera(n[e],t);w.matrixWorld.decompose(w.position,w.quaternion,w.scale);e.position.copy(w.position);e.quaternion.copy(w.quaternion);e.scale.copy(w.scale);e.matrix.copy(w.matrix);e.matrixWorld.copy(w.matrixWorld);const i=e.children;for(let e=0,t=i.length;e<t;e++)i[e].updateMatrixWorld(true);2===n.length?setProjectionFromUnion(w,b,_):w.projectionMatrix.copy(b.projectionMatrix)};this.getCamera=function(){return w};this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==h?h.fixedFoveation:void 0};this.setFoveation=function(e){null!==u&&(u.fixedFoveation=e);null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=e)};let L=null;function onAnimationFrame(t,n){l=n.getViewerPose(s);p=n;if(null!==l){const t=l.views;if(null!==h){e.setRenderTargetFramebuffer(g,h.framebuffer);e.setRenderTarget(g)}let n=false;if(t.length!==w.cameras.length){w.cameras.length=0;n=true}for(let r=0;r<t.length;r++){const i=t[r];let s=null;if(null!==h)s=h.getViewport(i);else{const t=c.getViewSubImage(u,i);s=t.viewport;if(0===r){e.setRenderTargetTextures(g,t.colorTexture,u.ignoreDepthValues?void 0:t.depthStencilTexture);e.setRenderTarget(g)}}const a=M[r];a.matrix.fromArray(i.transform.matrix);a.projectionMatrix.fromArray(i.projectionMatrix);a.viewport.set(s.x,s.y,s.width,s.height);0===r&&w.matrix.copy(a.matrix);true===n&&w.cameras.push(a)}}const i=r.inputSources;for(let e=0;e<y.length;e++){const t=y[e];const r=i[e];t.update(r,n,s)}L&&L(t,n);p=null}const C=new WebGLAnimation;C.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(e){L=e};this.dispose=function(){}}}function WebGLMaterials(e){function refreshFogUniforms(e,t){e.fogColor.value.copy(t.color);if(t.isFog){e.fogNear.value=t.near;e.fogFar.value=t.far}else t.isFogExp2&&(e.fogDensity.value=t.density)}function refreshMaterialUniforms(e,t,n,r,i){if(t.isMeshBasicMaterial)refreshUniformsCommon(e,t);else if(t.isMeshLambertMaterial){refreshUniformsCommon(e,t);refreshUniformsLambert(e,t)}else if(t.isMeshToonMaterial){refreshUniformsCommon(e,t);refreshUniformsToon(e,t)}else if(t.isMeshPhongMaterial){refreshUniformsCommon(e,t);refreshUniformsPhong(e,t)}else if(t.isMeshStandardMaterial){refreshUniformsCommon(e,t);t.isMeshPhysicalMaterial?refreshUniformsPhysical(e,t,i):refreshUniformsStandard(e,t)}else if(t.isMeshMatcapMaterial){refreshUniformsCommon(e,t);refreshUniformsMatcap(e,t)}else if(t.isMeshDepthMaterial){refreshUniformsCommon(e,t);refreshUniformsDepth(e,t)}else if(t.isMeshDistanceMaterial){refreshUniformsCommon(e,t);refreshUniformsDistance(e,t)}else if(t.isMeshNormalMaterial){refreshUniformsCommon(e,t);refreshUniformsNormal(e,t)}else if(t.isLineBasicMaterial){refreshUniformsLine(e,t);t.isLineDashedMaterial&&refreshUniformsDash(e,t)}else if(t.isPointsMaterial)refreshUniformsPoints(e,t,n,r);else if(t.isSpriteMaterial)refreshUniformsSprites(e,t);else if(t.isShadowMaterial){e.color.value.copy(t.color);e.opacity.value=t.opacity}else t.isShaderMaterial&&(t.uniformsNeedUpdate=false)}function refreshUniformsCommon(t,n){t.opacity.value=n.opacity;n.color&&t.diffuse.value.copy(n.color);n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity);n.map&&(t.map.value=n.map);n.alphaMap&&(t.alphaMap.value=n.alphaMap);n.specularMap&&(t.specularMap.value=n.specularMap);n.alphaTest>0&&(t.alphaTest.value=n.alphaTest);const r=e.get(n).envMap;if(r){t.envMap.value=r;t.flipEnvMap.value=r.isCubeTexture&&false===r.isRenderTargetTexture?-1:1;t.reflectivity.value=n.reflectivity;t.ior.value=n.ior;t.refractionRatio.value=n.refractionRatio}if(n.lightMap){t.lightMap.value=n.lightMap;t.lightMapIntensity.value=n.lightMapIntensity}if(n.aoMap){t.aoMap.value=n.aoMap;t.aoMapIntensity.value=n.aoMapIntensity}let i;n.map?i=n.map:n.specularMap?i=n.specularMap:n.displacementMap?i=n.displacementMap:n.normalMap?i=n.normalMap:n.bumpMap?i=n.bumpMap:n.roughnessMap?i=n.roughnessMap:n.metalnessMap?i=n.metalnessMap:n.alphaMap?i=n.alphaMap:n.emissiveMap?i=n.emissiveMap:n.clearcoatMap?i=n.clearcoatMap:n.clearcoatNormalMap?i=n.clearcoatNormalMap:n.clearcoatRoughnessMap?i=n.clearcoatRoughnessMap:n.specularIntensityMap?i=n.specularIntensityMap:n.specularColorMap?i=n.specularColorMap:n.transmissionMap?i=n.transmissionMap:n.thicknessMap?i=n.thicknessMap:n.sheenColorMap?i=n.sheenColorMap:n.sheenRoughnessMap&&(i=n.sheenRoughnessMap);if(void 0!==i){i.isWebGLRenderTarget&&(i=i.texture);true===i.matrixAutoUpdate&&i.updateMatrix();t.uvTransform.value.copy(i.matrix)}let s;n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap);if(void 0!==s){s.isWebGLRenderTarget&&(s=s.texture);true===s.matrixAutoUpdate&&s.updateMatrix();t.uv2Transform.value.copy(s.matrix)}}function refreshUniformsLine(e,t){e.diffuse.value.copy(t.color);e.opacity.value=t.opacity}function refreshUniformsDash(e,t){e.dashSize.value=t.dashSize;e.totalSize.value=t.dashSize+t.gapSize;e.scale.value=t.scale}function refreshUniformsPoints(e,t,n,r){e.diffuse.value.copy(t.color);e.opacity.value=t.opacity;e.size.value=t.size*n;e.scale.value=.5*r;t.map&&(e.map.value=t.map);t.alphaMap&&(e.alphaMap.value=t.alphaMap);t.alphaTest>0&&(e.alphaTest.value=t.alphaTest);let i;t.map?i=t.map:t.alphaMap&&(i=t.alphaMap);if(void 0!==i){true===i.matrixAutoUpdate&&i.updateMatrix();e.uvTransform.value.copy(i.matrix)}}function refreshUniformsSprites(e,t){e.diffuse.value.copy(t.color);e.opacity.value=t.opacity;e.rotation.value=t.rotation;t.map&&(e.map.value=t.map);t.alphaMap&&(e.alphaMap.value=t.alphaMap);t.alphaTest>0&&(e.alphaTest.value=t.alphaTest);let n;t.map?n=t.map:t.alphaMap&&(n=t.alphaMap);if(void 0!==n){true===n.matrixAutoUpdate&&n.updateMatrix();e.uvTransform.value.copy(n.matrix)}}function refreshUniformsLambert(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}function refreshUniformsPhong(e,t){e.specular.value.copy(t.specular);e.shininess.value=Math.max(t.shininess,1e-4);t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap);if(t.bumpMap){e.bumpMap.value=t.bumpMap;e.bumpScale.value=t.bumpScale;t.side===d&&(e.bumpScale.value*=-1)}if(t.normalMap){e.normalMap.value=t.normalMap;e.normalScale.value.copy(t.normalScale);t.side===d&&e.normalScale.value.negate()}if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}}function refreshUniformsToon(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap);t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap);if(t.bumpMap){e.bumpMap.value=t.bumpMap;e.bumpScale.value=t.bumpScale;t.side===d&&(e.bumpScale.value*=-1)}if(t.normalMap){e.normalMap.value=t.normalMap;e.normalScale.value.copy(t.normalScale);t.side===d&&e.normalScale.value.negate()}if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}}function refreshUniformsStandard(t,n){t.roughness.value=n.roughness;t.metalness.value=n.metalness;n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap);n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap);n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap);if(n.bumpMap){t.bumpMap.value=n.bumpMap;t.bumpScale.value=n.bumpScale;n.side===d&&(t.bumpScale.value*=-1)}if(n.normalMap){t.normalMap.value=n.normalMap;t.normalScale.value.copy(n.normalScale);n.side===d&&t.normalScale.value.negate()}if(n.displacementMap){t.displacementMap.value=n.displacementMap;t.displacementScale.value=n.displacementScale;t.displacementBias.value=n.displacementBias}const r=e.get(n).envMap;r&&(t.envMapIntensity.value=n.envMapIntensity)}function refreshUniformsPhysical(e,t,n){refreshUniformsStandard(e,t);e.ior.value=t.ior;if(t.sheen>0){e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen);e.sheenRoughness.value=t.sheenRoughness;t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap);t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap)}if(t.clearcoat>0){e.clearcoat.value=t.clearcoat;e.clearcoatRoughness.value=t.clearcoatRoughness;t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap);t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap);if(t.clearcoatNormalMap){e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale);e.clearcoatNormalMap.value=t.clearcoatNormalMap;t.side===d&&e.clearcoatNormalScale.value.negate()}}if(t.transmission>0){e.transmission.value=t.transmission;e.transmissionSamplerMap.value=n.texture;e.transmissionSamplerSize.value.set(n.width,n.height);t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap);e.thickness.value=t.thickness;t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap);e.attenuationDistance.value=t.attenuationDistance;e.attenuationColor.value.copy(t.attenuationColor)}e.specularIntensity.value=t.specularIntensity;e.specularColor.value.copy(t.specularColor);t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap);t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap)}function refreshUniformsMatcap(e,t){t.matcap&&(e.matcap.value=t.matcap);if(t.bumpMap){e.bumpMap.value=t.bumpMap;e.bumpScale.value=t.bumpScale;t.side===d&&(e.bumpScale.value*=-1)}if(t.normalMap){e.normalMap.value=t.normalMap;e.normalScale.value.copy(t.normalScale);t.side===d&&e.normalScale.value.negate()}if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}}function refreshUniformsDepth(e,t){if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}}function refreshUniformsDistance(e,t){if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}e.referencePosition.value.copy(t.referencePosition);e.nearDistance.value=t.nearDistance;e.farDistance.value=t.farDistance}function refreshUniformsNormal(e,t){if(t.bumpMap){e.bumpMap.value=t.bumpMap;e.bumpScale.value=t.bumpScale;t.side===d&&(e.bumpScale.value*=-1)}if(t.normalMap){e.normalMap.value=t.normalMap;e.normalScale.value.copy(t.normalScale);t.side===d&&e.normalScale.value.negate()}if(t.displacementMap){e.displacementMap.value=t.displacementMap;e.displacementScale.value=t.displacementScale;e.displacementBias.value=t.displacementBias}}return{refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms}}function createCanvasElement(){const e=createElementNS("canvas");e.style.display="block";return e}function WebGLRenderer(t={}){const n=void 0!==t.canvas?t.canvas:createCanvasElement(),r=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,s=void 0===t.depth||t.depth,a=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,l=void 0===t.premultipliedAlpha||t.premultipliedAlpha,c=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,u=void 0!==t.powerPreference?t.powerPreference:"default",f=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let m=null;let g=null;const y=[];const x=[];this.domElement=n;this.debug={
/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
checkShaderErrors:true};this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;this.sortObjects=true;this.clippingPlanes=[];this.localClippingEnabled=false;this.outputEncoding=Xt;this.physicallyCorrectLights=false;this.toneMapping=Z;this.toneMappingExposure=1;const b=this;let _=false;let M=0;let w=0;let S=null;let T=-1;let E=null;const A=new Vector4;const L=new Vector4;let C=null;let R=n.width;let P=n.height;let I=1;let D=null;let B=null;const V=new Vector4(0,0,R,P);const N=new Vector4(0,0,R,P);let U=false;const z=[];const G=new Frustum;let F=false;let O=false;let H=null;const k=new Matrix4;const W=new Vector3;const j={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};function getTargetPixelRatio(){return null===S?I:1}let q=r;function getContext(e,t){for(let r=0;r<e.length;r++){const i=e[r];const s=n.getContext(i,t);if(null!==s)return s}return null}try{const t={alpha:i,depth:s,stencil:a,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:f};"setAttribute"in n&&n.setAttribute("data-engine",`three.js r${e}`);n.addEventListener("webglcontextlost",onContextLost,false);n.addEventListener("webglcontextrestored",onContextRestore,false);if(null===q){const e=["webgl2","webgl","experimental-webgl"];true===b.isWebGL1Renderer&&e.shift();q=getContext(e,t);if(null===q)throw getContext(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===q.getShaderPrecisionFormat&&(q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){console.error("THREE.WebGLRenderer: "+e.message);throw e}let X,J,Y,Q;let K,$,ee,te,ne,re,ie;let se,ae,oe,le,ce,he;let pe,fe,me,ge;let ye,ve;function initGLContext(){X=new WebGLExtensions(q);J=new WebGLCapabilities(q,X,t);X.init(J);ye=new WebGLUtils(q,X,J);Y=new WebGLState(q,X,J);z[0]=1029;Q=new WebGLInfo(q);K=new WebGLProperties;$=new WebGLTextures(q,X,Y,K,J,ye,Q);ee=new WebGLCubeMaps(b);te=new WebGLCubeUVMaps(b);ne=new WebGLAttributes(q,J);ve=new WebGLBindingStates(q,X,ne,J);re=new WebGLGeometries(q,ne,Q,ve);ie=new WebGLObjects(q,re,ne,Q);fe=new WebGLMorphtargets(q,J,$);ce=new WebGLClipping(K);se=new WebGLPrograms(b,ee,te,X,J,ve,ce);ae=new WebGLMaterials(K);oe=new WebGLRenderLists;le=new WebGLRenderStates(X,J);pe=new WebGLBackground(b,ee,Y,ie,l);he=new WebGLShadowMap(b,ie,J);me=new WebGLBufferRenderer(q,X,Q,J);ge=new WebGLIndexedBufferRenderer(q,X,Q,J);Q.programs=se.programs;b.capabilities=J;b.extensions=X;b.properties=K;b.renderLists=oe;b.shadowMap=he;b.state=Y;b.info=Q}initGLContext();const xe=new WebXRManager(b,q);this.xr=xe;this.getContext=function(){return q};this.getContextAttributes=function(){return q.getContextAttributes()};this.forceContextLoss=function(){const e=X.get("WEBGL_lose_context");e&&e.loseContext()};this.forceContextRestore=function(){const e=X.get("WEBGL_lose_context");e&&e.restoreContext()};this.getPixelRatio=function(){return I};this.setPixelRatio=function(e){if(void 0!==e){I=e;this.setSize(R,P,false)}};this.getSize=function(e){return e.set(R,P)};this.setSize=function(e,t,r){if(xe.isPresenting)console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");else{R=e;P=t;n.width=Math.floor(e*I);n.height=Math.floor(t*I);if(false!==r){n.style.width=e+"px";n.style.height=t+"px"}this.setViewport(0,0,e,t)}};this.getDrawingBufferSize=function(e){return e.set(R*I,P*I).floor()};this.setDrawingBufferSize=function(e,t,r){R=e;P=t;I=r;n.width=Math.floor(e*r);n.height=Math.floor(t*r);this.setViewport(0,0,e,t)};this.getCurrentViewport=function(e){return e.copy(A)};this.getViewport=function(e){return e.copy(V)};this.setViewport=function(e,t,n,r){e.isVector4?V.set(e.x,e.y,e.z,e.w):V.set(e,t,n,r);Y.viewport(A.copy(V).multiplyScalar(I).floor())};this.getScissor=function(e){return e.copy(N)};this.setScissor=function(e,t,n,r){e.isVector4?N.set(e.x,e.y,e.z,e.w):N.set(e,t,n,r);Y.scissor(L.copy(N).multiplyScalar(I).floor())};this.getScissorTest=function(){return U};this.setScissorTest=function(e){Y.setScissorTest(U=e)};this.setOpaqueSort=function(e){D=e};this.setTransparentSort=function(e){B=e};this.getClearColor=function(e){return e.copy(pe.getClearColor())};this.setClearColor=function(){pe.setClearColor.apply(pe,arguments)};this.getClearAlpha=function(){return pe.getClearAlpha()};this.setClearAlpha=function(){pe.setClearAlpha.apply(pe,arguments)};this.clear=function(e,t,n){let r=0;(void 0===e||e)&&(r|=16384);(void 0===t||t)&&(r|=256);(void 0===n||n)&&(r|=1024);q.clear(r)};this.clearColor=function(){this.clear(true,false,false)};this.clearDepth=function(){this.clear(false,true,false)};this.clearStencil=function(){this.clear(false,false,true)};this.dispose=function(){n.removeEventListener("webglcontextlost",onContextLost,false);n.removeEventListener("webglcontextrestored",onContextRestore,false);oe.dispose();le.dispose();K.dispose();ee.dispose();te.dispose();ie.dispose();ve.dispose();se.dispose();xe.dispose();xe.removeEventListener("sessionstart",onXRSessionStart);xe.removeEventListener("sessionend",onXRSessionEnd);if(H){H.dispose();H=null}we.stop()};function onContextLost(e){e.preventDefault();console.log("THREE.WebGLRenderer: Context Lost.");_=true}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored.");_=false;const e=Q.autoReset;const t=he.enabled;const n=he.autoUpdate;const r=he.needsUpdate;const i=he.type;initGLContext();Q.autoReset=e;he.enabled=t;he.autoUpdate=n;he.needsUpdate=r;he.type=i}function onMaterialDispose(e){const t=e.target;t.removeEventListener("dispose",onMaterialDispose);deallocateMaterial(t)}function deallocateMaterial(e){releaseMaterialProgramReferences(e);K.remove(e)}function releaseMaterialProgramReferences(e){const t=K.get(e).programs;if(void 0!==t){t.forEach((function(e){se.releaseProgram(e)}));e.isShaderMaterial&&se.releaseShaderCache(e)}}this.renderBufferDirect=function(e,t,n,r,i,s){null===t&&(t=j);const a=i.isMesh&&i.matrixWorld.determinant()<0;const o=setProgram(e,t,n,r,i);Y.setMaterial(r,a);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u=1;if(true===r.wireframe){l=re.getWireframeAttribute(n);u=2}ve.setup(i,r,o,n,l);let h;let d=me;if(null!==l){h=ne.get(l);d=ge;d.setIndex(h)}const p=null!==l?l.count:c.count;const f=n.drawRange.start*u;const m=n.drawRange.count*u;const g=null!==s?s.start*u:0;const y=null!==s?s.count*u:Infinity;const x=Math.max(f,g);const b=Math.min(p,f+m,g+y)-1;const _=Math.max(0,b-x+1);if(0!==_){if(i.isMesh)if(true===r.wireframe){Y.setLineWidth(r.wireframeLinewidth*getTargetPixelRatio());d.setMode(1)}else d.setMode(4);else if(i.isLine){let e=r.linewidth;void 0===e&&(e=1);Y.setLineWidth(e*getTargetPixelRatio());i.isLineSegments?d.setMode(1):i.isLineLoop?d.setMode(2):d.setMode(3)}else i.isPoints?d.setMode(0):i.isSprite&&d.setMode(4);if(i.isInstancedMesh)d.renderInstances(x,_,i.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(x,_,e)}else d.render(x,_)}};this.compile=function(e,t){g=le.get(e);g.init();x.push(g);e.traverseVisible((function(e){if(e.isLight&&e.layers.test(t.layers)){g.pushLight(e);e.castShadow&&g.pushShadow(e)}}));g.setupLights(b.physicallyCorrectLights);e.traverse((function(t){const n=t.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++){const i=n[r];getProgram(i,e,t)}else getProgram(n,e,t)}));x.pop();g=null};let _e=null;function onAnimationFrame(e){_e&&_e(e)}function onXRSessionStart(){we.stop()}function onXRSessionEnd(){we.start()}const we=new WebGLAnimation;we.setAnimationLoop(onAnimationFrame);"undefined"!==typeof window&&we.setContext(window);this.setAnimationLoop=function(e){_e=e;xe.setAnimationLoop(e);null===e?we.stop():we.start()};xe.addEventListener("sessionstart",onXRSessionStart);xe.addEventListener("sessionend",onXRSessionEnd);this.render=function(e,t){if(void 0!==t&&true!==t.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(true===_)return;true===e.autoUpdate&&e.updateMatrixWorld();null===t.parent&&t.updateMatrixWorld();if(true===xe.enabled&&true===xe.isPresenting){true===xe.cameraAutoUpdate&&xe.updateCamera(t);t=xe.getCamera()}true===e.isScene&&e.onBeforeRender(b,e,t,S);g=le.get(e,x.length);g.init();x.push(g);k.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);G.setFromProjectionMatrix(k);O=this.localClippingEnabled;F=ce.init(this.clippingPlanes,O,t);m=oe.get(e,y.length);m.init();y.push(m);projectObject(e,t,0,b.sortObjects);m.finish();true===b.sortObjects&&m.sort(D,B);true===F&&ce.beginShadows();const n=g.state.shadowsArray;he.render(n,e,t);true===F&&ce.endShadows();true===this.info.autoReset&&this.info.reset();pe.render(m,e);g.setupLights(b.physicallyCorrectLights);if(t.isArrayCamera){const n=t.cameras;for(let t=0,r=n.length;t<r;t++){const r=n[t];renderScene(m,e,r,r.viewport)}}else renderScene(m,e,t);if(null!==S){$.updateMultisampleRenderTarget(S);$.updateRenderTargetMipmap(S)}true===e.isScene&&e.onAfterRender(b,e,t);Y.buffers.depth.setTest(true);Y.buffers.depth.setMask(true);Y.buffers.color.setMask(true);Y.setPolygonOffset(false);ve.resetDefaultState();T=-1;E=null;x.pop();g=x.length>0?x[x.length-1]:null;y.pop();m=y.length>0?y[y.length-1]:null};function projectObject(e,t,n,r){if(false===e.visible)return;const i=e.layers.test(t.layers);if(i)if(e.isGroup)n=e.renderOrder;else if(e.isLOD)true===e.autoUpdate&&e.update(t);else if(e.isLight){g.pushLight(e);e.castShadow&&g.pushShadow(e)}else if(e.isSprite){if(!e.frustumCulled||G.intersectsSprite(e)){r&&W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=ie.update(e);const i=e.material;i.visible&&m.push(e,t,i,n,W.z,null)}}else if(e.isMesh||e.isLine||e.isPoints){if(e.isSkinnedMesh&&e.skeleton.frame!==Q.render.frame){e.skeleton.update();e.skeleton.frame=Q.render.frame}if(!e.frustumCulled||G.intersectsObject(e)){r&&W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=ie.update(e);const i=e.material;if(Array.isArray(i)){const r=t.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s];const o=i[a.materialIndex];o&&o.visible&&m.push(e,t,o,n,W.z,a)}}else i.visible&&m.push(e,t,i,n,W.z,null)}}const s=e.children;for(let e=0,i=s.length;e<i;e++)projectObject(s[e],t,n,r)}function renderScene(e,t,n,r){const i=e.opaque;const s=e.transmissive;const a=e.transparent;g.setupLightsView(n);s.length>0&&renderTransmissionPass(i,t,n);r&&Y.viewport(A.copy(r));i.length>0&&renderObjects(i,t,n);s.length>0&&renderObjects(s,t,n);a.length>0&&renderObjects(a,t,n)}function renderTransmissionPass(e,t,n){if(null===H){const e=true===o&&true===J.isWebGL2;const t=e?WebGLMultisampleRenderTarget:WebGLRenderTarget;H=new t(1024,1024,{generateMipmaps:true,type:null!==ye.convert(Ce)?Ce:Me,minFilter:be,magFilter:de,wrapS:ue,wrapT:ue,useRenderToTexture:X.has("WEBGL_multisampled_render_to_texture")})}const r=b.getRenderTarget();b.setRenderTarget(H);b.clear();const i=b.toneMapping;b.toneMapping=Z;renderObjects(e,t,n);b.toneMapping=i;$.updateMultisampleRenderTarget(H);$.updateRenderTargetMipmap(H);b.setRenderTarget(r)}function renderObjects(e,t,n){const r=true===t.isScene?t.overrideMaterial:null;for(let i=0,s=e.length;i<s;i++){const s=e[i];const a=s.object;const o=s.geometry;const l=null===r?s.material:r;const c=s.group;a.layers.test(n.layers)&&renderObject(a,t,n,o,l,c)}}function renderObject(e,t,n,r,i,s){e.onBeforeRender(b,t,n,r,i,s);e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld);e.normalMatrix.getNormalMatrix(e.modelViewMatrix);i.onBeforeRender(b,t,n,r,e,s);if(true===i.transparent&&i.side===p){i.side=d;i.needsUpdate=true;b.renderBufferDirect(n,t,r,i,e,s);i.side=h;i.needsUpdate=true;b.renderBufferDirect(n,t,r,i,e,s);i.side=p}else b.renderBufferDirect(n,t,r,i,e,s);e.onAfterRender(b,t,n,r,i,s)}function getProgram(e,t,n){true!==t.isScene&&(t=j);const r=K.get(e);const i=g.state.lights;const s=g.state.shadowsArray;const a=i.state.version;const o=se.getParameters(e,i.state,s,t,n);const l=se.getProgramCacheKey(o);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null;r.fog=t.fog;r.envMap=(e.isMeshStandardMaterial?te:ee).get(e.envMap||r.environment);if(void 0===c){e.addEventListener("dispose",onMaterialDispose);c=new Map;r.programs=c}let u=c.get(l);if(void 0!==u){if(r.currentProgram===u&&r.lightsStateVersion===a){updateCommonMaterialProperties(e,o);return u}}else{o.uniforms=se.getUniforms(e);e.onBuild(n,o,b);e.onBeforeCompile(o,b);u=se.acquireProgram(o,l);c.set(l,u);r.uniforms=o.uniforms}const h=r.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&true!==e.clipping||(h.clippingPlanes=ce.uniform);updateCommonMaterialProperties(e,o);r.needsLights=materialNeedsLights(e);r.lightsStateVersion=a;if(r.needsLights){h.ambientLightColor.value=i.state.ambient;h.lightProbe.value=i.state.probe;h.directionalLights.value=i.state.directional;h.directionalLightShadows.value=i.state.directionalShadow;h.spotLights.value=i.state.spot;h.spotLightShadows.value=i.state.spotShadow;h.rectAreaLights.value=i.state.rectArea;h.ltc_1.value=i.state.rectAreaLTC1;h.ltc_2.value=i.state.rectAreaLTC2;h.pointLights.value=i.state.point;h.pointLightShadows.value=i.state.pointShadow;h.hemisphereLights.value=i.state.hemi;h.directionalShadowMap.value=i.state.directionalShadowMap;h.directionalShadowMatrix.value=i.state.directionalShadowMatrix;h.spotShadowMap.value=i.state.spotShadowMap;h.spotShadowMatrix.value=i.state.spotShadowMatrix;h.pointShadowMap.value=i.state.pointShadowMap;h.pointShadowMatrix.value=i.state.pointShadowMatrix}const d=u.getUniforms();const p=WebGLUniforms.seqWithValue(d.seq,h);r.currentProgram=u;r.uniformsList=p;return u}function updateCommonMaterialProperties(e,t){const n=K.get(e);n.outputEncoding=t.outputEncoding;n.instancing=t.instancing;n.skinning=t.skinning;n.morphTargets=t.morphTargets;n.morphNormals=t.morphNormals;n.morphTargetsCount=t.morphTargetsCount;n.numClippingPlanes=t.numClippingPlanes;n.numIntersection=t.numClipIntersection;n.vertexAlphas=t.vertexAlphas;n.vertexTangents=t.vertexTangents;n.toneMapping=t.toneMapping}function setProgram(e,t,n,r,i){true!==t.isScene&&(t=j);$.resetTextureUnits();const s=t.fog;const a=r.isMeshStandardMaterial?t.environment:null;const o=null===S?b.outputEncoding:S.texture.encoding;const l=(r.isMeshStandardMaterial?te:ee).get(r.envMap||a);const c=true===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize;const u=!!r.normalMap&&!!n.attributes.tangent;const h=!!n.morphAttributes.position;const d=!!n.morphAttributes.normal;const p=!n.morphAttributes.position?0:n.morphAttributes.position.length;const f=r.toneMapped?b.toneMapping:Z;const m=K.get(r);const y=g.state.lights;if(true===F&&(true===O||e!==E)){const t=e===E&&r.id===T;ce.setState(r,e,t)}let x=false;if(r.version===m.__version)m.needsLights&&m.lightsStateVersion!==y.state.version||m.outputEncoding!==o||i.isInstancedMesh&&false===m.instancing?x=true:i.isInstancedMesh||true!==m.instancing?i.isSkinnedMesh&&false===m.skinning?x=true:i.isSkinnedMesh||true!==m.skinning?m.envMap!==l||r.fog&&m.fog!==s?x=true:void 0===m.numClippingPlanes||m.numClippingPlanes===ce.numPlanes&&m.numIntersection===ce.numIntersection?(m.vertexAlphas!==c||m.vertexTangents!==u||m.morphTargets!==h||m.morphNormals!==d||m.toneMapping!==f||true===J.isWebGL2&&m.morphTargetsCount!==p)&&(x=true):x=true:x=true:x=true;else{x=true;m.__version=r.version}let _=m.currentProgram;true===x&&(_=getProgram(r,t,i));let M=false;let w=false;let A=false;const L=_.getUniforms(),C=m.uniforms;if(Y.useProgram(_.program)){M=true;w=true;A=true}if(r.id!==T){T=r.id;w=true}if(M||E!==e){L.setValue(q,"projectionMatrix",e.projectionMatrix);J.logarithmicDepthBuffer&&L.setValue(q,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2));if(E!==e){E=e;w=true;A=true}if(r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const t=L.map.cameraPosition;void 0!==t&&t.setValue(q,W.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&L.setValue(q,"isOrthographic",true===e.isOrthographicCamera);(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&L.setValue(q,"viewMatrix",e.matrixWorldInverse)}if(i.isSkinnedMesh){L.setOptional(q,i,"bindMatrix");L.setOptional(q,i,"bindMatrixInverse");const e=i.skeleton;if(e)if(J.floatVertexTextures){null===e.boneTexture&&e.computeBoneTexture();L.setValue(q,"boneTexture",e.boneTexture,$);L.setValue(q,"boneTextureSize",e.boneTextureSize)}else L.setOptional(q,e,"boneMatrices")}!n||void 0===n.morphAttributes.position&&void 0===n.morphAttributes.normal||fe.update(i,n,r,_);if(w||m.receiveShadow!==i.receiveShadow){m.receiveShadow=i.receiveShadow;L.setValue(q,"receiveShadow",i.receiveShadow)}if(w){L.setValue(q,"toneMappingExposure",b.toneMappingExposure);m.needsLights&&markUniformsLightsNeedsUpdate(C,A);s&&r.fog&&ae.refreshFogUniforms(C,s);ae.refreshMaterialUniforms(C,r,I,P,H);WebGLUniforms.upload(q,m.uniformsList,C,$)}if(r.isShaderMaterial&&true===r.uniformsNeedUpdate){WebGLUniforms.upload(q,m.uniformsList,C,$);r.uniformsNeedUpdate=false}r.isSpriteMaterial&&L.setValue(q,"center",i.center);L.setValue(q,"modelViewMatrix",i.modelViewMatrix);L.setValue(q,"normalMatrix",i.normalMatrix);L.setValue(q,"modelMatrix",i.matrixWorld);return _}function markUniformsLightsNeedsUpdate(e,t){e.ambientLightColor.needsUpdate=t;e.lightProbe.needsUpdate=t;e.directionalLights.needsUpdate=t;e.directionalLightShadows.needsUpdate=t;e.pointLights.needsUpdate=t;e.pointLightShadows.needsUpdate=t;e.spotLights.needsUpdate=t;e.spotLightShadows.needsUpdate=t;e.rectAreaLights.needsUpdate=t;e.hemisphereLights.needsUpdate=t}function materialNeedsLights(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&true===e.lights}this.getActiveCubeFace=function(){return M};this.getActiveMipmapLevel=function(){return w};this.getRenderTarget=function(){return S};this.setRenderTargetTextures=function(e,t,n){K.get(e.texture).__webglTexture=t;K.get(e.depthTexture).__webglTexture=n;const r=K.get(e);r.__hasExternalTextures=true;if(r.__hasExternalTextures){r.__autoAllocateDepthBuffer=void 0===n;if(!r.__autoAllocateDepthBuffer&&e.useRenderToTexture){console.warn("render-to-texture extension was disabled because an external texture was provided");e.useRenderToTexture=false;e.useRenderbuffer=true}}};this.setRenderTargetFramebuffer=function(e,t){const n=K.get(e);n.__webglFramebuffer=t;n.__useDefaultFramebuffer=void 0===t};this.setRenderTarget=function(e,t=0,n=0){S=e;M=t;w=n;let r=true;if(e){const t=K.get(e);if(void 0!==t.__useDefaultFramebuffer){Y.bindFramebuffer(36160,null);r=false}else void 0===t.__webglFramebuffer?$.setupRenderTarget(e):t.__hasExternalTextures&&$.rebindTextures(e,K.get(e.texture).__webglTexture,K.get(e.depthTexture).__webglTexture)}let i=null;let s=false;let a=false;if(e){const n=e.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(a=true);const r=K.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget){i=r[t];s=true}else i=e.useRenderbuffer?K.get(e).__webglMultisampledFramebuffer:r;A.copy(e.viewport);L.copy(e.scissor);C=e.scissorTest}else{A.copy(V).multiplyScalar(I).floor();L.copy(N).multiplyScalar(I).floor();C=U}const o=Y.bindFramebuffer(36160,i);if(o&&J.drawBuffers&&r){let t=false;if(e){if(e.isWebGLMultipleRenderTargets){const n=e.texture;if(z.length!==n.length||36064!==z[0]){for(let e=0,t=n.length;e<t;e++)z[e]=36064+e;z.length=n.length;t=true}}else if(1!==z.length||36064!==z[0]){z[0]=36064;z.length=1;t=true}}else if(1!==z.length||1029!==z[0]){z[0]=1029;z.length=1;t=true}t&&(J.isWebGL2?q.drawBuffers(z):X.get("WEBGL_draw_buffers").drawBuffersWEBGL(z))}Y.viewport(A);Y.scissor(L);Y.setScissorTest(C);if(s){const r=K.get(e.texture);q.framebufferTexture2D(36160,36064,34069+t,r.__webglTexture,n)}else if(a){const r=K.get(e.texture);const i=t||0;q.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,i)}T=-1};this.readRenderTargetPixels=function(e,t,n,r,i,s,a){if(!(e&&e.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let o=K.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]);if(o){Y.bindFramebuffer(36160,o);try{const a=e.texture;const o=a.format;const l=a.type;if(o!==Ne&&ye.convert(o)!==q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const c=l===Ce&&(X.has("EXT_color_buffer_half_float")||J.isWebGL2&&X.has("EXT_color_buffer_float"));if(l!==Me&&ye.convert(l)!==q.getParameter(35738)&&!(l===Le&&(J.isWebGL2||X.has("OES_texture_float")||X.has("WEBGL_color_buffer_float")))&&!c){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}36053===q.checkFramebufferStatus(36160)?t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i&&q.readPixels(t,n,r,i,ye.convert(o),ye.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const e=null!==S?K.get(S).__webglFramebuffer:null;Y.bindFramebuffer(36160,e)}}};this.copyFramebufferToTexture=function(e,t,n=0){if(true!==t.isFramebufferTexture){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const r=Math.pow(2,-n);const i=Math.floor(t.image.width*r);const s=Math.floor(t.image.height*r);$.setTexture2D(t,0);q.copyTexSubImage2D(3553,n,0,0,e.x,e.y,i,s);Y.unbindTexture()};this.copyTextureToTexture=function(e,t,n,r=0){const i=t.image.width;const s=t.image.height;const a=ye.convert(n.format);const o=ye.convert(n.type);$.setTexture2D(n,0);q.pixelStorei(37440,n.flipY);q.pixelStorei(37441,n.premultiplyAlpha);q.pixelStorei(3317,n.unpackAlignment);t.isDataTexture?q.texSubImage2D(3553,r,e.x,e.y,i,s,a,o,t.image.data):t.isCompressedTexture?q.compressedTexSubImage2D(3553,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,a,t.mipmaps[0].data):q.texSubImage2D(3553,r,e.x,e.y,a,o,t.image);0===r&&n.generateMipmaps&&q.generateMipmap(3553);Y.unbindTexture()};this.copyTextureToTexture3D=function(e,t,n,r,i=0){if(b.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const s=e.max.x-e.min.x+1;const a=e.max.y-e.min.y+1;const o=e.max.z-e.min.z+1;const l=ye.convert(r.format);const c=ye.convert(r.type);let u;if(r.isDataTexture3D){$.setTexture3D(r,0);u=32879}else{if(!r.isDataTexture2DArray){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}$.setTexture2DArray(r,0);u=35866}q.pixelStorei(37440,r.flipY);q.pixelStorei(37441,r.premultiplyAlpha);q.pixelStorei(3317,r.unpackAlignment);const h=q.getParameter(3314);const d=q.getParameter(32878);const p=q.getParameter(3316);const f=q.getParameter(3315);const m=q.getParameter(32877);const g=n.isCompressedTexture?n.mipmaps[0]:n.image;q.pixelStorei(3314,g.width);q.pixelStorei(32878,g.height);q.pixelStorei(3316,e.min.x);q.pixelStorei(3315,e.min.y);q.pixelStorei(32877,e.min.z);if(n.isDataTexture||n.isDataTexture3D)q.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,g.data);else if(n.isCompressedTexture){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");q.compressedTexSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,g.data)}else q.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,g);q.pixelStorei(3314,h);q.pixelStorei(32878,d);q.pixelStorei(3316,p);q.pixelStorei(3315,f);q.pixelStorei(32877,m);0===i&&r.generateMipmaps&&q.generateMipmap(u);Y.unbindTexture()};this.initTexture=function(e){$.setTexture2D(e,0);Y.unbindTexture()};this.resetState=function(){M=0;w=0;S=null;Y.reset();ve.reset()};"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}WebGLRenderer.prototype.isWebGLRenderer=true;class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=true;class FogExp2{constructor(e,t=25e-5){this.name="";this.color=new Color(e);this.density=t}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}FogExp2.prototype.isFogExp2=true;class Fog{constructor(e,t=1,n=1e3){this.name="";this.color=new Color(e);this.near=t;this.far=n}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Fog.prototype.isFog=true;class Scene extends Object3D{constructor(){super();this.type="Scene";this.background=null;this.environment=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){super.copy(e,t);null!==e.background&&(this.background=e.background.clone());null!==e.environment&&(this.environment=e.environment.clone());null!==e.fog&&(this.fog=e.fog.clone());null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone());this.autoUpdate=e.autoUpdate;this.matrixAutoUpdate=e.matrixAutoUpdate;return this}toJSON(e){const t=super.toJSON(e);null!==this.fog&&(t.object.fog=this.fog.toJSON());return t}}Scene.prototype.isScene=true;class InterleavedBuffer{constructor(e,t){this.array=e;this.stride=t;this.count=void 0!==e?e.length/t:0;this.usage=gn;this.updateRange={offset:0,count:-1};this.version=0;this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(e){true===e&&this.version++}setUsage(e){this.usage=e;return this}copy(e){this.array=new e.array.constructor(e.array);this.count=e.count;this.stride=e.stride;this.usage=e.usage;return this}copyAt(e,t,n){e*=this.stride;n*=t.stride;for(let r=0,i=this.stride;r<i;r++)this.array[e+r]=t.array[n+r];return this}set(e,t=0){this.array.set(e,t);return this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={});void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID());void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]);const n=new this.constructor(t,this.stride);n.setUsage(this.usage);return n}onUpload(e){this.onUploadCallback=e;return this}toJSON(e){void 0===e.arrayBuffers&&(e.arrayBuffers={});void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID());void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer)));return{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}InterleavedBuffer.prototype.isInterleavedBuffer=true;const No=new Vector3;class InterleavedBufferAttribute{constructor(e,t,n,r=false){this.name="";this.data=e;this.itemSize=t;this.offset=n;this.normalized=true===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++){No.x=this.getX(t);No.y=this.getY(t);No.z=this.getZ(t);No.applyMatrix4(e);this.setXYZ(t,No.x,No.y,No.z)}return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++){No.x=this.getX(t);No.y=this.getY(t);No.z=this.getZ(t);No.applyNormalMatrix(e);this.setXYZ(t,No.x,No.y,No.z)}return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++){No.x=this.getX(t);No.y=this.getY(t);No.z=this.getZ(t);No.transformDirection(e);this.setXYZ(t,No.x,No.y,No.z)}return this}setX(e,t){this.data.array[e*this.data.stride+this.offset]=t;return this}setY(e,t){this.data.array[e*this.data.stride+this.offset+1]=t;return this}setZ(e,t){this.data.array[e*this.data.stride+this.offset+2]=t;return this}setW(e,t){this.data.array[e*this.data.stride+this.offset+3]=t;return this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){e=e*this.data.stride+this.offset;this.data.array[e+0]=t;this.data.array[e+1]=n;return this}setXYZ(e,t,n,r){e=e*this.data.stride+this.offset;this.data.array[e+0]=t;this.data.array[e+1]=n;this.data.array[e+2]=r;return this}setXYZW(e,t,n,r,i){e=e*this.data.stride+this.offset;this.data.array[e+0]=t;this.data.array[e+1]=n;this.data.array[e+2]=r;this.data.array[e+3]=i;return this}clone(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new BufferAttribute(new this.array.constructor(e),this.itemSize,this.normalized)}void 0===e.interleavedBuffers&&(e.interleavedBuffers={});void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e));return new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}void 0===e.interleavedBuffers&&(e.interleavedBuffers={});void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e));return{isInterleavedBufferAttribute:true,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute=true;class SpriteMaterial extends Material{constructor(e){super();this.type="SpriteMaterial";this.color=new Color(16777215);this.map=null;this.alphaMap=null;this.rotation=0;this.sizeAttenuation=true;this.transparent=true;this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.map=e.map;this.alphaMap=e.alphaMap;this.rotation=e.rotation;this.sizeAttenuation=e.sizeAttenuation;return this}}SpriteMaterial.prototype.isSpriteMaterial=true;let Uo;const zo=new Vector3;const Go=new Vector3;const Fo=new Vector3;const Oo=new Vector2;const Ho=new Vector2;const ko=new Matrix4;const Wo=new Vector3;const jo=new Vector3;const qo=new Vector3;const Xo=new Vector2;const Jo=new Vector2;const Yo=new Vector2;class Sprite extends Object3D{constructor(e){super();this.type="Sprite";if(void 0===Uo){Uo=new BufferGeometry;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]);const t=new InterleavedBuffer(e,5);Uo.setIndex([0,1,2,0,2,3]);Uo.setAttribute("position",new InterleavedBufferAttribute(t,3,0,false));Uo.setAttribute("uv",new InterleavedBufferAttribute(t,2,3,false))}this.geometry=Uo;this.material=void 0!==e?e:new SpriteMaterial;this.center=new Vector2(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');Go.setFromMatrixScale(this.matrixWorld);ko.copy(e.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld);Fo.setFromMatrixPosition(this.modelViewMatrix);e.camera.isPerspectiveCamera&&false===this.material.sizeAttenuation&&Go.multiplyScalar(-Fo.z);const n=this.material.rotation;let r,i;if(0!==n){i=Math.cos(n);r=Math.sin(n)}const s=this.center;transformVertex(Wo.set(-.5,-.5,0),Fo,s,Go,r,i);transformVertex(jo.set(.5,-.5,0),Fo,s,Go,r,i);transformVertex(qo.set(.5,.5,0),Fo,s,Go,r,i);Xo.set(0,0);Jo.set(1,0);Yo.set(1,1);let a=e.ray.intersectTriangle(Wo,jo,qo,false,zo);if(null===a){transformVertex(jo.set(-.5,.5,0),Fo,s,Go,r,i);Jo.set(0,1);a=e.ray.intersectTriangle(Wo,qo,jo,false,zo);if(null===a)return}const o=e.ray.origin.distanceTo(zo);o<e.near||o>e.far||t.push({distance:o,point:zo.clone(),uv:Triangle.getUV(zo,Wo,jo,qo,Xo,Jo,Yo,new Vector2),face:null,object:this})}copy(e){super.copy(e);void 0!==e.center&&this.center.copy(e.center);this.material=e.material;return this}}Sprite.prototype.isSprite=true;function transformVertex(e,t,n,r,i,s){Oo.subVectors(e,n).addScalar(.5).multiply(r);if(void 0!==i){Ho.x=s*Oo.x-i*Oo.y;Ho.y=i*Oo.x+s*Oo.y}else Ho.copy(Oo);e.copy(t);e.x+=Ho.x;e.y+=Ho.y;e.applyMatrix4(ko)}const Zo=new Vector3;const Qo=new Vector3;class LOD extends Object3D{constructor(){super();this._currentLevel=0;this.type="LOD";Object.defineProperties(this,{levels:{enumerable:true,value:[]},isLOD:{value:true}});this.autoUpdate=true}copy(e){super.copy(e,false);const t=e.levels;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.addLevel(n.object.clone(),n.distance)}this.autoUpdate=e.autoUpdate;return this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let r;for(r=0;r<n.length;r++)if(t<n[r].distance)break;n.splice(r,0,{distance:t,object:e});this.add(e);return this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,r;for(n=1,r=t.length;n<r;n++)if(e<t[n].distance)break;return t[n-1].object}return null}raycast(e,t){const n=this.levels;if(n.length>0){Zo.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(Zo);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Zo.setFromMatrixPosition(e.matrixWorld);Qo.setFromMatrixPosition(this.matrixWorld);const n=Zo.distanceTo(Qo)/e.zoom;t[0].object.visible=true;let r,i;for(r=1,i=t.length;r<i;r++){if(!(n>=t[r].distance))break;t[r-1].object.visible=false;t[r].object.visible=true}this._currentLevel=r-1;for(;r<i;r++)t[r].object.visible=false}}toJSON(e){const t=super.toJSON(e);false===this.autoUpdate&&(t.object.autoUpdate=false);t.object.levels=[];const n=this.levels;for(let e=0,r=n.length;e<r;e++){const r=n[e];t.object.levels.push({object:r.object.uuid,distance:r.distance})}return t}}const Ko=new Vector3;const $o=new Vector4;const el=new Vector4;const tl=new Vector3;const nl=new Matrix4;class SkinnedMesh extends Mesh{constructor(e,t){super(e,t);this.type="SkinnedMesh";this.bindMode="attached";this.bindMatrix=new Matrix4;this.bindMatrixInverse=new Matrix4}copy(e){super.copy(e);this.bindMode=e.bindMode;this.bindMatrix.copy(e.bindMatrix);this.bindMatrixInverse.copy(e.bindMatrixInverse);this.skeleton=e.skeleton;return this}bind(e,t){this.skeleton=e;if(void 0===t){this.updateMatrixWorld(true);this.skeleton.calculateInverses();t=this.matrixWorld}this.bindMatrix.copy(t);this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Vector4;const t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.x=t.getX(n);e.y=t.getY(n);e.z=t.getZ(n);e.w=t.getW(n);const r=1/e.manhattanLength();Infinity!==r?e.multiplyScalar(r):e.set(1,0,0,0);t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e);"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton;const r=this.geometry;$o.fromBufferAttribute(r.attributes.skinIndex,e);el.fromBufferAttribute(r.attributes.skinWeight,e);Ko.copy(t).applyMatrix4(this.bindMatrix);t.set(0,0,0);for(let e=0;e<4;e++){const r=el.getComponent(e);if(0!==r){const i=$o.getComponent(e);nl.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]);t.addScaledVector(tl.copy(Ko).applyMatrix4(nl),r)}}return t.applyMatrix4(this.bindMatrixInverse)}}SkinnedMesh.prototype.isSkinnedMesh=true;class Bone extends Object3D{constructor(){super();this.type="Bone"}}Bone.prototype.isBone=true;class DataTexture extends Texture{constructor(e=null,t=1,n=1,r,i,s,a,o,l=de,c=de,u,h){super(null,s,a,o,l,c,r,i,u,h);this.image={data:e,width:t,height:n};this.magFilter=l;this.minFilter=c;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1}}DataTexture.prototype.isDataTexture=true;const rl=new Matrix4;const il=new Matrix4;class Skeleton{constructor(e=[],t=[]){this.uuid=generateUUID();this.bones=e.slice(0);this.boneInverses=t;this.boneMatrices=null;this.boneTexture=null;this.boneTextureSize=0;this.frame=-1;this.init()}init(){const e=this.bones;const t=this.boneInverses;this.boneMatrices=new Float32Array(16*e.length);if(0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Matrix4;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert();this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];if(t){if(t.parent&&t.parent.isBone){t.matrix.copy(t.parent.matrixWorld).invert();t.matrix.multiply(t.matrixWorld)}else t.matrix.copy(t.matrixWorld);t.matrix.decompose(t.position,t.quaternion,t.scale)}}}update(){const e=this.bones;const t=this.boneInverses;const n=this.boneMatrices;const r=this.boneTexture;for(let r=0,i=e.length;r<i;r++){const i=e[r]?e[r].matrixWorld:il;rl.multiplyMatrices(i,t[r]);rl.toArray(n,16*r)}null!==r&&(r.needsUpdate=true)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=ceilPowerOfTwo(e);e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new DataTexture(t,e,e,Ne,Le);n.needsUpdate=true;this.boneMatrices=t;this.boneTexture=n;this.boneTextureSize=e;return this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}}dispose(){if(null!==this.boneTexture){this.boneTexture.dispose();this.boneTexture=null}}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,r=e.bones.length;n<r;n++){const r=e.bones[n];let i=t[r];if(void 0===i){console.warn("THREE.Skeleton: No bone found with UUID:",r);i=new Bone}this.bones.push(i);this.boneInverses.push((new Matrix4).fromArray(e.boneInverses[n]))}this.init();return this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones;const n=this.boneInverses;for(let r=0,i=t.length;r<i;r++){const i=t[r];e.bones.push(i.uuid);const s=n[r];e.boneInverses.push(s.toArray())}return e}}class InstancedBufferAttribute extends BufferAttribute{constructor(e,t,n,r=1){if("number"===typeof n){r=n;n=false;console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")}super(e,t,n);this.meshPerAttribute=r}copy(e){super.copy(e);this.meshPerAttribute=e.meshPerAttribute;return this}toJSON(){const e=super.toJSON();e.meshPerAttribute=this.meshPerAttribute;e.isInstancedBufferAttribute=true;return e}}InstancedBufferAttribute.prototype.isInstancedBufferAttribute=true;const sl=new Matrix4;const al=new Matrix4;const ol=[];const ll=new Mesh;class InstancedMesh extends Mesh{constructor(e,t,n){super(e,t);this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(16*n),16);this.instanceColor=null;this.count=n;this.frustumCulled=false}copy(e){super.copy(e);this.instanceMatrix.copy(e.instanceMatrix);null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone());this.count=e.count;return this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const n=this.matrixWorld;const r=this.count;ll.geometry=this.geometry;ll.material=this.material;if(void 0!==ll.material)for(let i=0;i<r;i++){this.getMatrixAt(i,sl);al.multiplyMatrices(n,sl);ll.matrixWorld=al;ll.raycast(e,ol);for(let e=0,n=ol.length;e<n;e++){const n=ol[e];n.instanceId=i;n.object=this;t.push(n)}ol.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count),3));t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}InstancedMesh.prototype.isInstancedMesh=true;class LineBasicMaterial extends Material{constructor(e){super();this.type="LineBasicMaterial";this.color=new Color(16777215);this.linewidth=1;this.linecap="round";this.linejoin="round";this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.linewidth=e.linewidth;this.linecap=e.linecap;this.linejoin=e.linejoin;return this}}LineBasicMaterial.prototype.isLineBasicMaterial=true;const cl=new Vector3;const ul=new Vector3;const hl=new Matrix4;const dl=new Ray;const pl=new Sphere;class Line extends Object3D{constructor(e=new BufferGeometry,t=new LineBasicMaterial){super();this.type="Line";this.geometry=e;this.material=t;this.updateMorphTargets()}copy(e){super.copy(e);this.material=e.material;this.geometry=e.geometry;return this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position;const n=[0];for(let e=1,r=t.count;e<r;e++){cl.fromBufferAttribute(t,e-1);ul.fromBufferAttribute(t,e);n[e]=n[e-1];n[e]+=cl.distanceTo(ul)}e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry;const r=this.matrixWorld;const i=e.params.Line.threshold;const s=n.drawRange;null===n.boundingSphere&&n.computeBoundingSphere();pl.copy(n.boundingSphere);pl.applyMatrix4(r);pl.radius+=i;if(false===e.ray.intersectsSphere(pl))return;hl.copy(r).invert();dl.copy(e.ray).applyMatrix4(hl);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3);const o=a*a;const l=new Vector3;const c=new Vector3;const u=new Vector3;const h=new Vector3;const d=this.isLineSegments?2:1;if(n.isBufferGeometry){const r=n.index;const i=n.attributes;const a=i.position;if(null!==r){const n=Math.max(0,s.start);const i=Math.min(r.count,s.start+s.count);for(let s=n,p=i-1;s<p;s+=d){const n=r.getX(s);const i=r.getX(s+1);l.fromBufferAttribute(a,n);c.fromBufferAttribute(a,i);const d=dl.distanceSqToSegment(l,c,h,u);if(d>o)continue;h.applyMatrix4(this.matrixWorld);const p=e.ray.origin.distanceTo(h);p<e.near||p>e.far||t.push({distance:p,point:u.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}else{const n=Math.max(0,s.start);const r=Math.min(a.count,s.start+s.count);for(let i=n,s=r-1;i<s;i+=d){l.fromBufferAttribute(a,i);c.fromBufferAttribute(a,i+1);const n=dl.distanceSqToSegment(l,c,h,u);if(n>o)continue;h.applyMatrix4(this.matrixWorld);const r=e.ray.origin.distanceTo(h);r<e.near||r>e.far||t.push({distance:r,point:u.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes;const n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0);this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Line.prototype.isLine=true;const fl=new Vector3;const ml=new Vector3;class LineSegments extends Line{constructor(e,t){super(e,t);this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position;const n=[];for(let e=0,r=t.count;e<r;e+=2){fl.fromBufferAttribute(t,e);ml.fromBufferAttribute(t,e+1);n[e]=0===e?0:n[e-1];n[e+1]=n[e]+fl.distanceTo(ml)}e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}LineSegments.prototype.isLineSegments=true;class LineLoop extends Line{constructor(e,t){super(e,t);this.type="LineLoop"}}LineLoop.prototype.isLineLoop=true;class PointsMaterial extends Material{constructor(e){super();this.type="PointsMaterial";this.color=new Color(16777215);this.map=null;this.alphaMap=null;this.size=1;this.sizeAttenuation=true;this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.map=e.map;this.alphaMap=e.alphaMap;this.size=e.size;this.sizeAttenuation=e.sizeAttenuation;return this}}PointsMaterial.prototype.isPointsMaterial=true;const gl=new Matrix4;const yl=new Ray;const vl=new Sphere;const xl=new Vector3;class Points extends Object3D{constructor(e=new BufferGeometry,t=new PointsMaterial){super();this.type="Points";this.geometry=e;this.material=t;this.updateMorphTargets()}copy(e){super.copy(e);this.material=e.material;this.geometry=e.geometry;return this}raycast(e,t){const n=this.geometry;const r=this.matrixWorld;const i=e.params.Points.threshold;const s=n.drawRange;null===n.boundingSphere&&n.computeBoundingSphere();vl.copy(n.boundingSphere);vl.applyMatrix4(r);vl.radius+=i;if(false===e.ray.intersectsSphere(vl))return;gl.copy(r).invert();yl.copy(e.ray).applyMatrix4(gl);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3);const o=a*a;if(n.isBufferGeometry){const i=n.index;const a=n.attributes;const l=a.position;if(null!==i){const n=Math.max(0,s.start);const a=Math.min(i.count,s.start+s.count);for(let s=n,c=a;s<c;s++){const n=i.getX(s);xl.fromBufferAttribute(l,n);testPoint(xl,n,o,r,e,t,this)}}else{const n=Math.max(0,s.start);const i=Math.min(l.count,s.start+s.count);for(let s=n,a=i;s<a;s++){xl.fromBufferAttribute(l,s);testPoint(xl,s,o,r,e,t,this)}}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes;const n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0);this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Points.prototype.isPoints=true;function testPoint(e,t,n,r,i,s,a){const o=yl.distanceSqToPoint(e);if(o<n){const n=new Vector3;yl.closestPointToPoint(e,n);n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:t,face:null,object:a})}}class VideoTexture extends Texture{constructor(e,t,n,r,i,s,a,o,l){super(e,t,n,r,i,s,a,o,l);this.format=void 0!==a?a:Ve;this.minFilter=void 0!==s?s:ye;this.magFilter=void 0!==i?i:ye;this.generateMipmaps=false;const c=this;function updateVideo(){c.needsUpdate=true;e.requestVideoFrameCallback(updateVideo)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(updateVideo)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;const t="requestVideoFrameCallback"in e;false===t&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=true)}}VideoTexture.prototype.isVideoTexture=true;class FramebufferTexture extends Texture{constructor(e,t,n){super({width:e,height:t});this.format=n;this.magFilter=de;this.minFilter=de;this.generateMipmaps=false;this.needsUpdate=true}}FramebufferTexture.prototype.isFramebufferTexture=true;class CompressedTexture extends Texture{constructor(e,t,n,r,i,s,a,o,l,c,u,h){super(null,s,a,o,l,c,r,i,u,h);this.image={width:t,height:n};this.mipmaps=e;this.flipY=false;this.generateMipmaps=false}}CompressedTexture.prototype.isCompressedTexture=true;class CanvasTexture extends Texture{constructor(e,t,n,r,i,s,a,o,l){super(e,t,n,r,i,s,a,o,l);this.needsUpdate=true}}CanvasTexture.prototype.isCanvasTexture=true;class CircleGeometry extends BufferGeometry{constructor(e=1,t=8,n=0,r=2*Math.PI){super();this.type="CircleGeometry";this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:r};t=Math.max(3,t);const i=[];const s=[];const a=[];const o=[];const l=new Vector3;const c=new Vector2;s.push(0,0,0);a.push(0,0,1);o.push(.5,.5);for(let i=0,u=3;i<=t;i++,u+=3){const h=n+i/t*r;l.x=e*Math.cos(h);l.y=e*Math.sin(h);s.push(l.x,l.y,l.z);a.push(0,0,1);c.x=(s[u]/e+1)/2;c.y=(s[u+1]/e+1)/2;o.push(c.x,c.y)}for(let e=1;e<=t;e++)i.push(e,e+1,0);this.setIndex(i);this.setAttribute("position",new Float32BufferAttribute(s,3));this.setAttribute("normal",new Float32BufferAttribute(a,3));this.setAttribute("uv",new Float32BufferAttribute(o,2))}static fromJSON(e){return new CircleGeometry(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(e=1,t=1,n=1,r=8,i=1,s=false,a=0,o=2*Math.PI){super();this.type="CylinderGeometry";this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r);i=Math.floor(i);const c=[];const u=[];const h=[];const d=[];let p=0;const f=[];const m=n/2;let g=0;generateTorso();if(false===s){e>0&&generateCap(true);t>0&&generateCap(false)}this.setIndex(c);this.setAttribute("position",new Float32BufferAttribute(u,3));this.setAttribute("normal",new Float32BufferAttribute(h,3));this.setAttribute("uv",new Float32BufferAttribute(d,2));function generateTorso(){const s=new Vector3;const y=new Vector3;let x=0;const b=(t-e)/n;for(let l=0;l<=i;l++){const c=[];const g=l/i;const x=g*(t-e)+e;for(let e=0;e<=r;e++){const t=e/r;const i=t*o+a;const l=Math.sin(i);const f=Math.cos(i);y.x=x*l;y.y=-g*n+m;y.z=x*f;u.push(y.x,y.y,y.z);s.set(l,b,f).normalize();h.push(s.x,s.y,s.z);d.push(t,1-g);c.push(p++)}f.push(c)}for(let e=0;e<r;e++)for(let t=0;t<i;t++){const n=f[t][e];const r=f[t+1][e];const i=f[t+1][e+1];const s=f[t][e+1];c.push(n,r,s);c.push(r,i,s);x+=6}l.addGroup(g,x,0);g+=x}function generateCap(n){const i=p;const s=new Vector2;const f=new Vector3;let y=0;const x=true===n?e:t;const b=true===n?1:-1;for(let e=1;e<=r;e++){u.push(0,m*b,0);h.push(0,b,0);d.push(.5,.5);p++}const _=p;for(let e=0;e<=r;e++){const t=e/r;const n=t*o+a;const i=Math.cos(n);const l=Math.sin(n);f.x=x*l;f.y=m*b;f.z=x*i;u.push(f.x,f.y,f.z);h.push(0,b,0);s.x=.5*i+.5;s.y=.5*l*b+.5;d.push(s.x,s.y);p++}for(let e=0;e<r;e++){const t=i+e;const r=_+e;true===n?c.push(r,r+1,t):c.push(r+1,r,t);y+=3}l.addGroup(g,y,true===n?1:2);g+=y}}static fromJSON(e){return new CylinderGeometry(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(e=1,t=1,n=8,r=1,i=false,s=0,a=2*Math.PI){super(0,e,t,n,r,i,s,a);this.type="ConeGeometry";this.parameters={radius:e,height:t,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(e){return new ConeGeometry(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(e=[],t=[],n=1,r=0){super();this.type="PolyhedronGeometry";this.parameters={vertices:e,indices:t,radius:n,detail:r};const i=[];const s=[];subdivide(r);applyRadius(n);generateUVs();this.setAttribute("position",new Float32BufferAttribute(i,3));this.setAttribute("normal",new Float32BufferAttribute(i.slice(),3));this.setAttribute("uv",new Float32BufferAttribute(s,2));0===r?this.computeVertexNormals():this.normalizeNormals();function subdivide(e){const n=new Vector3;const r=new Vector3;const i=new Vector3;for(let s=0;s<t.length;s+=3){getVertexByIndex(t[s+0],n);getVertexByIndex(t[s+1],r);getVertexByIndex(t[s+2],i);subdivideFace(n,r,i,e)}}function subdivideFace(e,t,n,r){const i=r+1;const s=[];for(let r=0;r<=i;r++){s[r]=[];const a=e.clone().lerp(n,r/i);const o=t.clone().lerp(n,r/i);const l=i-r;for(let e=0;e<=l;e++)s[r][e]=0===e&&r===i?a:a.clone().lerp(o,e/l)}for(let e=0;e<i;e++)for(let t=0;t<2*(i-e)-1;t++){const n=Math.floor(t/2);if(t%2===0){pushVertex(s[e][n+1]);pushVertex(s[e+1][n]);pushVertex(s[e][n])}else{pushVertex(s[e][n+1]);pushVertex(s[e+1][n+1]);pushVertex(s[e+1][n])}}}function applyRadius(e){const t=new Vector3;for(let n=0;n<i.length;n+=3){t.x=i[n+0];t.y=i[n+1];t.z=i[n+2];t.normalize().multiplyScalar(e);i[n+0]=t.x;i[n+1]=t.y;i[n+2]=t.z}}function generateUVs(){const e=new Vector3;for(let t=0;t<i.length;t+=3){e.x=i[t+0];e.y=i[t+1];e.z=i[t+2];const n=azimuth(e)/2/Math.PI+.5;const r=inclination(e)/Math.PI+.5;s.push(n,1-r)}correctUVs();correctSeam()}function correctSeam(){for(let e=0;e<s.length;e+=6){const t=s[e+0];const n=s[e+2];const r=s[e+4];const i=Math.max(t,n,r);const a=Math.min(t,n,r);if(i>.9&&a<.1){t<.2&&(s[e+0]+=1);n<.2&&(s[e+2]+=1);r<.2&&(s[e+4]+=1)}}}function pushVertex(e){i.push(e.x,e.y,e.z)}function getVertexByIndex(t,n){const r=3*t;n.x=e[r+0];n.y=e[r+1];n.z=e[r+2]}function correctUVs(){const e=new Vector3;const t=new Vector3;const n=new Vector3;const r=new Vector3;const a=new Vector2;const o=new Vector2;const l=new Vector2;for(let c=0,u=0;c<i.length;c+=9,u+=6){e.set(i[c+0],i[c+1],i[c+2]);t.set(i[c+3],i[c+4],i[c+5]);n.set(i[c+6],i[c+7],i[c+8]);a.set(s[u+0],s[u+1]);o.set(s[u+2],s[u+3]);l.set(s[u+4],s[u+5]);r.copy(e).add(t).add(n).divideScalar(3);const h=azimuth(r);correctUV(a,u+0,e,h);correctUV(o,u+2,t,h);correctUV(l,u+4,n,h)}}function correctUV(e,t,n,r){r<0&&1===e.x&&(s[t]=e.x-1);0===n.x&&0===n.z&&(s[t]=r/2/Math.PI+.5)}function azimuth(e){return Math.atan2(e.z,-e.x)}function inclination(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}}static fromJSON(e){return new PolyhedronGeometry(e.vertices,e.indices,e.radius,e.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;const r=1/n;const i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r];const s=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,s,e,t);this.type="DodecahedronGeometry";this.parameters={radius:e,detail:t}}static fromJSON(e){return new DodecahedronGeometry(e.radius,e.detail)}}const bl=new Vector3;const _l=new Vector3;const Ml=new Vector3;const wl=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(e=null,t=1){super();this.type="EdgesGeometry";this.parameters={geometry:e,thresholdAngle:t};if(null!==e){const n=4;const r=Math.pow(10,n);const i=Math.cos(Cn*t);const s=e.getIndex();const a=e.getAttribute("position");const o=s?s.count:a.count;const l=[0,0,0];const c=["a","b","c"];const u=new Array(3);const h={};const d=[];for(let e=0;e<o;e+=3){if(s){l[0]=s.getX(e);l[1]=s.getX(e+1);l[2]=s.getX(e+2)}else{l[0]=e;l[1]=e+1;l[2]=e+2}const{a:t,b:n,c:o}=wl;t.fromBufferAttribute(a,l[0]);n.fromBufferAttribute(a,l[1]);o.fromBufferAttribute(a,l[2]);wl.getNormal(Ml);u[0]=`${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`;u[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`;u[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`;if(u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let e=0;e<3;e++){const t=(e+1)%3;const n=u[e];const r=u[t];const s=wl[c[e]];const a=wl[c[t]];const o=`${n}_${r}`;const p=`${r}_${n}`;if(p in h&&h[p]){if(Ml.dot(h[p].normal)<=i){d.push(s.x,s.y,s.z);d.push(a.x,a.y,a.z)}h[p]=null}else o in h||(h[o]={index0:l[e],index1:l[t],normal:Ml.clone()})}}for(const e in h)if(h[e]){const{index0:t,index1:n}=h[e];bl.fromBufferAttribute(a,t);_l.fromBufferAttribute(a,n);d.push(bl.x,bl.y,bl.z);d.push(_l.x,_l.y,_l.z)}this.setAttribute("position",new Float32BufferAttribute(d,3))}}}class Curve{constructor(){this.type="Curve";this.arcLengthDivisions=200}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.");return null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=false;const t=[];let n,r=this.getPoint(0);let i=0;t.push(0);for(let s=1;s<=e;s++){n=this.getPoint(s/e);i+=n.distanceTo(r);t.push(i);r=n}this.cacheArcLengths=t;return t}updateArcLengths(){this.needsUpdate=true;this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let r=0;const i=n.length;let s;s=t||e*n[i-1];let a,o=0,l=i-1;while(o<=l){r=Math.floor(o+(l-o)/2);a=n[r]-s;if(a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}}r=l;if(n[r]===s)return r/(i-1);const c=n[r];const u=n[r+1];const h=u-c;const d=(s-c)/h;const p=(r+d)/(i-1);return p}getTangent(e,t){const n=1e-4;let r=e-n;let i=e+n;r<0&&(r=0);i>1&&(i=1);const s=this.getPoint(r);const a=this.getPoint(i);const o=t||(s.isVector2?new Vector2:new Vector3);o.copy(a).sub(s).normalize();return o}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new Vector3;const r=[];const i=[];const s=[];const a=new Vector3;const o=new Matrix4;for(let t=0;t<=e;t++){const n=t/e;r[t]=this.getTangentAt(n,new Vector3)}i[0]=new Vector3;s[0]=new Vector3;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x);const u=Math.abs(r[0].y);const h=Math.abs(r[0].z);if(c<=l){l=c;n.set(1,0,0)}if(u<=l){l=u;n.set(0,1,0)}h<=l&&n.set(0,0,1);a.crossVectors(r[0],n).normalize();i[0].crossVectors(r[0],a);s[0].crossVectors(r[0],i[0]);for(let t=1;t<=e;t++){i[t]=i[t-1].clone();s[t]=s[t-1].clone();a.crossVectors(r[t-1],r[t]);if(a.length()>Number.EPSILON){a.normalize();const e=Math.acos(clamp(r[t-1].dot(r[t]),-1,1));i[t].applyMatrix4(o.makeRotationAxis(a,e))}s[t].crossVectors(r[t],i[t])}if(true===t){let t=Math.acos(clamp(i[0].dot(i[e]),-1,1));t/=e;r[0].dot(a.crossVectors(i[0],i[e]))>0&&(t=-t);for(let n=1;n<=e;n++){i[n].applyMatrix4(o.makeRotationAxis(r[n],t*n));s[n].crossVectors(r[n],i[n])}}return{tangents:r,normals:i,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(e){this.arcLengthDivisions=e.arcLengthDivisions;return this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};e.arcLengthDivisions=this.arcLengthDivisions;e.type=this.type;return e}fromJSON(e){this.arcLengthDivisions=e.arcLengthDivisions;return this}}class EllipseCurve extends Curve{constructor(e=0,t=0,n=1,r=1,i=0,s=2*Math.PI,a=false,o=0){super();this.type="EllipseCurve";this.aX=e;this.aY=t;this.xRadius=n;this.yRadius=r;this.aStartAngle=i;this.aEndAngle=s;this.aClockwise=a;this.aRotation=o}getPoint(e,t){const n=t||new Vector2;const r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;while(i<0)i+=r;while(i>r)i-=r;i<Number.EPSILON&&(i=s?0:r);true!==this.aClockwise||s||(i===r?i=-r:i-=r);const a=this.aStartAngle+e*i;let o=this.aX+this.xRadius*Math.cos(a);let l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const e=Math.cos(this.aRotation);const t=Math.sin(this.aRotation);const n=o-this.aX;const r=l-this.aY;o=n*e-r*t+this.aX;l=n*t+r*e+this.aY}return n.set(o,l)}copy(e){super.copy(e);this.aX=e.aX;this.aY=e.aY;this.xRadius=e.xRadius;this.yRadius=e.yRadius;this.aStartAngle=e.aStartAngle;this.aEndAngle=e.aEndAngle;this.aClockwise=e.aClockwise;this.aRotation=e.aRotation;return this}toJSON(){const e=super.toJSON();e.aX=this.aX;e.aY=this.aY;e.xRadius=this.xRadius;e.yRadius=this.yRadius;e.aStartAngle=this.aStartAngle;e.aEndAngle=this.aEndAngle;e.aClockwise=this.aClockwise;e.aRotation=this.aRotation;return e}fromJSON(e){super.fromJSON(e);this.aX=e.aX;this.aY=e.aY;this.xRadius=e.xRadius;this.yRadius=e.yRadius;this.aStartAngle=e.aStartAngle;this.aEndAngle=e.aEndAngle;this.aClockwise=e.aClockwise;this.aRotation=e.aRotation;return this}}EllipseCurve.prototype.isEllipseCurve=true;class ArcCurve extends EllipseCurve{constructor(e,t,n,r,i,s){super(e,t,n,n,r,i,s);this.type="ArcCurve"}}ArcCurve.prototype.isArcCurve=true;function CubicPoly(){let e=0,t=0,n=0,r=0;function init(i,s,a,o){e=i;t=a;n=-3*i+3*s-2*a-o;r=2*i-2*s+a+o}return{initCatmullRom:function(e,t,n,r,i){init(t,n,i*(n-e),i*(r-t))},initNonuniformCatmullRom:function(e,t,n,r,i,s,a){let o=(t-e)/i-(n-e)/(i+s)+(n-t)/s;let l=(n-t)/s-(r-t)/(s+a)+(r-n)/a;o*=s;l*=s;init(t,n,o,l)},calc:function(i){const s=i*i;const a=s*i;return e+t*i+n*s+r*a}}}const Sl=new Vector3;const Tl=new CubicPoly,El=new CubicPoly,Al=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(e=[],t=false,n="centripetal",r=.5){super();this.type="CatmullRomCurve3";this.points=e;this.closed=t;this.curveType=n;this.tension=r}getPoint(e,t=new Vector3){const n=t;const r=this.points;const i=r.length;const s=(i-(this.closed?0:1))*e;let a=Math.floor(s);let o=s-a;if(this.closed)a+=a>0?0:(Math.floor(Math.abs(a)/i)+1)*i;else if(0===o&&a===i-1){a=i-2;o=1}let l,c;if(this.closed||a>0)l=r[(a-1)%i];else{Sl.subVectors(r[0],r[1]).add(r[0]);l=Sl}const u=r[a%i];const h=r[(a+1)%i];if(this.closed||a+2<i)c=r[(a+2)%i];else{Sl.subVectors(r[i-1],r[i-2]).add(r[i-1]);c=Sl}if("centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(l.distanceToSquared(u),e);let n=Math.pow(u.distanceToSquared(h),e);let r=Math.pow(h.distanceToSquared(c),e);n<1e-4&&(n=1);t<1e-4&&(t=n);r<1e-4&&(r=n);Tl.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,t,n,r);El.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,t,n,r);Al.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,t,n,r)}else if("catmullrom"===this.curveType){Tl.initCatmullRom(l.x,u.x,h.x,c.x,this.tension);El.initCatmullRom(l.y,u.y,h.y,c.y,this.tension);Al.initCatmullRom(l.z,u.z,h.z,c.z,this.tension)}n.set(Tl.calc(o),El.calc(o),Al.calc(o));return n}copy(e){super.copy(e);this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}this.closed=e.closed;this.curveType=e.curveType;this.tension=e.tension;return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}e.closed=this.closed;e.curveType=this.curveType;e.tension=this.tension;return e}fromJSON(e){super.fromJSON(e);this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector3).fromArray(n))}this.closed=e.closed;this.curveType=e.curveType;this.tension=e.tension;return this}}CatmullRomCurve3.prototype.isCatmullRomCurve3=true;function CatmullRom(e,t,n,r,i){const s=.5*(r-t);const a=.5*(i-n);const o=e*e;const l=e*o;return(2*n-2*r+s+a)*l+(-3*n+3*r-2*s-a)*o+s*e+n}function QuadraticBezierP0(e,t){const n=1-e;return n*n*t}function QuadraticBezierP1(e,t){return 2*(1-e)*e*t}function QuadraticBezierP2(e,t){return e*e*t}function QuadraticBezier(e,t,n,r){return QuadraticBezierP0(e,t)+QuadraticBezierP1(e,n)+QuadraticBezierP2(e,r)}function CubicBezierP0(e,t){const n=1-e;return n*n*n*t}function CubicBezierP1(e,t){const n=1-e;return 3*n*n*e*t}function CubicBezierP2(e,t){return 3*(1-e)*e*e*t}function CubicBezierP3(e,t){return e*e*e*t}function CubicBezier(e,t,n,r,i){return CubicBezierP0(e,t)+CubicBezierP1(e,n)+CubicBezierP2(e,r)+CubicBezierP3(e,i)}class CubicBezierCurve extends Curve{constructor(e=new Vector2,t=new Vector2,n=new Vector2,r=new Vector2){super();this.type="CubicBezierCurve";this.v0=e;this.v1=t;this.v2=n;this.v3=r}getPoint(e,t=new Vector2){const n=t;const r=this.v0,i=this.v1,s=this.v2,a=this.v3;n.set(CubicBezier(e,r.x,i.x,s.x,a.x),CubicBezier(e,r.y,i.y,s.y,a.y));return n}copy(e){super.copy(e);this.v0.copy(e.v0);this.v1.copy(e.v1);this.v2.copy(e.v2);this.v3.copy(e.v3);return this}toJSON(){const e=super.toJSON();e.v0=this.v0.toArray();e.v1=this.v1.toArray();e.v2=this.v2.toArray();e.v3=this.v3.toArray();return e}fromJSON(e){super.fromJSON(e);this.v0.fromArray(e.v0);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);this.v3.fromArray(e.v3);return this}}CubicBezierCurve.prototype.isCubicBezierCurve=true;class CubicBezierCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3,n=new Vector3,r=new Vector3){super();this.type="CubicBezierCurve3";this.v0=e;this.v1=t;this.v2=n;this.v3=r}getPoint(e,t=new Vector3){const n=t;const r=this.v0,i=this.v1,s=this.v2,a=this.v3;n.set(CubicBezier(e,r.x,i.x,s.x,a.x),CubicBezier(e,r.y,i.y,s.y,a.y),CubicBezier(e,r.z,i.z,s.z,a.z));return n}copy(e){super.copy(e);this.v0.copy(e.v0);this.v1.copy(e.v1);this.v2.copy(e.v2);this.v3.copy(e.v3);return this}toJSON(){const e=super.toJSON();e.v0=this.v0.toArray();e.v1=this.v1.toArray();e.v2=this.v2.toArray();e.v3=this.v3.toArray();return e}fromJSON(e){super.fromJSON(e);this.v0.fromArray(e.v0);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);this.v3.fromArray(e.v3);return this}}CubicBezierCurve3.prototype.isCubicBezierCurve3=true;class LineCurve extends Curve{constructor(e=new Vector2,t=new Vector2){super();this.type="LineCurve";this.v1=e;this.v2=t}getPoint(e,t=new Vector2){const n=t;if(1===e)n.copy(this.v2);else{n.copy(this.v2).sub(this.v1);n.multiplyScalar(e).add(this.v1)}return n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new Vector2;n.copy(this.v2).sub(this.v1).normalize();return n}copy(e){super.copy(e);this.v1.copy(e.v1);this.v2.copy(e.v2);return this}toJSON(){const e=super.toJSON();e.v1=this.v1.toArray();e.v2=this.v2.toArray();return e}fromJSON(e){super.fromJSON(e);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);return this}}LineCurve.prototype.isLineCurve=true;class LineCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3){super();this.type="LineCurve3";this.isLineCurve3=true;this.v1=e;this.v2=t}getPoint(e,t=new Vector3){const n=t;if(1===e)n.copy(this.v2);else{n.copy(this.v2).sub(this.v1);n.multiplyScalar(e).add(this.v1)}return n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){super.copy(e);this.v1.copy(e.v1);this.v2.copy(e.v2);return this}toJSON(){const e=super.toJSON();e.v1=this.v1.toArray();e.v2=this.v2.toArray();return e}fromJSON(e){super.fromJSON(e);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);return this}}class QuadraticBezierCurve extends Curve{constructor(e=new Vector2,t=new Vector2,n=new Vector2){super();this.type="QuadraticBezierCurve";this.v0=e;this.v1=t;this.v2=n}getPoint(e,t=new Vector2){const n=t;const r=this.v0,i=this.v1,s=this.v2;n.set(QuadraticBezier(e,r.x,i.x,s.x),QuadraticBezier(e,r.y,i.y,s.y));return n}copy(e){super.copy(e);this.v0.copy(e.v0);this.v1.copy(e.v1);this.v2.copy(e.v2);return this}toJSON(){const e=super.toJSON();e.v0=this.v0.toArray();e.v1=this.v1.toArray();e.v2=this.v2.toArray();return e}fromJSON(e){super.fromJSON(e);this.v0.fromArray(e.v0);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);return this}}QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;class QuadraticBezierCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3,n=new Vector3){super();this.type="QuadraticBezierCurve3";this.v0=e;this.v1=t;this.v2=n}getPoint(e,t=new Vector3){const n=t;const r=this.v0,i=this.v1,s=this.v2;n.set(QuadraticBezier(e,r.x,i.x,s.x),QuadraticBezier(e,r.y,i.y,s.y),QuadraticBezier(e,r.z,i.z,s.z));return n}copy(e){super.copy(e);this.v0.copy(e.v0);this.v1.copy(e.v1);this.v2.copy(e.v2);return this}toJSON(){const e=super.toJSON();e.v0=this.v0.toArray();e.v1=this.v1.toArray();e.v2=this.v2.toArray();return e}fromJSON(e){super.fromJSON(e);this.v0.fromArray(e.v0);this.v1.fromArray(e.v1);this.v2.fromArray(e.v2);return this}}QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;class SplineCurve extends Curve{constructor(e=[]){super();this.type="SplineCurve";this.points=e}getPoint(e,t=new Vector2){const n=t;const r=this.points;const i=(r.length-1)*e;const s=Math.floor(i);const a=i-s;const o=r[0===s?s:s-1];const l=r[s];const c=r[s>r.length-2?r.length-1:s+1];const u=r[s>r.length-3?r.length-1:s+2];n.set(CatmullRom(a,o.x,l.x,c.x,u.x),CatmullRom(a,o.y,l.y,c.y,u.y));return n}copy(e){super.copy(e);this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e}fromJSON(e){super.fromJSON(e);this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector2).fromArray(n))}return this}}SplineCurve.prototype.isSplineCurve=true;var Ll=Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});class CurvePath extends Curve{constructor(){super();this.type="CurvePath";this.curves=[];this.autoClose=false}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0);const t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new LineCurve(t,e))}getPoint(e,t){const n=e*this.getLength();const r=this.getCurveLengths();let i=0;while(i<r.length){if(r[i]>=n){const e=r[i]-n;const s=this.curves[i];const a=s.getLength();const o=0===a?0:1-e/a;return s.getPointAt(o,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++){t+=this.curves[n].getLength();e.push(t)}this.cacheLengths=e;return e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));this.autoClose&&t.push(t[0]);return t}getPoints(e=12){const t=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r];const a=s&&s.isEllipseCurve?2*e:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?e*s.points.length:e;const o=s.getPoints(a);for(let e=0;e<o.length;e++){const r=o[e];if(!n||!n.equals(r)){t.push(r);n=r}}}this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]);return t}copy(e){super.copy(e);this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}this.autoClose=e.autoClose;return this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose;e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e);this.autoClose=e.autoClose;this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new Ll[n.type]).fromJSON(n))}return this}}class Path extends CurvePath{constructor(e){super();this.type="Path";this.currentPoint=new Vector2;e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){this.currentPoint.set(e,t);return this}lineTo(e,t){const n=new LineCurve(this.currentPoint.clone(),new Vector2(e,t));this.curves.push(n);this.currentPoint.set(e,t);return this}quadraticCurveTo(e,t,n,r){const i=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,r));this.curves.push(i);this.currentPoint.set(n,r);return this}bezierCurveTo(e,t,n,r,i,s){const a=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,r),new Vector2(i,s));this.curves.push(a);this.currentPoint.set(i,s);return this}splineThru(e){const t=[this.currentPoint.clone()].concat(e);const n=new SplineCurve(t);this.curves.push(n);this.currentPoint.copy(e[e.length-1]);return this}arc(e,t,n,r,i,s){const a=this.currentPoint.x;const o=this.currentPoint.y;this.absarc(e+a,t+o,n,r,i,s);return this}absarc(e,t,n,r,i,s){this.absellipse(e,t,n,n,r,i,s);return this}ellipse(e,t,n,r,i,s,a,o){const l=this.currentPoint.x;const c=this.currentPoint.y;this.absellipse(e+l,t+c,n,r,i,s,a,o);return this}absellipse(e,t,n,r,i,s,a,o){const l=new EllipseCurve(e,t,n,r,i,s,a,o);if(this.curves.length>0){const e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);const c=l.getPoint(1);this.currentPoint.copy(c);return this}copy(e){super.copy(e);this.currentPoint.copy(e.currentPoint);return this}toJSON(){const e=super.toJSON();e.currentPoint=this.currentPoint.toArray();return e}fromJSON(e){super.fromJSON(e);this.currentPoint.fromArray(e.currentPoint);return this}}class Shape extends Path{constructor(e){super(e);this.uuid=generateUUID();this.type="Shape";this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e);this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid;e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e);this.uuid=e.uuid;this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new Path).fromJSON(n))}return this}}const Cl={triangulate:function(e,t,n=2){const r=t&&t.length;const i=r?t[0]*n:e.length;let s=linkedList(e,0,i,n,true);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,u,h,d,p;r&&(s=eliminateHoles(e,t,s,n));if(e.length>80*n){o=c=e[0];l=u=e[1];for(let t=n;t<i;t+=n){h=e[t];d=e[t+1];h<o&&(o=h);d<l&&(l=d);h>c&&(c=h);d>u&&(u=d)}p=Math.max(c-o,u-l);p=0!==p?1/p:0}earcutLinked(s,a,n,o,l,p);return a}};function linkedList(e,t,n,r,i){let s,a;if(i===signedArea(e,t,n,r)>0)for(s=t;s<n;s+=r)a=insertNode(s,e[s],e[s+1],a);else for(s=n-r;s>=t;s-=r)a=insertNode(s,e[s],e[s+1],a);if(a&&equals(a,a.next)){removeNode(a);a=a.next}return a}function filterPoints(e,t){if(!e)return e;t||(t=e);let n,r=e;do{n=false;if(r.steiner||!equals(r,r.next)&&0!==area(r.prev,r,r.next))r=r.next;else{removeNode(r);r=t=r.prev;if(r===r.next)break;n=true}}while(n||r!==t);return t}function earcutLinked(e,t,n,r,i,s,a){if(!e)return;!a&&s&&indexCurve(e,r,i,s);let o,l,c=e;while(e.prev!==e.next){o=e.prev;l=e.next;if(s?isEarHashed(e,r,i,s):isEar(e)){t.push(o.i/n);t.push(e.i/n);t.push(l.i/n);removeNode(e);e=l.next;c=l.next}else{e=l;if(e===c){if(a)if(1===a){e=cureLocalIntersections(filterPoints(e),t,n);earcutLinked(e,t,n,r,i,s,2)}else 2===a&&splitEarcut(e,t,n,r,i,s);else earcutLinked(filterPoints(e),t,n,r,i,s,1);break}}}}function isEar(e){const t=e.prev,n=e,r=e.next;if(area(t,n,r)>=0)return false;let i=e.next.next;while(i!==e.prev){if(pointInTriangle(t.x,t.y,n.x,n.y,r.x,r.y,i.x,i.y)&&area(i.prev,i,i.next)>=0)return false;i=i.next}return true}function isEarHashed(e,t,n,r){const i=e.prev,s=e,a=e.next;if(area(i,s,a)>=0)return false;const o=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,l=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,c=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,u=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y;const h=zOrder(o,l,t,n,r),d=zOrder(c,u,t,n,r);let p=e.prevZ,f=e.nextZ;while(p&&p.z>=h&&f&&f.z<=d){if(p!==e.prev&&p!==e.next&&pointInTriangle(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(f!==e.prev&&f!==e.next&&pointInTriangle(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&area(f.prev,f,f.next)>=0)return false;f=f.nextZ}while(p&&p.z>=h){if(p!==e.prev&&p!==e.next&&pointInTriangle(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ}while(f&&f.z<=d){if(f!==e.prev&&f!==e.next&&pointInTriangle(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&area(f.prev,f,f.next)>=0)return false;f=f.nextZ}return true}function cureLocalIntersections(e,t,n){let r=e;do{const i=r.prev,s=r.next.next;if(!equals(i,s)&&intersects(i,r,r.next,s)&&locallyInside(i,s)&&locallyInside(s,i)){t.push(i.i/n);t.push(r.i/n);t.push(s.i/n);removeNode(r);removeNode(r.next);r=e=s}r=r.next}while(r!==e);return filterPoints(r)}function splitEarcut(e,t,n,r,i,s){let a=e;do{let e=a.next.next;while(e!==a.prev){if(a.i!==e.i&&isValidDiagonal(a,e)){let o=splitPolygon(a,e);a=filterPoints(a,a.next);o=filterPoints(o,o.next);earcutLinked(a,t,n,r,i,s);earcutLinked(o,t,n,r,i,s);return}e=e.next}a=a.next}while(a!==e)}function eliminateHoles(e,t,n,r){const i=[];let s,a,o,l,c;for(s=0,a=t.length;s<a;s++){o=t[s]*r;l=s<a-1?t[s+1]*r:e.length;c=linkedList(e,o,l,r,false);c===c.next&&(c.steiner=true);i.push(getLeftmost(c))}i.sort(compareX);for(s=0;s<i.length;s++){eliminateHole(i[s],n);n=filterPoints(n,n.next)}return n}function compareX(e,t){return e.x-t.x}function eliminateHole(e,t){t=findHoleBridge(e,t);if(t){const n=splitPolygon(t,e);filterPoints(t,t.next);filterPoints(n,n.next)}}function findHoleBridge(e,t){let n=t;const r=e.x;const i=e.y;let s,a=-Infinity;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const e=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=r&&e>a){a=e;if(e===r){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!s)return null;if(r===a)return s;const o=s,l=s.x,c=s.y;let u,h=Infinity;n=s;do{if(r>=n.x&&n.x>=l&&r!==n.x&&pointInTriangle(i<c?r:a,i,l,c,i<c?a:r,i,n.x,n.y)){u=Math.abs(i-n.y)/(r-n.x);if(locallyInside(n,e)&&(u<h||u===h&&(n.x>s.x||n.x===s.x&&sectorContainsSector(s,n)))){s=n;h=u}}n=n.next}while(n!==o);return s}function sectorContainsSector(e,t){return area(e.prev,e,t.prev)<0&&area(t.next,e,e.next)<0}function indexCurve(e,t,n,r){let i=e;do{null===i.z&&(i.z=zOrder(i.x,i.y,t,n,r));i.prevZ=i.prev;i.nextZ=i.next;i=i.next}while(i!==e);i.prevZ.nextZ=null;i.prevZ=null;sortLinked(i)}function sortLinked(e){let t,n,r,i,s,a,o,l,c=1;do{n=e;e=null;s=null;a=0;while(n){a++;r=n;o=0;for(t=0;t<c;t++){o++;r=r.nextZ;if(!r)break}l=c;while(o>0||l>0&&r){if(0!==o&&(0===l||!r||n.z<=r.z)){i=n;n=n.nextZ;o--}else{i=r;r=r.nextZ;l--}s?s.nextZ=i:e=i;i.prevZ=s;s=i}n=r}s.nextZ=null;c*=2}while(a>1);return e}function zOrder(e,t,n,r,i){e=32767*(e-n)*i;t=32767*(t-r)*i;e=16711935&(e|e<<8);e=252645135&(e|e<<4);e=858993459&(e|e<<2);e=1431655765&(e|e<<1);t=16711935&(t|t<<8);t=252645135&(t|t<<4);t=858993459&(t|t<<2);t=1431655765&(t|t<<1);return e|t<<1}function getLeftmost(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t);t=t.next}while(t!==e);return n}function pointInTriangle(e,t,n,r,i,s,a,o){return(i-a)*(t-o)-(e-a)*(s-o)>=0&&(e-a)*(r-o)-(n-a)*(t-o)>=0&&(n-a)*(s-o)-(i-a)*(r-o)>=0}function isValidDiagonal(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!intersectsPolygon(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&middleInside(e,t)&&(area(e.prev,e,t.prev)||area(e,t.prev,t))||equals(e,t)&&area(e.prev,e,e.next)>0&&area(t.prev,t,t.next)>0)}function area(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function equals(e,t){return e.x===t.x&&e.y===t.y}function intersects(e,t,n,r){const i=sign(area(e,t,n));const s=sign(area(e,t,r));const a=sign(area(n,r,e));const o=sign(area(n,r,t));return i!==s&&a!==o||(!(0!==i||!onSegment(e,n,t))||(!(0!==s||!onSegment(e,r,t))||(!(0!==a||!onSegment(n,e,r))||!(0!==o||!onSegment(n,t,r)))))}function onSegment(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function sign(e){return e>0?1:e<0?-1:0}function intersectsPolygon(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&intersects(n,n.next,e,t))return true;n=n.next}while(n!==e);return false}function locallyInside(e,t){return area(e.prev,e,e.next)<0?area(e,t,e.next)>=0&&area(e,e.prev,t)>=0:area(e,t,e.prev)<0||area(e,e.next,t)<0}function middleInside(e,t){let n=e,r=false;const i=(e.x+t.x)/2,s=(e.y+t.y)/2;do{n.y>s!==n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r);n=n.next}while(n!==e);return r}function splitPolygon(e,t){const n=new Node(e.i,e.x,e.y),r=new Node(t.i,t.x,t.y),i=e.next,s=t.prev;e.next=t;t.prev=e;n.next=i;i.prev=n;r.next=n;n.prev=r;s.next=r;r.prev=s;return r}function insertNode(e,t,n,r){const i=new Node(e,t,n);if(r){i.next=r.next;i.prev=r;r.next.prev=i;r.next=i}else{i.prev=i;i.next=i}return i}function removeNode(e){e.next.prev=e.prev;e.prev.next=e.next;e.prevZ&&(e.prevZ.nextZ=e.nextZ);e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,t,n){this.i=e;this.x=t;this.y=n;this.prev=null;this.next=null;this.z=null;this.prevZ=null;this.nextZ=null;this.steiner=false}function signedArea(e,t,n,r){let i=0;for(let s=t,a=n-r;s<n;s+=r){i+=(e[a]-e[s])*(e[s+1]+e[a+1]);a=s}return i}class ShapeUtils{static area(e){const t=e.length;let n=0;for(let r=t-1,i=0;i<t;r=i++)n+=e[r].x*e[i].y-e[i].x*e[r].y;return.5*n}static isClockWise(e){return ShapeUtils.area(e)<0}static triangulateShape(e,t){const n=[];const r=[];const i=[];removeDupEndPts(e);addContour(n,e);let s=e.length;t.forEach(removeDupEndPts);for(let e=0;e<t.length;e++){r.push(s);s+=t[e].length;addContour(n,t[e])}const a=Cl.triangulate(n,r);for(let e=0;e<a.length;e+=3)i.push(a.slice(e,e+3));return i}}function removeDupEndPts(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function addContour(e,t){for(let n=0;n<t.length;n++){e.push(t[n].x);e.push(t[n].y)}}class ExtrudeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),t={}){super();this.type="ExtrudeGeometry";this.parameters={shapes:e,options:t};e=Array.isArray(e)?e:[e];const n=this;const r=[];const i=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];addShape(n)}this.setAttribute("position",new Float32BufferAttribute(r,3));this.setAttribute("uv",new Float32BufferAttribute(i,2));this.computeVertexNormals();function addShape(e){const s=[];const a=void 0!==t.curveSegments?t.curveSegments:12;const o=void 0!==t.steps?t.steps:1;let l=void 0!==t.depth?t.depth:1;let c=void 0===t.bevelEnabled||t.bevelEnabled;let u=void 0!==t.bevelThickness?t.bevelThickness:.2;let h=void 0!==t.bevelSize?t.bevelSize:u-.1;let d=void 0!==t.bevelOffset?t.bevelOffset:0;let p=void 0!==t.bevelSegments?t.bevelSegments:3;const f=t.extrudePath;const m=void 0!==t.UVGenerator?t.UVGenerator:Rl;if(void 0!==t.amount){console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");l=t.amount}let g,y=false;let x,b,_,M;if(f){g=f.getSpacedPoints(o);y=true;c=false;x=f.computeFrenetFrames(o,false);b=new Vector3;_=new Vector3;M=new Vector3}if(!c){p=0;u=0;h=0;d=0}const w=e.extractPoints(a);let S=w.shape;const T=w.holes;const E=!ShapeUtils.isClockWise(S);if(E){S=S.reverse();for(let e=0,t=T.length;e<t;e++){const t=T[e];ShapeUtils.isClockWise(t)&&(T[e]=t.reverse())}}const A=ShapeUtils.triangulateShape(S,T);const L=S;for(let e=0,t=T.length;e<t;e++){const t=T[e];S=S.concat(t)}function scalePt2(e,t,n){t||console.error("THREE.ExtrudeGeometry: vec does not exist");return t.clone().multiplyScalar(n).add(e)}const C=S.length,R=A.length;function getBevelVec(e,t,n){let r,i,s;const a=e.x-t.x,o=e.y-t.y;const l=n.x-e.x,c=n.y-e.y;const u=a*a+o*o;const h=a*c-o*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(u);const d=Math.sqrt(l*l+c*c);const p=t.x-o/h;const f=t.y+a/h;const m=n.x-c/d;const g=n.y+l/d;const y=((m-p)*c-(g-f)*l)/(a*c-o*l);r=p+a*y-e.x;i=f+o*y-e.y;const x=r*r+i*i;if(x<=2)return new Vector2(r,i);s=Math.sqrt(x/2)}else{let e=false;a>Number.EPSILON?l>Number.EPSILON&&(e=true):a<-Number.EPSILON?l<-Number.EPSILON&&(e=true):Math.sign(o)===Math.sign(c)&&(e=true);if(e){r=-o;i=a;s=Math.sqrt(u)}else{r=a;i=o;s=Math.sqrt(u/2)}}return new Vector2(r/s,i/s)}const P=[];for(let e=0,t=L.length,n=t-1,r=e+1;e<t;e++,n++,r++){n===t&&(n=0);r===t&&(r=0);P[e]=getBevelVec(L[e],L[n],L[r])}const I=[];let D,B=P.concat();for(let e=0,t=T.length;e<t;e++){const t=T[e];D=[];for(let e=0,n=t.length,r=n-1,i=e+1;e<n;e++,r++,i++){r===n&&(r=0);i===n&&(i=0);D[e]=getBevelVec(t[e],t[r],t[i])}I.push(D);B=B.concat(D)}for(let e=0;e<p;e++){const t=e/p;const n=u*Math.cos(t*Math.PI/2);const r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,t=L.length;e<t;e++){const t=scalePt2(L[e],P[e],r);v(t.x,t.y,-n)}for(let e=0,t=T.length;e<t;e++){const t=T[e];D=I[e];for(let e=0,i=t.length;e<i;e++){const i=scalePt2(t[e],D[e],r);v(i.x,i.y,-n)}}}const V=h+d;for(let e=0;e<C;e++){const t=c?scalePt2(S[e],B[e],V):S[e];if(y){_.copy(x.normals[0]).multiplyScalar(t.x);b.copy(x.binormals[0]).multiplyScalar(t.y);M.copy(g[0]).add(_).add(b);v(M.x,M.y,M.z)}else v(t.x,t.y,0)}for(let e=1;e<=o;e++)for(let t=0;t<C;t++){const n=c?scalePt2(S[t],B[t],V):S[t];if(y){_.copy(x.normals[e]).multiplyScalar(n.x);b.copy(x.binormals[e]).multiplyScalar(n.y);M.copy(g[e]).add(_).add(b);v(M.x,M.y,M.z)}else v(n.x,n.y,l/o*e)}for(let e=p-1;e>=0;e--){const t=e/p;const n=u*Math.cos(t*Math.PI/2);const r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,t=L.length;e<t;e++){const t=scalePt2(L[e],P[e],r);v(t.x,t.y,l+n)}for(let e=0,t=T.length;e<t;e++){const t=T[e];D=I[e];for(let e=0,i=t.length;e<i;e++){const i=scalePt2(t[e],D[e],r);y?v(i.x,i.y+g[o-1].y,g[o-1].x+n):v(i.x,i.y,l+n)}}}buildLidFaces();buildSideFaces();function buildLidFaces(){const e=r.length/3;if(c){let e=0;let t=C*e;for(let e=0;e<R;e++){const n=A[e];f3(n[2]+t,n[1]+t,n[0]+t)}e=o+2*p;t=C*e;for(let e=0;e<R;e++){const n=A[e];f3(n[0]+t,n[1]+t,n[2]+t)}}else{for(let e=0;e<R;e++){const t=A[e];f3(t[2],t[1],t[0])}for(let e=0;e<R;e++){const t=A[e];f3(t[0]+C*o,t[1]+C*o,t[2]+C*o)}}n.addGroup(e,r.length/3-e,0)}function buildSideFaces(){const e=r.length/3;let t=0;sidewalls(L,t);t+=L.length;for(let e=0,n=T.length;e<n;e++){const n=T[e];sidewalls(n,t);t+=n.length}n.addGroup(e,r.length/3-e,1)}function sidewalls(e,t){let n=e.length;while(--n>=0){const r=n;let i=n-1;i<0&&(i=e.length-1);for(let e=0,n=o+2*p;e<n;e++){const n=C*e;const s=C*(e+1);const a=t+r+n,o=t+i+n,l=t+i+s,c=t+r+s;f4(a,o,l,c)}}}function v(e,t,n){s.push(e);s.push(t);s.push(n)}function f3(e,t,i){addVertex(e);addVertex(t);addVertex(i);const s=r.length/3;const a=m.generateTopUV(n,r,s-3,s-2,s-1);addUV(a[0]);addUV(a[1]);addUV(a[2])}function f4(e,t,i,s){addVertex(e);addVertex(t);addVertex(s);addVertex(t);addVertex(i);addVertex(s);const a=r.length/3;const o=m.generateSideWallUV(n,r,a-6,a-3,a-2,a-1);addUV(o[0]);addUV(o[1]);addUV(o[3]);addUV(o[1]);addUV(o[2]);addUV(o[3])}function addVertex(e){r.push(s[3*e+0]);r.push(s[3*e+1]);r.push(s[3*e+2])}function addUV(e){i.push(e.x);i.push(e.y)}}}toJSON(){const e=super.toJSON();const t=this.parameters.shapes;const n=this.parameters.options;return toJSON$1(t,n,e)}static fromJSON(e,t){const n=[];for(let r=0,i=e.shapes.length;r<i;r++){const i=t[e.shapes[r]];n.push(i)}const r=e.options.extrudePath;void 0!==r&&(e.options.extrudePath=(new Ll[r.type]).fromJSON(r));return new ExtrudeGeometry(n,e.options)}}const Rl={generateTopUV:function(e,t,n,r,i){const s=t[3*n];const a=t[3*n+1];const o=t[3*r];const l=t[3*r+1];const c=t[3*i];const u=t[3*i+1];return[new Vector2(s,a),new Vector2(o,l),new Vector2(c,u)]},generateSideWallUV:function(e,t,n,r,i,s){const a=t[3*n];const o=t[3*n+1];const l=t[3*n+2];const c=t[3*r];const u=t[3*r+1];const h=t[3*r+2];const d=t[3*i];const p=t[3*i+1];const f=t[3*i+2];const m=t[3*s];const g=t[3*s+1];const y=t[3*s+2];return Math.abs(o-u)<Math.abs(a-c)?[new Vector2(a,1-l),new Vector2(c,1-h),new Vector2(d,1-f),new Vector2(m,1-y)]:[new Vector2(o,1-l),new Vector2(u,1-h),new Vector2(p,1-f),new Vector2(g,1-y)]}};function toJSON$1(e,t,n){n.shapes=[];if(Array.isArray(e))for(let t=0,r=e.length;t<r;t++){const r=e[t];n.shapes.push(r.uuid)}else n.shapes.push(e.uuid);void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON());return n}class IcosahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;const r=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1];const i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(r,i,e,t);this.type="IcosahedronGeometry";this.parameters={radius:e,detail:t}}static fromJSON(e){return new IcosahedronGeometry(e.radius,e.detail)}}class LatheGeometry extends BufferGeometry{constructor(e=[new Vector2(0,.5),new Vector2(.5,0),new Vector2(0,-.5)],t=12,n=0,r=2*Math.PI){super();this.type="LatheGeometry";this.parameters={points:e,segments:t,phiStart:n,phiLength:r};t=Math.floor(t);r=clamp(r,0,2*Math.PI);const i=[];const s=[];const a=[];const o=[];const l=[];const c=1/t;const u=new Vector3;const h=new Vector2;const d=new Vector3;const p=new Vector3;const f=new Vector3;let m=0;let g=0;for(let t=0;t<=e.length-1;t++)switch(t){case 0:m=e[t+1].x-e[t].x;g=e[t+1].y-e[t].y;d.x=1*g;d.y=-m;d.z=0*g;f.copy(d);d.normalize();o.push(d.x,d.y,d.z);break;case e.length-1:o.push(f.x,f.y,f.z);break;default:m=e[t+1].x-e[t].x;g=e[t+1].y-e[t].y;d.x=1*g;d.y=-m;d.z=0*g;p.copy(d);d.x+=f.x;d.y+=f.y;d.z+=f.z;d.normalize();o.push(d.x,d.y,d.z);f.copy(p)}for(let i=0;i<=t;i++){const d=n+i*c*r;const p=Math.sin(d);const f=Math.cos(d);for(let n=0;n<=e.length-1;n++){u.x=e[n].x*p;u.y=e[n].y;u.z=e[n].x*f;s.push(u.x,u.y,u.z);h.x=i/t;h.y=n/(e.length-1);a.push(h.x,h.y);const r=o[3*n+0]*p;const c=o[3*n+1];const d=o[3*n+0]*f;l.push(r,c,d)}}for(let n=0;n<t;n++)for(let t=0;t<e.length-1;t++){const r=t+n*e.length;const s=r;const a=r+e.length;const o=r+e.length+1;const l=r+1;i.push(s,a,l);i.push(a,o,l)}this.setIndex(i);this.setAttribute("position",new Float32BufferAttribute(s,3));this.setAttribute("uv",new Float32BufferAttribute(a,2));this.setAttribute("normal",new Float32BufferAttribute(l,3))}static fromJSON(e){return new LatheGeometry(e.points,e.segments,e.phiStart,e.phiLength)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];const r=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,r,e,t);this.type="OctahedronGeometry";this.parameters={radius:e,detail:t}}static fromJSON(e){return new OctahedronGeometry(e.radius,e.detail)}}class RingGeometry extends BufferGeometry{constructor(e=.5,t=1,n=8,r=1,i=0,s=2*Math.PI){super();this.type="RingGeometry";this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:s};n=Math.max(3,n);r=Math.max(1,r);const a=[];const o=[];const l=[];const c=[];let u=e;const h=(t-e)/r;const d=new Vector3;const p=new Vector2;for(let e=0;e<=r;e++){for(let e=0;e<=n;e++){const r=i+e/n*s;d.x=u*Math.cos(r);d.y=u*Math.sin(r);o.push(d.x,d.y,d.z);l.push(0,0,1);p.x=(d.x/t+1)/2;p.y=(d.y/t+1)/2;c.push(p.x,p.y)}u+=h}for(let e=0;e<r;e++){const t=e*(n+1);for(let e=0;e<n;e++){const r=e+t;const i=r;const s=r+n+1;const o=r+n+2;const l=r+1;a.push(i,s,l);a.push(s,o,l)}}this.setIndex(a);this.setAttribute("position",new Float32BufferAttribute(o,3));this.setAttribute("normal",new Float32BufferAttribute(l,3));this.setAttribute("uv",new Float32BufferAttribute(c,2))}static fromJSON(e){return new RingGeometry(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),t=12){super();this.type="ShapeGeometry";this.parameters={shapes:e,curveSegments:t};const n=[];const r=[];const i=[];const s=[];let a=0;let o=0;if(false===Array.isArray(e))addShape(e);else for(let t=0;t<e.length;t++){addShape(e[t]);this.addGroup(a,o,t);a+=o;o=0}this.setIndex(n);this.setAttribute("position",new Float32BufferAttribute(r,3));this.setAttribute("normal",new Float32BufferAttribute(i,3));this.setAttribute("uv",new Float32BufferAttribute(s,2));function addShape(e){const a=r.length/3;const l=e.extractPoints(t);let c=l.shape;const u=l.holes;false===ShapeUtils.isClockWise(c)&&(c=c.reverse());for(let e=0,t=u.length;e<t;e++){const t=u[e];true===ShapeUtils.isClockWise(t)&&(u[e]=t.reverse())}const h=ShapeUtils.triangulateShape(c,u);for(let e=0,t=u.length;e<t;e++){const t=u[e];c=c.concat(t)}for(let e=0,t=c.length;e<t;e++){const t=c[e];r.push(t.x,t.y,0);i.push(0,0,1);s.push(t.x,t.y)}for(let e=0,t=h.length;e<t;e++){const t=h[e];const r=t[0]+a;const i=t[1]+a;const s=t[2]+a;n.push(r,i,s);o+=3}}}toJSON(){const e=super.toJSON();const t=this.parameters.shapes;return toJSON(t,e)}static fromJSON(e,t){const n=[];for(let r=0,i=e.shapes.length;r<i;r++){const i=t[e.shapes[r]];n.push(i)}return new ShapeGeometry(n,e.curveSegments)}}function toJSON(e,t){t.shapes=[];if(Array.isArray(e))for(let n=0,r=e.length;n<r;n++){const r=e[n];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}class SphereGeometry extends BufferGeometry{constructor(e=1,t=32,n=16,r=0,i=2*Math.PI,s=0,a=Math.PI){super();this.type="SphereGeometry";this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:i,thetaStart:s,thetaLength:a};t=Math.max(3,Math.floor(t));n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const c=[];const u=new Vector3;const h=new Vector3;const d=[];const p=[];const f=[];const m=[];for(let d=0;d<=n;d++){const g=[];const y=d/n;let x=0;0==d&&0==s?x=.5/t:d==n&&o==Math.PI&&(x=-.5/t);for(let n=0;n<=t;n++){const o=n/t;u.x=-e*Math.cos(r+o*i)*Math.sin(s+y*a);u.y=e*Math.cos(s+y*a);u.z=e*Math.sin(r+o*i)*Math.sin(s+y*a);p.push(u.x,u.y,u.z);h.copy(u).normalize();f.push(h.x,h.y,h.z);m.push(o+x,1-y);g.push(l++)}c.push(g)}for(let e=0;e<n;e++)for(let r=0;r<t;r++){const t=c[e][r+1];const i=c[e][r];const a=c[e+1][r];const l=c[e+1][r+1];(0!==e||s>0)&&d.push(t,i,l);(e!==n-1||o<Math.PI)&&d.push(i,a,l)}this.setIndex(d);this.setAttribute("position",new Float32BufferAttribute(p,3));this.setAttribute("normal",new Float32BufferAttribute(f,3));this.setAttribute("uv",new Float32BufferAttribute(m,2))}static fromJSON(e){return new SphereGeometry(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];const r=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,r,e,t);this.type="TetrahedronGeometry";this.parameters={radius:e,detail:t}}static fromJSON(e){return new TetrahedronGeometry(e.radius,e.detail)}}class TorusGeometry extends BufferGeometry{constructor(e=1,t=.4,n=8,r=6,i=2*Math.PI){super();this.type="TorusGeometry";this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:r,arc:i};n=Math.floor(n);r=Math.floor(r);const s=[];const a=[];const o=[];const l=[];const c=new Vector3;const u=new Vector3;const h=new Vector3;for(let s=0;s<=n;s++)for(let d=0;d<=r;d++){const p=d/r*i;const f=s/n*Math.PI*2;u.x=(e+t*Math.cos(f))*Math.cos(p);u.y=(e+t*Math.cos(f))*Math.sin(p);u.z=t*Math.sin(f);a.push(u.x,u.y,u.z);c.x=e*Math.cos(p);c.y=e*Math.sin(p);h.subVectors(u,c).normalize();o.push(h.x,h.y,h.z);l.push(d/r);l.push(s/n)}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*e+t-1;const i=(r+1)*(e-1)+t-1;const a=(r+1)*(e-1)+t;const o=(r+1)*e+t;s.push(n,i,o);s.push(i,a,o)}this.setIndex(s);this.setAttribute("position",new Float32BufferAttribute(a,3));this.setAttribute("normal",new Float32BufferAttribute(o,3));this.setAttribute("uv",new Float32BufferAttribute(l,2))}static fromJSON(e){return new TorusGeometry(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(e=1,t=.4,n=64,r=8,i=2,s=3){super();this.type="TorusKnotGeometry";this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:r,p:i,q:s};n=Math.floor(n);r=Math.floor(r);const a=[];const o=[];const l=[];const c=[];const u=new Vector3;const h=new Vector3;const d=new Vector3;const p=new Vector3;const f=new Vector3;const m=new Vector3;const g=new Vector3;for(let a=0;a<=n;++a){const y=a/n*i*Math.PI*2;calculatePositionOnCurve(y,i,s,e,d);calculatePositionOnCurve(y+.01,i,s,e,p);m.subVectors(p,d);g.addVectors(p,d);f.crossVectors(m,g);g.crossVectors(f,m);f.normalize();g.normalize();for(let e=0;e<=r;++e){const i=e/r*Math.PI*2;const s=-t*Math.cos(i);const p=t*Math.sin(i);u.x=d.x+(s*g.x+p*f.x);u.y=d.y+(s*g.y+p*f.y);u.z=d.z+(s*g.z+p*f.z);o.push(u.x,u.y,u.z);h.subVectors(u,d).normalize();l.push(h.x,h.y,h.z);c.push(a/n);c.push(e/r)}}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1);const i=(r+1)*e+(t-1);const s=(r+1)*e+t;const o=(r+1)*(e-1)+t;a.push(n,i,o);a.push(i,s,o)}this.setIndex(a);this.setAttribute("position",new Float32BufferAttribute(o,3));this.setAttribute("normal",new Float32BufferAttribute(l,3));this.setAttribute("uv",new Float32BufferAttribute(c,2));function calculatePositionOnCurve(e,t,n,r,i){const s=Math.cos(e);const a=Math.sin(e);const o=n/t*e;const l=Math.cos(o);i.x=r*(2+l)*.5*s;i.y=r*(2+l)*a*.5;i.z=r*Math.sin(o)*.5}}static fromJSON(e){return new TorusKnotGeometry(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class TubeGeometry extends BufferGeometry{constructor(e=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),t=64,n=1,r=8,i=false){super();this.type="TubeGeometry";this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:r,closed:i};const s=e.computeFrenetFrames(t,i);this.tangents=s.tangents;this.normals=s.normals;this.binormals=s.binormals;const a=new Vector3;const o=new Vector3;const l=new Vector2;let c=new Vector3;const u=[];const h=[];const d=[];const p=[];generateBufferData();this.setIndex(p);this.setAttribute("position",new Float32BufferAttribute(u,3));this.setAttribute("normal",new Float32BufferAttribute(h,3));this.setAttribute("uv",new Float32BufferAttribute(d,2));function generateBufferData(){for(let e=0;e<t;e++)generateSegment(e);generateSegment(false===i?t:0);generateUVs();generateIndices()}function generateSegment(i){c=e.getPointAt(i/t,c);const l=s.normals[i];const d=s.binormals[i];for(let e=0;e<=r;e++){const t=e/r*Math.PI*2;const i=Math.sin(t);const s=-Math.cos(t);o.x=s*l.x+i*d.x;o.y=s*l.y+i*d.y;o.z=s*l.z+i*d.z;o.normalize();h.push(o.x,o.y,o.z);a.x=c.x+n*o.x;a.y=c.y+n*o.y;a.z=c.z+n*o.z;u.push(a.x,a.y,a.z)}}function generateIndices(){for(let e=1;e<=t;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1);const i=(r+1)*e+(t-1);const s=(r+1)*e+t;const a=(r+1)*(e-1)+t;p.push(n,i,a);p.push(i,s,a)}}function generateUVs(){for(let e=0;e<=t;e++)for(let n=0;n<=r;n++){l.x=e/t;l.y=n/r;d.push(l.x,l.y)}}}toJSON(){const e=super.toJSON();e.path=this.parameters.path.toJSON();return e}static fromJSON(e){return new TubeGeometry((new Ll[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class WireframeGeometry extends BufferGeometry{constructor(e=null){super();this.type="WireframeGeometry";this.parameters={geometry:e};if(null!==e){const t=[];const n=new Set;const r=new Vector3;const i=new Vector3;if(null!==e.index){const s=e.attributes.position;const a=e.index;let o=e.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let e=0,l=o.length;e<l;++e){const l=o[e];const c=l.start;const u=l.count;for(let e=c,o=c+u;e<o;e+=3)for(let o=0;o<3;o++){const l=a.getX(e+o);const c=a.getX(e+(o+1)%3);r.fromBufferAttribute(s,l);i.fromBufferAttribute(s,c);if(true===isUniqueEdge(r,i,n)){t.push(r.x,r.y,r.z);t.push(i.x,i.y,i.z)}}}}else{const s=e.attributes.position;for(let e=0,a=s.count/3;e<a;e++)for(let a=0;a<3;a++){const o=3*e+a;const l=3*e+(a+1)%3;r.fromBufferAttribute(s,o);i.fromBufferAttribute(s,l);if(true===isUniqueEdge(r,i,n)){t.push(r.x,r.y,r.z);t.push(i.x,i.y,i.z)}}}this.setAttribute("position",new Float32BufferAttribute(t,3))}}}function isUniqueEdge(e,t,n){const r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;const i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;if(true===n.has(r)||true===n.has(i))return false;n.add(r,i);return true}var Pl=Object.freeze({__proto__:null,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronGeometry,EdgesGeometry:EdgesGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeGeometry,WireframeGeometry:WireframeGeometry});class ShadowMaterial extends Material{constructor(e){super();this.type="ShadowMaterial";this.color=new Color(0);this.transparent=true;this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);return this}}ShadowMaterial.prototype.isShadowMaterial=true;class MeshStandardMaterial extends Material{constructor(e){super();this.defines={STANDARD:""};this.type="MeshStandardMaterial";this.color=new Color(16777215);this.roughness=1;this.metalness=0;this.map=null;this.lightMap=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=Qt;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1;this.refractionRatio=.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap="round";this.wireframeLinejoin="round";this.flatShading=false;this.setValues(e)}copy(e){super.copy(e);this.defines={STANDARD:""};this.color.copy(e.color);this.roughness=e.roughness;this.metalness=e.metalness;this.map=e.map;this.lightMap=e.lightMap;this.lightMapIntensity=e.lightMapIntensity;this.aoMap=e.aoMap;this.aoMapIntensity=e.aoMapIntensity;this.emissive.copy(e.emissive);this.emissiveMap=e.emissiveMap;this.emissiveIntensity=e.emissiveIntensity;this.bumpMap=e.bumpMap;this.bumpScale=e.bumpScale;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(e.normalScale);this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.roughnessMap=e.roughnessMap;this.metalnessMap=e.metalnessMap;this.alphaMap=e.alphaMap;this.envMap=e.envMap;this.envMapIntensity=e.envMapIntensity;this.refractionRatio=e.refractionRatio;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.wireframeLinecap=e.wireframeLinecap;this.wireframeLinejoin=e.wireframeLinejoin;this.flatShading=e.flatShading;return this}}MeshStandardMaterial.prototype.isMeshStandardMaterial=true;class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(e){super();this.defines={STANDARD:"",PHYSICAL:""};this.type="MeshPhysicalMaterial";this.clearcoatMap=null;this.clearcoatRoughness=0;this.clearcoatRoughnessMap=null;this.clearcoatNormalScale=new Vector2(1,1);this.clearcoatNormalMap=null;this.ior=1.5;Object.defineProperty(this,"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}});this.sheenColor=new Color(0);this.sheenColorMap=null;this.sheenRoughness=1;this.sheenRoughnessMap=null;this.transmissionMap=null;this.thickness=0;this.thicknessMap=null;this.attenuationDistance=0;this.attenuationColor=new Color(1,1,1);this.specularIntensity=1;this.specularIntensityMap=null;this.specularColor=new Color(1,1,1);this.specularColorMap=null;this._sheen=0;this._clearcoat=0;this._transmission=0;this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!==e>0&&this.version++;this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!==e>0&&this.version++;this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!==e>0&&this.version++;this._transmission=e}copy(e){super.copy(e);this.defines={STANDARD:"",PHYSICAL:""};this.clearcoat=e.clearcoat;this.clearcoatMap=e.clearcoatMap;this.clearcoatRoughness=e.clearcoatRoughness;this.clearcoatRoughnessMap=e.clearcoatRoughnessMap;this.clearcoatNormalMap=e.clearcoatNormalMap;this.clearcoatNormalScale.copy(e.clearcoatNormalScale);this.ior=e.ior;this.sheen=e.sheen;this.sheenColor.copy(e.sheenColor);this.sheenColorMap=e.sheenColorMap;this.sheenRoughness=e.sheenRoughness;this.sheenRoughnessMap=e.sheenRoughnessMap;this.transmission=e.transmission;this.transmissionMap=e.transmissionMap;this.thickness=e.thickness;this.thicknessMap=e.thicknessMap;this.attenuationDistance=e.attenuationDistance;this.attenuationColor.copy(e.attenuationColor);this.specularIntensity=e.specularIntensity;this.specularIntensityMap=e.specularIntensityMap;this.specularColor.copy(e.specularColor);this.specularColorMap=e.specularColorMap;return this}}MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;class MeshPhongMaterial extends Material{constructor(e){super();this.type="MeshPhongMaterial";this.color=new Color(16777215);this.specular=new Color(1118481);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=Qt;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=X;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap="round";this.wireframeLinejoin="round";this.flatShading=false;this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.specular.copy(e.specular);this.shininess=e.shininess;this.map=e.map;this.lightMap=e.lightMap;this.lightMapIntensity=e.lightMapIntensity;this.aoMap=e.aoMap;this.aoMapIntensity=e.aoMapIntensity;this.emissive.copy(e.emissive);this.emissiveMap=e.emissiveMap;this.emissiveIntensity=e.emissiveIntensity;this.bumpMap=e.bumpMap;this.bumpScale=e.bumpScale;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(e.normalScale);this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.specularMap=e.specularMap;this.alphaMap=e.alphaMap;this.envMap=e.envMap;this.combine=e.combine;this.reflectivity=e.reflectivity;this.refractionRatio=e.refractionRatio;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.wireframeLinecap=e.wireframeLinecap;this.wireframeLinejoin=e.wireframeLinejoin;this.flatShading=e.flatShading;return this}}MeshPhongMaterial.prototype.isMeshPhongMaterial=true;class MeshToonMaterial extends Material{constructor(e){super();this.defines={TOON:""};this.type="MeshToonMaterial";this.color=new Color(16777215);this.map=null;this.gradientMap=null;this.lightMap=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=Qt;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap="round";this.wireframeLinejoin="round";this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.map=e.map;this.gradientMap=e.gradientMap;this.lightMap=e.lightMap;this.lightMapIntensity=e.lightMapIntensity;this.aoMap=e.aoMap;this.aoMapIntensity=e.aoMapIntensity;this.emissive.copy(e.emissive);this.emissiveMap=e.emissiveMap;this.emissiveIntensity=e.emissiveIntensity;this.bumpMap=e.bumpMap;this.bumpScale=e.bumpScale;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(e.normalScale);this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.alphaMap=e.alphaMap;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.wireframeLinecap=e.wireframeLinecap;this.wireframeLinejoin=e.wireframeLinejoin;return this}}MeshToonMaterial.prototype.isMeshToonMaterial=true;class MeshNormalMaterial extends Material{constructor(e){super();this.type="MeshNormalMaterial";this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=Qt;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.flatShading=false;this.setValues(e)}copy(e){super.copy(e);this.bumpMap=e.bumpMap;this.bumpScale=e.bumpScale;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(e.normalScale);this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.flatShading=e.flatShading;return this}}MeshNormalMaterial.prototype.isMeshNormalMaterial=true;class MeshLambertMaterial extends Material{constructor(e){super();this.type="MeshLambertMaterial";this.color=new Color(16777215);this.map=null;this.lightMap=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=X;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap="round";this.wireframeLinejoin="round";this.setValues(e)}copy(e){super.copy(e);this.color.copy(e.color);this.map=e.map;this.lightMap=e.lightMap;this.lightMapIntensity=e.lightMapIntensity;this.aoMap=e.aoMap;this.aoMapIntensity=e.aoMapIntensity;this.emissive.copy(e.emissive);this.emissiveMap=e.emissiveMap;this.emissiveIntensity=e.emissiveIntensity;this.specularMap=e.specularMap;this.alphaMap=e.alphaMap;this.envMap=e.envMap;this.combine=e.combine;this.reflectivity=e.reflectivity;this.refractionRatio=e.refractionRatio;this.wireframe=e.wireframe;this.wireframeLinewidth=e.wireframeLinewidth;this.wireframeLinecap=e.wireframeLinecap;this.wireframeLinejoin=e.wireframeLinejoin;return this}}MeshLambertMaterial.prototype.isMeshLambertMaterial=true;class MeshMatcapMaterial extends Material{constructor(e){super();this.defines={MATCAP:""};this.type="MeshMatcapMaterial";this.color=new Color(16777215);this.matcap=null;this.map=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=Qt;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.flatShading=false;this.setValues(e)}copy(e){super.copy(e);this.defines={MATCAP:""};this.color.copy(e.color);this.matcap=e.matcap;this.map=e.map;this.bumpMap=e.bumpMap;this.bumpScale=e.bumpScale;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(e.normalScale);this.displacementMap=e.displacementMap;this.displacementScale=e.displacementScale;this.displacementBias=e.displacementBias;this.alphaMap=e.alphaMap;this.flatShading=e.flatShading;return this}}MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;class LineDashedMaterial extends LineBasicMaterial{constructor(e){super();this.type="LineDashedMaterial";this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(e)}copy(e){super.copy(e);this.scale=e.scale;this.dashSize=e.dashSize;this.gapSize=e.gapSize;return this}}LineDashedMaterial.prototype.isLineDashedMaterial=true;var Il=Object.freeze({__proto__:null,ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});const Dl={arraySlice:function(e,t,n){return Dl.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"===typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function compareTime(t,n){return e[t]-e[n]}const t=e.length;const n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;n.sort(compareTime);return n},sortedArray:function(e,t,n){const r=e.length;const i=new e.constructor(r);for(let s=0,a=0;a!==r;++s){const r=n[s]*t;for(let n=0;n!==t;++n)i[a++]=e[r+n]}return i},flattenJSON:function(e,t,n,r){let i=1,s=e[0];while(void 0!==s&&void 0===s[r])s=e[i++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r];if(void 0!==a){t.push(s.time);n.push.apply(n,a)}s=e[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r];if(void 0!==a){t.push(s.time);a.toArray(n,n.length)}s=e[i++]}while(void 0!==s);else do{a=s[r];if(void 0!==a){t.push(s.time);n.push(a)}s=e[i++]}while(void 0!==s)},subclip:function(e,t,n,r,i=30){const s=e.clone();s.name=t;const a=[];for(let e=0;e<s.tracks.length;++e){const t=s.tracks[e];const o=t.getValueSize();const l=[];const c=[];for(let e=0;e<t.times.length;++e){const s=t.times[e]*i;if(!(s<n||s>=r)){l.push(t.times[e]);for(let n=0;n<o;++n)c.push(t.values[e*o+n])}}if(0!==l.length){t.times=Dl.convertArray(l,t.times.constructor);t.values=Dl.convertArray(c,t.values.constructor);a.push(t)}}s.tracks=a;let o=Infinity;for(let e=0;e<s.tracks.length;++e)o>s.tracks[e].times[0]&&(o=s.tracks[e].times[0]);for(let e=0;e<s.tracks.length;++e)s.tracks[e].shift(-1*o);s.resetDuration();return s},makeClipAdditive:function(e,t=0,n=e,r=30){r<=0&&(r=30);const i=n.tracks.length;const s=t/r;for(let t=0;t<i;++t){const r=n.tracks[t];const i=r.ValueTypeName;if("bool"===i||"string"===i)continue;const a=e.tracks.find((function(e){return e.name===r.name&&e.ValueTypeName===i}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=r.times.length-1;let d;if(s<=r.times[0]){const e=o;const t=l-o;d=Dl.arraySlice(r.values,e,t)}else if(s>=r.times[h]){const e=h*l+o;const t=e+l-o;d=Dl.arraySlice(r.values,e,t)}else{const e=r.createInterpolant();const t=o;const n=l-o;e.evaluate(s);d=Dl.arraySlice(e.resultBuffer,t,n)}if("quaternion"===i){const e=(new Quaternion).fromArray(d).normalize().conjugate();e.toArray(d)}const p=a.times.length;for(let e=0;e<p;++e){const t=e*u+c;if("quaternion"===i)Quaternion.multiplyQuaternionsFlat(a.values,t,d,0,a.values,t);else{const e=u-2*c;for(let n=0;n<e;++n)a.values[t+n]-=d[n]}}}e.blendMode=kt;return e}};class Interpolant{constructor(e,t,n,r){this.parameterPositions=e;this._cachedIndex=0;this.resultBuffer=void 0!==r?r:new t.constructor(n);this.sampleValues=t;this.valueSize=n;this.settings=null;this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],i=t[n-1];e:{t:{let s;n:{r:if(!(e<r)){for(let s=n+2;;){if(void 0===r){if(e<i)break r;n=t.length;this._cachedIndex=n;return this.afterEnd_(n-1,e,i)}if(n===s)break;i=r;r=t[++n];if(e<r)break t}s=t.length;break n}if(e>=i)break e;{const a=t[1];if(e<a){n=2;i=a}for(let s=n-2;;){if(void 0===i){this._cachedIndex=0;return this.beforeStart_(0,e,r)}if(n===s)break;r=i;i=t[--n-1];if(e>=i)break t}s=n;n=0}}while(n<s){const r=n+s>>>1;e<t[r]?s=r:n=r+1}r=t[n];i=t[n-1];if(void 0===i){this._cachedIndex=0;return this.beforeStart_(0,e,r)}if(void 0===r){n=t.length;this._cachedIndex=n;return this.afterEnd_(n-1,i,e)}}this._cachedIndex=n;this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=e*r;for(let e=0;e!==r;++e)t[e]=n[i+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Interpolant.prototype.beforeStart_=Interpolant.prototype.copySampleValue_;Interpolant.prototype.afterEnd_=Interpolant.prototype.copySampleValue_;class CubicInterpolant extends Interpolant{constructor(e,t,n,r){super(e,t,n,r);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;this.DefaultSettings_={endingStart:Gt,endingEnd:Gt}}intervalChanged_(e,t,n){const r=this.parameterPositions;let i=e-2,s=e+1,a=r[i],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case Ft:i=e;a=2*t-n;break;case Ot:i=r.length-2;a=t+r[i]-r[i+1];break;default:i=e;a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Ft:s=e;o=2*n-t;break;case Ot:s=1;o=n+r[1]-r[0];break;default:s=e-1;o=t}const l=.5*(n-t),c=this.valueSize;this._weightPrev=l/(t-a);this._weightNext=l/(o-n);this._offsetPrev=i*c;this._offsetNext=s*c}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-t)/(r-t),f=p*p,m=f*p;const g=-h*m+2*h*f-h*p;const y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1;const x=(-1-d)*m+(1.5+d)*f+.5*p;const b=d*m-d*f;for(let e=0;e!==a;++e)i[e]=g*s[c+e]+y*s[l+e]+x*s[o+e]+b*s[u+e];return i}}class LinearInterpolant extends Interpolant{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=(n-t)/(r-t),u=1-c;for(let e=0;e!==a;++e)i[e]=s[l+e]*u+s[o+e]*c;return i}}class DiscreteInterpolant extends Interpolant{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class KeyframeTrack{constructor(e,t,n,r){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e;this.times=Dl.convertArray(t,this.TimeBufferType);this.values=Dl.convertArray(n,this.ValueBufferType);this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Dl.convertArray(e.times,Array),values:Dl.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}n.type=e.ValueTypeName;return n}InterpolantFactoryMethodDiscrete(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Nt:t=this.InterpolantFactoryMethodDiscrete;break;case Ut:t=this.InterpolantFactoryMethodLinear;break;case zt:t=this.InterpolantFactoryMethodSmooth;break}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}console.warn("THREE.KeyframeTrack:",t);return this}this.createInterpolant=t;return this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Nt;case this.InterpolantFactoryMethodLinear:return Ut;case this.InterpolantFactoryMethodSmooth:return zt}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let i=0,s=r-1;while(i!==r&&n[i]<e)++i;while(-1!==s&&n[s]>t)--s;++s;if(0!==i||s!==r){if(i>=s){s=Math.max(s,1);i=s-1}const e=this.getValueSize();this.times=Dl.arraySlice(n,i,s);this.values=Dl.arraySlice(this.values,i*e,s*e)}return this}validate(){let e=true;const t=this.getValueSize();if(t-Math.floor(t)!==0){console.error("THREE.KeyframeTrack: Invalid value size in track.",this);e=false}const n=this.times,r=this.values,i=n.length;if(0===i){console.error("THREE.KeyframeTrack: Track is empty.",this);e=false}let s=null;for(let t=0;t!==i;t++){const r=n[t];if("number"===typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,r);e=false;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,r,s);e=false;break}s=r}if(void 0!==r&&Dl.isTypedArray(r))for(let t=0,n=r.length;t!==n;++t){const n=r[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n);e=false;break}}return e}optimize(){const e=Dl.arraySlice(this.times),t=Dl.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===zt,i=e.length-1;let s=1;for(let a=1;a<i;++a){let i=false;const o=e[a];const l=e[a+1];if(o!==l&&(1!==a||o!==e[0]))if(r)i=true;else{const e=a*n,r=e-n,s=e+n;for(let a=0;a!==n;++a){const n=t[e+a];if(n!==t[r+a]||n!==t[s+a]){i=true;break}}}if(i){if(a!==s){e[s]=e[a];const r=a*n,i=s*n;for(let e=0;e!==n;++e)t[i+e]=t[r+e]}++s}}if(i>0){e[s]=e[i];for(let e=i*n,r=s*n,a=0;a!==n;++a)t[r+a]=t[e+a];++s}if(s!==e.length){this.times=Dl.arraySlice(e,0,s);this.values=Dl.arraySlice(t,0,s*n)}else{this.times=e;this.values=t}return this}clone(){const e=Dl.arraySlice(this.times,0);const t=Dl.arraySlice(this.values,0);const n=this.constructor;const r=new n(this.name,e,t);r.createInterpolant=this.createInterpolant;return r}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=Ut;class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=Nt;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-t)/(r-t);let l=e*a;for(let e=l+a;l!==e;l+=4)Quaternion.slerpFlat(i,0,s,l-a,s,l,o);return i}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.DefaultInterpolation=Ut;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=Nt;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(e,t=-1,n,r=Ht){this.name=e;this.tracks=n;this.duration=t;this.blendMode=r;this.uuid=generateUUID();this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let e=0,i=n.length;e!==i;++e)t.push(parseKeyframeTrack(n[e]).scale(r));const i=new this(e.name,e.duration,t,e.blendMode);i.uuid=e.uuid;return i}static toJSON(e){const t=[],n=e.tracks;const r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,r=n.length;e!==r;++e)t.push(KeyframeTrack.toJSON(n[e]));return r}static CreateFromMorphTargetSequence(e,t,n,r){const i=t.length;const s=[];for(let e=0;e<i;e++){let a=[];let o=[];a.push((e+i-1)%i,e,(e+1)%i);o.push(0,1,0);const l=Dl.getKeyframeOrder(a);a=Dl.sortedArray(a,1,l);o=Dl.sortedArray(o,1,l);if(!r&&0===a[0]){a.push(i);o.push(o[0])}s.push(new NumberKeyframeTrack(".morphTargetInfluences["+t[e].name+"]",a,o).scale(1/n))}return new this(e,-1,s)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const r={};const i=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t];const s=n.name.match(i);if(s&&s.length>1){const e=s[1];let t=r[e];t||(r[e]=t=[]);t.push(n)}}const s=[];for(const e in r)s.push(this.CreateFromMorphTargetSequence(e,r[e],t,n));return s}static parseAnimation(e,t){if(!e){console.error("THREE.AnimationClip: No animation in JSONLoader data.");return null}const addNonemptyTrack=function(e,t,n,r,i){if(0!==n.length){const s=[];const a=[];Dl.flattenJSON(n,s,a,r);0!==s.length&&i.push(new e(t,s,a))}};const n=[];const r=e.name||"default";const i=e.fps||30;const s=e.blendMode;let a=e.length||-1;const o=e.hierarchy||[];for(let e=0;e<o.length;e++){const r=o[e].keys;if(r&&0!==r.length)if(r[0].morphTargets){const e={};let t;for(t=0;t<r.length;t++)if(r[t].morphTargets)for(let n=0;n<r[t].morphTargets.length;n++)e[r[t].morphTargets[n]]=-1;for(const i in e){const e=[];const s=[];for(let n=0;n!==r[t].morphTargets.length;++n){const n=r[t];e.push(n.time);s.push(n.morphTarget===i?1:0)}n.push(new NumberKeyframeTrack(".morphTargetInfluence["+i+"]",e,s))}a=e.length*(i||1)}else{const i=".bones["+t[e].name+"]";addNonemptyTrack(VectorKeyframeTrack,i+".position",r,"pos",n);addNonemptyTrack(QuaternionKeyframeTrack,i+".quaternion",r,"rot",n);addNonemptyTrack(VectorKeyframeTrack,i+".scale",r,"scl",n)}}if(0===n.length)return null;const l=new this(r,a,n,s);return l}resetDuration(){const e=this.tracks;let t=0;for(let n=0,r=e.length;n!==r;++n){const e=this.tracks[n];t=Math.max(t,e.times[e.times.length-1])}this.duration=t;return this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=true;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function parseKeyframeTrack(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=getTrackTypeForValueTypeName(e.type);if(void 0===e.times){const t=[],n=[];Dl.flattenJSON(e.keys,t,n,"value");e.times=t;e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const Bl={enabled:false,files:{},add:function(e,t){false!==this.enabled&&(this.files[e]=t)},get:function(e){if(false!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class LoadingManager{constructor(e,t,n){const r=this;let i=false;let s=0;let a=0;let o;const l=[];this.onStart=void 0;this.onLoad=e;this.onProgress=t;this.onError=n;this.itemStart=function(e){a++;false===i&&void 0!==r.onStart&&r.onStart(e,s,a);i=true};this.itemEnd=function(e){s++;void 0!==r.onProgress&&r.onProgress(e,s,a);if(s===a){i=false;void 0!==r.onLoad&&r.onLoad()}};this.itemError=function(e){void 0!==r.onError&&r.onError(e)};this.resolveURL=function(e){return o?o(e):e};this.setURLModifier=function(e){o=e;return this};this.addHandler=function(e,t){l.push(e,t);return this};this.removeHandler=function(e){const t=l.indexOf(e);-1!==t&&l.splice(t,2);return this};this.getHandler=function(e){for(let t=0,n=l.length;t<n;t+=2){const n=l[t];const r=l[t+1];n.global&&(n.lastIndex=0);if(n.test(e))return r}return null}}}const Vl=new LoadingManager;class Loader{constructor(e){this.manager=void 0!==e?e:Vl;this.crossOrigin="anonymous";this.withCredentials=false;this.path="";this.resourcePath="";this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise((function(r,i){n.load(e,r,t,i)}))}parse(){}setCrossOrigin(e){this.crossOrigin=e;return this}setWithCredentials(e){this.withCredentials=e;return this}setPath(e){this.path=e;return this}setResourcePath(e){this.resourcePath=e;return this}setRequestHeader(e){this.requestHeader=e;return this}}const Nl={};class FileLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){void 0===e&&(e="");void 0!==this.path&&(e=this.path+e);e=this.manager.resolveURL(e);const i=Bl.get(e);if(void 0!==i){this.manager.itemStart(e);setTimeout((()=>{t&&t(i);this.manager.itemEnd(e)}),0);return i}if(void 0!==Nl[e]){Nl[e].push({onLoad:t,onProgress:n,onError:r});return}Nl[e]=[];Nl[e].push({onLoad:t,onProgress:n,onError:r});const s=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(s).then((t=>{if(200===t.status||0===t.status){0===t.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");if("undefined"===typeof ReadableStream||void 0===t.body.getReader)return t;const n=Nl[e];const r=t.body.getReader();const i=t.headers.get("Content-Length");const s=i?parseInt(i):0;const a=0!==s;let o=0;const l=new ReadableStream({start(e){readData();function readData(){r.read().then((({done:t,value:r})=>{if(t)e.close();else{o+=r.byteLength;const t=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onProgress&&r.onProgress(t)}e.enqueue(r);readData()}}))}}});return new Response(l)}throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)})).then((e=>{switch(this.responseType){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then((e=>{const t=new DOMParser;return t.parseFromString(e,this.mimeType)}));case"json":return e.json();default:return e.text()}})).then((t=>{Bl.add(e,t);const n=Nl[e];delete Nl[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onLoad&&r.onLoad(t)}})).catch((t=>{const n=Nl[e];if(void 0===n){this.manager.itemError(e);throw t}delete Nl[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onError&&r.onError(t)}this.manager.itemError(e)})).finally((()=>{this.manager.itemEnd(e)}));this.manager.itemStart(e)}setResponseType(e){this.responseType=e;return this}setMimeType(e){this.mimeType=e;return this}}class AnimationLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=new FileLoader(this.manager);s.setPath(this.path);s.setRequestHeader(this.requestHeader);s.setWithCredentials(this.withCredentials);s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t);i.manager.itemError(e)}}),n,r)}parse(e){const t=[];for(let n=0;n<e.length;n++){const r=AnimationClip.parse(e[n]);t.push(r)}return t}}class CompressedTextureLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=[];const a=new CompressedTexture;const o=new FileLoader(this.manager);o.setPath(this.path);o.setResponseType("arraybuffer");o.setRequestHeader(this.requestHeader);o.setWithCredentials(i.withCredentials);let l=0;function loadTexture(c){o.load(e[c],(function(e){const n=i.parse(e,true);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps};l+=1;if(6===l){1===n.mipmapCount&&(a.minFilter=ye);a.image=s;a.format=n.format;a.needsUpdate=true;t&&t(a)}}),n,r)}if(Array.isArray(e))for(let t=0,n=e.length;t<n;++t)loadTexture(t);else o.load(e,(function(e){const n=i.parse(e,true);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){s[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++){s[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]);s[t].format=n.format;s[t].width=n.width;s[t].height=n.height}}a.image=s}else{a.image.width=n.width;a.image.height=n.height;a.mipmaps=n.mipmaps}1===n.mipmapCount&&(a.minFilter=ye);a.format=n.format;a.needsUpdate=true;t&&t(a)}),n,r);return a}}class ImageLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){void 0!==this.path&&(e=this.path+e);e=this.manager.resolveURL(e);const i=this;const s=Bl.get(e);if(void 0!==s){i.manager.itemStart(e);setTimeout((function(){t&&t(s);i.manager.itemEnd(e)}),0);return s}const a=createElementNS("img");function onImageLoad(){removeEventListeners();Bl.add(e,this);t&&t(this);i.manager.itemEnd(e)}function onImageError(t){removeEventListeners();r&&r(t);i.manager.itemError(e);i.manager.itemEnd(e)}function removeEventListeners(){a.removeEventListener("load",onImageLoad,false);a.removeEventListener("error",onImageError,false)}a.addEventListener("load",onImageLoad,false);a.addEventListener("error",onImageError,false);"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin);i.manager.itemStart(e);a.src=e;return a}}class CubeTextureLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=new CubeTexture;const s=new ImageLoader(this.manager);s.setCrossOrigin(this.crossOrigin);s.setPath(this.path);let a=0;function loadTexture(n){s.load(e[n],(function(e){i.images[n]=e;a++;if(6===a){i.needsUpdate=true;t&&t(i)}}),void 0,r)}for(let t=0;t<e.length;++t)loadTexture(t);return i}}class DataTextureLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=new DataTexture;const a=new FileLoader(this.manager);a.setResponseType("arraybuffer");a.setRequestHeader(this.requestHeader);a.setPath(this.path);a.setWithCredentials(i.withCredentials);a.load(e,(function(e){const n=i.parse(e);if(n){if(void 0!==n.image)s.image=n.image;else if(void 0!==n.data){s.image.width=n.width;s.image.height=n.height;s.image.data=n.data}s.wrapS=void 0!==n.wrapS?n.wrapS:ue;s.wrapT=void 0!==n.wrapT?n.wrapT:ue;s.magFilter=void 0!==n.magFilter?n.magFilter:ye;s.minFilter=void 0!==n.minFilter?n.minFilter:ye;s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1;void 0!==n.encoding&&(s.encoding=n.encoding);void 0!==n.flipY&&(s.flipY=n.flipY);void 0!==n.format&&(s.format=n.format);void 0!==n.type&&(s.type=n.type);if(void 0!==n.mipmaps){s.mipmaps=n.mipmaps;s.minFilter=be}1===n.mipmapCount&&(s.minFilter=ye);void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps);s.needsUpdate=true;t&&t(s,n)}}),n,r);return s}}class TextureLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=new Texture;const s=new ImageLoader(this.manager);s.setCrossOrigin(this.crossOrigin);s.setPath(this.path);s.load(e,(function(e){i.image=e;i.needsUpdate=true;void 0!==t&&t(i)}),n,r);return i}}class Light extends Object3D{constructor(e,t=1){super();this.type="Light";this.color=new Color(e);this.intensity=t}dispose(){}copy(e){super.copy(e);this.color.copy(e.color);this.intensity=e.intensity;return this}toJSON(e){const t=super.toJSON(e);t.object.color=this.color.getHex();t.object.intensity=this.intensity;void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(t.object.distance=this.distance);void 0!==this.angle&&(t.object.angle=this.angle);void 0!==this.decay&&(t.object.decay=this.decay);void 0!==this.penumbra&&(t.object.penumbra=this.penumbra);void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON());return t}}Light.prototype.isLight=true;class HemisphereLight extends Light{constructor(e,t,n){super(e,n);this.type="HemisphereLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(t)}copy(e){Light.prototype.copy.call(this,e);this.groundColor.copy(e.groundColor);return this}}HemisphereLight.prototype.isHemisphereLight=true;const Ul=new Matrix4;const zl=new Vector3;const Gl=new Vector3;class LightShadow{constructor(e){this.camera=e;this.bias=0;this.normalBias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4;this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum;this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera;const n=this.matrix;zl.setFromMatrixPosition(e.matrixWorld);t.position.copy(zl);Gl.setFromMatrixPosition(e.target.matrixWorld);t.lookAt(Gl);t.updateMatrixWorld();Ul.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);this._frustum.setFromProjectionMatrix(Ul);n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);n.multiply(t.projectionMatrix);n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose();this.mapPass&&this.mapPass.dispose()}copy(e){this.camera=e.camera.clone();this.bias=e.bias;this.radius=e.radius;this.mapSize.copy(e.mapSize);return this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};0!==this.bias&&(e.bias=this.bias);0!==this.normalBias&&(e.normalBias=this.normalBias);1!==this.radius&&(e.radius=this.radius);512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray());e.camera=this.camera.toJSON(false).object;delete e.camera.matrix;return e}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500));this.focus=1}updateMatrices(e){const t=this.camera;const n=2*Rn*e.angle*this.focus;const r=this.mapSize.width/this.mapSize.height;const i=e.distance||t.far;if(n!==t.fov||r!==t.aspect||i!==t.far){t.fov=n;t.aspect=r;t.far=i;t.updateProjectionMatrix()}super.updateMatrices(e)}copy(e){super.copy(e);this.focus=e.focus;return this}}SpotLightShadow.prototype.isSpotLightShadow=true;class SpotLight extends Light{constructor(e,t,n=0,r=Math.PI/3,i=0,s=1){super(e,t);this.type="SpotLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D;this.distance=n;this.angle=r;this.penumbra=i;this.decay=s;this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){super.copy(e);this.distance=e.distance;this.angle=e.angle;this.penumbra=e.penumbra;this.decay=e.decay;this.target=e.target.clone();this.shadow=e.shadow.clone();return this}}SpotLight.prototype.isSpotLight=true;const Fl=new Matrix4;const Ol=new Vector3;const Hl=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500));this._frameExtents=new Vector2(4,2);this._viewportCount=6;this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)];this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera;const r=this.matrix;const i=e.distance||n.far;if(i!==n.far){n.far=i;n.updateProjectionMatrix()}Ol.setFromMatrixPosition(e.matrixWorld);n.position.copy(Ol);Hl.copy(n.position);Hl.add(this._cubeDirections[t]);n.up.copy(this._cubeUps[t]);n.lookAt(Hl);n.updateMatrixWorld();r.makeTranslation(-Ol.x,-Ol.y,-Ol.z);Fl.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse);this._frustum.setFromProjectionMatrix(Fl)}}PointLightShadow.prototype.isPointLightShadow=true;class PointLight extends Light{constructor(e,t,n=0,r=1){super(e,t);this.type="PointLight";this.distance=n;this.decay=r;this.shadow=new PointLightShadow}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){super.copy(e);this.distance=e.distance;this.decay=e.decay;this.shadow=e.shadow.clone();return this}}PointLight.prototype.isPointLight=true;class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500))}}DirectionalLightShadow.prototype.isDirectionalLightShadow=true;class DirectionalLight extends Light{constructor(e,t){super(e,t);this.type="DirectionalLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D;this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(e){super.copy(e);this.target=e.target.clone();this.shadow=e.shadow.clone();return this}}DirectionalLight.prototype.isDirectionalLight=true;class AmbientLight extends Light{constructor(e,t){super(e,t);this.type="AmbientLight"}}AmbientLight.prototype.isAmbientLight=true;class RectAreaLight extends Light{constructor(e,t,n=10,r=10){super(e,t);this.type="RectAreaLight";this.width=n;this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){super.copy(e);this.width=e.width;this.height=e.height;return this}toJSON(e){const t=super.toJSON(e);t.object.width=this.width;t.object.height=this.height;return t}}RectAreaLight.prototype.isRectAreaLight=true;class SphericalHarmonics3{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Vector3)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,i=e.z;const s=this.coefficients;t.copy(s[0]).multiplyScalar(.282095);t.addScaledVector(s[1],.488603*r);t.addScaledVector(s[2],.488603*i);t.addScaledVector(s[3],.488603*n);t.addScaledVector(s[4],n*r*1.092548);t.addScaledVector(s[5],r*i*1.092548);t.addScaledVector(s[6],.315392*(3*i*i-1));t.addScaledVector(s[7],n*i*1.092548);t.addScaledVector(s[8],.546274*(n*n-r*r));return t}getIrradianceAt(e,t){const n=e.x,r=e.y,i=e.z;const s=this.coefficients;t.copy(s[0]).multiplyScalar(.886227);t.addScaledVector(s[1],1.023328*r);t.addScaledVector(s[2],1.023328*i);t.addScaledVector(s[3],1.023328*n);t.addScaledVector(s[4],.858086*n*r);t.addScaledVector(s[5],.858086*r*i);t.addScaledVector(s[6],.743125*i*i-.247708);t.addScaledVector(s[7],.858086*n*i);t.addScaledVector(s[8],.429043*(n*n-r*r));return t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return false;return true}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+3*r);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+3*r);return e}static getBasisAt(e,t){const n=e.x,r=e.y,i=e.z;t[0]=.282095;t[1]=.488603*r;t[2]=.488603*i;t[3]=.488603*n;t[4]=1.092548*n*r;t[5]=1.092548*r*i;t[6]=.315392*(3*i*i-1);t[7]=1.092548*n*i;t[8]=.546274*(n*n-r*r)}}SphericalHarmonics3.prototype.isSphericalHarmonics3=true;class LightProbe extends Light{constructor(e=new SphericalHarmonics3,t=1){super(void 0,t);this.sh=e}copy(e){super.copy(e);this.sh.copy(e.sh);return this}fromJSON(e){this.intensity=e.intensity;this.sh.fromArray(e.sh);return this}toJSON(e){const t=super.toJSON(e);t.object.sh=this.sh.toArray();return t}}LightProbe.prototype.isLightProbe=true;class MaterialLoader extends Loader{constructor(e){super(e);this.textures={}}load(e,t,n,r){const i=this;const s=new FileLoader(i.manager);s.setPath(i.path);s.setRequestHeader(i.requestHeader);s.setWithCredentials(i.withCredentials);s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t);i.manager.itemError(e)}}),n,r)}parse(e){const t=this.textures;function getTexture(e){void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e);return t[e]}const n=new Il[e.type];void 0!==e.uuid&&(n.uuid=e.uuid);void 0!==e.name&&(n.name=e.name);void 0!==e.color&&void 0!==n.color&&n.color.setHex(e.color);void 0!==e.roughness&&(n.roughness=e.roughness);void 0!==e.metalness&&(n.metalness=e.metalness);void 0!==e.sheen&&(n.sheen=e.sheen);void 0!==e.sheenColor&&(n.sheenColor=(new Color).setHex(e.sheenColor));void 0!==e.sheenRoughness&&(n.sheenRoughness=e.sheenRoughness);void 0!==e.emissive&&void 0!==n.emissive&&n.emissive.setHex(e.emissive);void 0!==e.specular&&void 0!==n.specular&&n.specular.setHex(e.specular);void 0!==e.specularIntensity&&(n.specularIntensity=e.specularIntensity);void 0!==e.specularColor&&void 0!==n.specularColor&&n.specularColor.setHex(e.specularColor);void 0!==e.shininess&&(n.shininess=e.shininess);void 0!==e.clearcoat&&(n.clearcoat=e.clearcoat);void 0!==e.clearcoatRoughness&&(n.clearcoatRoughness=e.clearcoatRoughness);void 0!==e.transmission&&(n.transmission=e.transmission);void 0!==e.thickness&&(n.thickness=e.thickness);void 0!==e.attenuationDistance&&(n.attenuationDistance=e.attenuationDistance);void 0!==e.attenuationColor&&void 0!==n.attenuationColor&&n.attenuationColor.setHex(e.attenuationColor);void 0!==e.fog&&(n.fog=e.fog);void 0!==e.flatShading&&(n.flatShading=e.flatShading);void 0!==e.blending&&(n.blending=e.blending);void 0!==e.combine&&(n.combine=e.combine);void 0!==e.side&&(n.side=e.side);void 0!==e.shadowSide&&(n.shadowSide=e.shadowSide);void 0!==e.opacity&&(n.opacity=e.opacity);void 0!==e.format&&(n.format=e.format);void 0!==e.transparent&&(n.transparent=e.transparent);void 0!==e.alphaTest&&(n.alphaTest=e.alphaTest);void 0!==e.depthTest&&(n.depthTest=e.depthTest);void 0!==e.depthWrite&&(n.depthWrite=e.depthWrite);void 0!==e.colorWrite&&(n.colorWrite=e.colorWrite);void 0!==e.stencilWrite&&(n.stencilWrite=e.stencilWrite);void 0!==e.stencilWriteMask&&(n.stencilWriteMask=e.stencilWriteMask);void 0!==e.stencilFunc&&(n.stencilFunc=e.stencilFunc);void 0!==e.stencilRef&&(n.stencilRef=e.stencilRef);void 0!==e.stencilFuncMask&&(n.stencilFuncMask=e.stencilFuncMask);void 0!==e.stencilFail&&(n.stencilFail=e.stencilFail);void 0!==e.stencilZFail&&(n.stencilZFail=e.stencilZFail);void 0!==e.stencilZPass&&(n.stencilZPass=e.stencilZPass);void 0!==e.wireframe&&(n.wireframe=e.wireframe);void 0!==e.wireframeLinewidth&&(n.wireframeLinewidth=e.wireframeLinewidth);void 0!==e.wireframeLinecap&&(n.wireframeLinecap=e.wireframeLinecap);void 0!==e.wireframeLinejoin&&(n.wireframeLinejoin=e.wireframeLinejoin);void 0!==e.rotation&&(n.rotation=e.rotation);1!==e.linewidth&&(n.linewidth=e.linewidth);void 0!==e.dashSize&&(n.dashSize=e.dashSize);void 0!==e.gapSize&&(n.gapSize=e.gapSize);void 0!==e.scale&&(n.scale=e.scale);void 0!==e.polygonOffset&&(n.polygonOffset=e.polygonOffset);void 0!==e.polygonOffsetFactor&&(n.polygonOffsetFactor=e.polygonOffsetFactor);void 0!==e.polygonOffsetUnits&&(n.polygonOffsetUnits=e.polygonOffsetUnits);void 0!==e.dithering&&(n.dithering=e.dithering);void 0!==e.alphaToCoverage&&(n.alphaToCoverage=e.alphaToCoverage);void 0!==e.premultipliedAlpha&&(n.premultipliedAlpha=e.premultipliedAlpha);void 0!==e.visible&&(n.visible=e.visible);void 0!==e.toneMapped&&(n.toneMapped=e.toneMapped);void 0!==e.userData&&(n.userData=e.userData);void 0!==e.vertexColors&&("number"===typeof e.vertexColors?n.vertexColors=e.vertexColors>0:n.vertexColors=e.vertexColors);if(void 0!==e.uniforms)for(const t in e.uniforms){const r=e.uniforms[t];n.uniforms[t]={};switch(r.type){case"t":n.uniforms[t].value=getTexture(r.value);break;case"c":n.uniforms[t].value=(new Color).setHex(r.value);break;case"v2":n.uniforms[t].value=(new Vector2).fromArray(r.value);break;case"v3":n.uniforms[t].value=(new Vector3).fromArray(r.value);break;case"v4":n.uniforms[t].value=(new Vector4).fromArray(r.value);break;case"m3":n.uniforms[t].value=(new Matrix3).fromArray(r.value);break;case"m4":n.uniforms[t].value=(new Matrix4).fromArray(r.value);break;default:n.uniforms[t].value=r.value}}void 0!==e.defines&&(n.defines=e.defines);void 0!==e.vertexShader&&(n.vertexShader=e.vertexShader);void 0!==e.fragmentShader&&(n.fragmentShader=e.fragmentShader);if(void 0!==e.extensions)for(const t in e.extensions)n.extensions[t]=e.extensions[t];void 0!==e.shading&&(n.flatShading=1===e.shading);void 0!==e.size&&(n.size=e.size);void 0!==e.sizeAttenuation&&(n.sizeAttenuation=e.sizeAttenuation);void 0!==e.map&&(n.map=getTexture(e.map));void 0!==e.matcap&&(n.matcap=getTexture(e.matcap));void 0!==e.alphaMap&&(n.alphaMap=getTexture(e.alphaMap));void 0!==e.bumpMap&&(n.bumpMap=getTexture(e.bumpMap));void 0!==e.bumpScale&&(n.bumpScale=e.bumpScale);void 0!==e.normalMap&&(n.normalMap=getTexture(e.normalMap));void 0!==e.normalMapType&&(n.normalMapType=e.normalMapType);if(void 0!==e.normalScale){let t=e.normalScale;false===Array.isArray(t)&&(t=[t,t]);n.normalScale=(new Vector2).fromArray(t)}void 0!==e.displacementMap&&(n.displacementMap=getTexture(e.displacementMap));void 0!==e.displacementScale&&(n.displacementScale=e.displacementScale);void 0!==e.displacementBias&&(n.displacementBias=e.displacementBias);void 0!==e.roughnessMap&&(n.roughnessMap=getTexture(e.roughnessMap));void 0!==e.metalnessMap&&(n.metalnessMap=getTexture(e.metalnessMap));void 0!==e.emissiveMap&&(n.emissiveMap=getTexture(e.emissiveMap));void 0!==e.emissiveIntensity&&(n.emissiveIntensity=e.emissiveIntensity);void 0!==e.specularMap&&(n.specularMap=getTexture(e.specularMap));void 0!==e.specularIntensityMap&&(n.specularIntensityMap=getTexture(e.specularIntensityMap));void 0!==e.specularColorMap&&(n.specularColorMap=getTexture(e.specularColorMap));void 0!==e.envMap&&(n.envMap=getTexture(e.envMap));void 0!==e.envMapIntensity&&(n.envMapIntensity=e.envMapIntensity);void 0!==e.reflectivity&&(n.reflectivity=e.reflectivity);void 0!==e.refractionRatio&&(n.refractionRatio=e.refractionRatio);void 0!==e.lightMap&&(n.lightMap=getTexture(e.lightMap));void 0!==e.lightMapIntensity&&(n.lightMapIntensity=e.lightMapIntensity);void 0!==e.aoMap&&(n.aoMap=getTexture(e.aoMap));void 0!==e.aoMapIntensity&&(n.aoMapIntensity=e.aoMapIntensity);void 0!==e.gradientMap&&(n.gradientMap=getTexture(e.gradientMap));void 0!==e.clearcoatMap&&(n.clearcoatMap=getTexture(e.clearcoatMap));void 0!==e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=getTexture(e.clearcoatRoughnessMap));void 0!==e.clearcoatNormalMap&&(n.clearcoatNormalMap=getTexture(e.clearcoatNormalMap));void 0!==e.clearcoatNormalScale&&(n.clearcoatNormalScale=(new Vector2).fromArray(e.clearcoatNormalScale));void 0!==e.transmissionMap&&(n.transmissionMap=getTexture(e.transmissionMap));void 0!==e.thicknessMap&&(n.thicknessMap=getTexture(e.thicknessMap));void 0!==e.sheenColorMap&&(n.sheenColorMap=getTexture(e.sheenColorMap));void 0!==e.sheenRoughnessMap&&(n.sheenRoughnessMap=getTexture(e.sheenRoughnessMap));return n}setTextures(e){this.textures=e;return this}}class LoaderUtils{static decodeText(e){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}static resolveURL(e,t){if("string"!==typeof e||""===e)return"";/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1"));return/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super();this.type="InstancedBufferGeometry";this.instanceCount=Infinity}copy(e){super.copy(e);this.instanceCount=e.instanceCount;return this}clone(){return(new this.constructor).copy(this)}toJSON(){const e=super.toJSON(this);e.instanceCount=this.instanceCount;e.isInstancedBufferGeometry=true;return e}}InstancedBufferGeometry.prototype.isInstancedBufferGeometry=true;class BufferGeometryLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=new FileLoader(i.manager);s.setPath(i.path);s.setRequestHeader(i.requestHeader);s.setWithCredentials(i.withCredentials);s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t);i.manager.itemError(e)}}),n,r)}parse(e){const t={};const n={};function getInterleavedBuffer(e,n){if(void 0!==t[n])return t[n];const r=e.interleavedBuffers;const i=r[n];const s=getArrayBuffer(e,i.buffer);const a=getTypedArray(i.type,s);const o=new InterleavedBuffer(a,i.stride);o.uuid=i.uuid;t[n]=o;return o}function getArrayBuffer(e,t){if(void 0!==n[t])return n[t];const r=e.arrayBuffers;const i=r[t];const s=new Uint32Array(i).buffer;n[t]=s;return s}const r=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry;const i=e.data.index;if(void 0!==i){const e=getTypedArray(i.type,i.array);r.setIndex(new BufferAttribute(e,1))}const s=e.data.attributes;for(const t in s){const n=s[t];let i;if(n.isInterleavedBufferAttribute){const t=getInterleavedBuffer(e.data,n.data);i=new InterleavedBufferAttribute(t,n.itemSize,n.offset,n.normalized)}else{const e=getTypedArray(n.type,n.array);const t=n.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;i=new t(e,n.itemSize,n.normalized)}void 0!==n.name&&(i.name=n.name);void 0!==n.usage&&i.setUsage(n.usage);if(void 0!==n.updateRange){i.updateRange.offset=n.updateRange.offset;i.updateRange.count=n.updateRange.count}r.setAttribute(t,i)}const a=e.data.morphAttributes;if(a)for(const t in a){const n=a[t];const i=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];let s;if(r.isInterleavedBufferAttribute){const t=getInterleavedBuffer(e.data,r.data);s=new InterleavedBufferAttribute(t,r.itemSize,r.offset,r.normalized)}else{const e=getTypedArray(r.type,r.array);s=new BufferAttribute(e,r.itemSize,r.normalized)}void 0!==r.name&&(s.name=r.name);i.push(s)}r.morphAttributes[t]=i}const o=e.data.morphTargetsRelative;o&&(r.morphTargetsRelative=true);const l=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==l)for(let e=0,t=l.length;e!==t;++e){const t=l[e];r.addGroup(t.start,t.count,t.materialIndex)}const c=e.data.boundingSphere;if(void 0!==c){const e=new Vector3;void 0!==c.center&&e.fromArray(c.center);r.boundingSphere=new Sphere(e,c.radius)}e.name&&(r.name=e.name);e.userData&&(r.userData=e.userData);return r}}class ObjectLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const a=new FileLoader(this.manager);a.setPath(this.path);a.setRequestHeader(this.requestHeader);a.setWithCredentials(this.withCredentials);a.load(e,(function(n){let s=null;try{s=JSON.parse(n)}catch(t){void 0!==r&&r(t);console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message);return}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?i.parse(s,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,r)}async loadAsync(e,t){const n=this;const r=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const i=new FileLoader(this.manager);i.setPath(this.path);i.setRequestHeader(this.requestHeader);i.setWithCredentials(this.withCredentials);const s=await i.loadAsync(e,t);const a=JSON.parse(s);const o=a.metadata;if(void 0===o||void 0===o.type||"geometry"===o.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(a)}parse(e,t){const n=this.parseAnimations(e.animations);const r=this.parseShapes(e.shapes);const i=this.parseGeometries(e.geometries,r);const s=this.parseImages(e.images,(function(){void 0!==t&&t(l)}));const a=this.parseTextures(e.textures,s);const o=this.parseMaterials(e.materials,a);const l=this.parseObject(e.object,i,o,a,n);const c=this.parseSkeletons(e.skeletons,l);this.bindSkeletons(l,c);if(void 0!==t){let e=false;for(const t in s)if(s[t]instanceof HTMLImageElement){e=true;break}false===e&&t(l)}return l}async parseAsync(e){const t=this.parseAnimations(e.animations);const n=this.parseShapes(e.shapes);const r=this.parseGeometries(e.geometries,n);const i=await this.parseImagesAsync(e.images);const s=this.parseTextures(e.textures,i);const a=this.parseMaterials(e.materials,s);const o=this.parseObject(e.object,r,a,s,t);const l=this.parseSkeletons(e.skeletons,o);this.bindSkeletons(o,l);return o}parseShapes(e){const t={};if(void 0!==e)for(let n=0,r=e.length;n<r;n++){const r=(new Shape).fromJSON(e[n]);t[r.uuid]=r}return t}parseSkeletons(e,t){const n={};const r={};t.traverse((function(e){e.isBone&&(r[e.uuid]=e)}));if(void 0!==e)for(let t=0,i=e.length;t<i;t++){const i=(new Skeleton).fromJSON(e[t],r);n[i.uuid]=i}return n}parseGeometries(e,t){const n={};if(void 0!==e){const r=new BufferGeometryLoader;for(let i=0,s=e.length;i<s;i++){let s;const a=e[i];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Pl?s=Pl[a.type].fromJSON(a,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid;void 0!==a.name&&(s.name=a.name);true===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData);n[a.uuid]=s}}return n}parseMaterials(e,t){const n={};const r={};if(void 0!==e){const i=new MaterialLoader;i.setTextures(t);for(let t=0,s=e.length;t<s;t++){const s=e[t];if("MultiMaterial"===s.type){const e=[];for(let t=0;t<s.materials.length;t++){const r=s.materials[t];void 0===n[r.uuid]&&(n[r.uuid]=i.parse(r));e.push(n[r.uuid])}r[s.uuid]=e}else{void 0===n[s.uuid]&&(n[s.uuid]=i.parse(s));r[s.uuid]=n[s.uuid]}}}return r}parseAnimations(e){const t={};if(void 0!==e)for(let n=0;n<e.length;n++){const r=e[n];const i=AnimationClip.parse(r);t[i.uuid]=i}return t}parseImages(e,t){const n=this;const r={};let i;function loadImage(e){n.manager.itemStart(e);return i.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e);n.manager.itemEnd(e)}))}function deserializeImage(e){if("string"===typeof e){const t=e;const r=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t;return loadImage(r)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const n=new LoadingManager(t);i=new ImageLoader(n);i.setCrossOrigin(this.crossOrigin);for(let t=0,n=e.length;t<n;t++){const n=e[t];const i=n.url;if(Array.isArray(i)){r[n.uuid]=[];for(let e=0,t=i.length;e<t;e++){const t=i[e];const s=deserializeImage(t);null!==s&&(s instanceof HTMLImageElement?r[n.uuid].push(s):r[n.uuid].push(new DataTexture(s.data,s.width,s.height)))}}else{const e=deserializeImage(n.url);null!==e&&(r[n.uuid]=e)}}}return r}async parseImagesAsync(e){const t=this;const n={};let r;async function deserializeImage(e){if("string"===typeof e){const n=e;const i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:t.resourcePath+n;return await r.loadAsync(i)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){r=new ImageLoader(this.manager);r.setCrossOrigin(this.crossOrigin);for(let t=0,r=e.length;t<r;t++){const r=e[t];const i=r.url;if(Array.isArray(i)){n[r.uuid]=[];for(let e=0,t=i.length;e<t;e++){const t=i[e];const s=await deserializeImage(t);null!==s&&(s instanceof HTMLImageElement?n[r.uuid].push(s):n[r.uuid].push(new DataTexture(s.data,s.width,s.height)))}}else{const e=await deserializeImage(r.url);null!==e&&(n[r.uuid]=e)}}}return n}parseTextures(e,t){function parseConstant(e,t){if("number"===typeof e)return e;console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e);return t[e]}const n={};if(void 0!==e)for(let r=0,i=e.length;r<i;r++){const i=e[r];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid);void 0===t[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);let s;const a=t[i.image];if(Array.isArray(a)){s=new CubeTexture(a);6===a.length&&(s.needsUpdate=true)}else{s=a&&a.data?new DataTexture(a.data,a.width,a.height):new Texture(a);a&&(s.needsUpdate=true)}s.uuid=i.uuid;void 0!==i.name&&(s.name=i.name);void 0!==i.mapping&&(s.mapping=parseConstant(i.mapping,kl));void 0!==i.offset&&s.offset.fromArray(i.offset);void 0!==i.repeat&&s.repeat.fromArray(i.repeat);void 0!==i.center&&s.center.fromArray(i.center);void 0!==i.rotation&&(s.rotation=i.rotation);if(void 0!==i.wrap){s.wrapS=parseConstant(i.wrap[0],Wl);s.wrapT=parseConstant(i.wrap[1],Wl)}void 0!==i.format&&(s.format=i.format);void 0!==i.type&&(s.type=i.type);void 0!==i.encoding&&(s.encoding=i.encoding);void 0!==i.minFilter&&(s.minFilter=parseConstant(i.minFilter,jl));void 0!==i.magFilter&&(s.magFilter=parseConstant(i.magFilter,jl));void 0!==i.anisotropy&&(s.anisotropy=i.anisotropy);void 0!==i.flipY&&(s.flipY=i.flipY);void 0!==i.premultiplyAlpha&&(s.premultiplyAlpha=i.premultiplyAlpha);void 0!==i.unpackAlignment&&(s.unpackAlignment=i.unpackAlignment);void 0!==i.userData&&(s.userData=i.userData);n[i.uuid]=s}return n}parseObject(e,t,n,r,i){let s;function getGeometry(e){void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e);return t[e]}function getMaterial(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let r=0,i=e.length;r<i;r++){const i=e[r];void 0===n[i]&&console.warn("THREE.ObjectLoader: Undefined material",i);t.push(n[i])}return t}void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e);return n[e]}}function getTexture(e){void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e);return r[e]}let a,o;switch(e.type){case"Scene":s=new Scene;void 0!==e.background&&(Number.isInteger(e.background)?s.background=new Color(e.background):s.background=getTexture(e.background));void 0!==e.environment&&(s.environment=getTexture(e.environment));void 0!==e.fog&&("Fog"===e.fog.type?s.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(s.fog=new FogExp2(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far);void 0!==e.focus&&(s.focus=e.focus);void 0!==e.zoom&&(s.zoom=e.zoom);void 0!==e.filmGauge&&(s.filmGauge=e.filmGauge);void 0!==e.filmOffset&&(s.filmOffset=e.filmOffset);void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far);void 0!==e.zoom&&(s.zoom=e.zoom);void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":s=new DirectionalLight(e.color,e.intensity);break;case"PointLight":s=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=(new LightProbe).fromJSON(e);break;case"SkinnedMesh":a=getGeometry(e.geometry);o=getMaterial(e.material);s=new SkinnedMesh(a,o);void 0!==e.bindMode&&(s.bindMode=e.bindMode);void 0!==e.bindMatrix&&s.bindMatrix.fromArray(e.bindMatrix);void 0!==e.skeleton&&(s.skeleton=e.skeleton);break;case"Mesh":a=getGeometry(e.geometry);o=getMaterial(e.material);s=new Mesh(a,o);break;case"InstancedMesh":a=getGeometry(e.geometry);o=getMaterial(e.material);const t=e.count;const n=e.instanceMatrix;const r=e.instanceColor;s=new InstancedMesh(a,o,t);s.instanceMatrix=new InstancedBufferAttribute(new Float32Array(n.array),16);void 0!==r&&(s.instanceColor=new InstancedBufferAttribute(new Float32Array(r.array),r.itemSize));break;case"LOD":s=new LOD;break;case"Line":s=new Line(getGeometry(e.geometry),getMaterial(e.material));break;case"LineLoop":s=new LineLoop(getGeometry(e.geometry),getMaterial(e.material));break;case"LineSegments":s=new LineSegments(getGeometry(e.geometry),getMaterial(e.material));break;case"PointCloud":case"Points":s=new Points(getGeometry(e.geometry),getMaterial(e.material));break;case"Sprite":s=new Sprite(getMaterial(e.material));break;case"Group":s=new Group;break;case"Bone":s=new Bone;break;default:s=new Object3D}s.uuid=e.uuid;void 0!==e.name&&(s.name=e.name);if(void 0!==e.matrix){s.matrix.fromArray(e.matrix);void 0!==e.matrixAutoUpdate&&(s.matrixAutoUpdate=e.matrixAutoUpdate);s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)}else{void 0!==e.position&&s.position.fromArray(e.position);void 0!==e.rotation&&s.rotation.fromArray(e.rotation);void 0!==e.quaternion&&s.quaternion.fromArray(e.quaternion);void 0!==e.scale&&s.scale.fromArray(e.scale)}void 0!==e.castShadow&&(s.castShadow=e.castShadow);void 0!==e.receiveShadow&&(s.receiveShadow=e.receiveShadow);if(e.shadow){void 0!==e.shadow.bias&&(s.shadow.bias=e.shadow.bias);void 0!==e.shadow.normalBias&&(s.shadow.normalBias=e.shadow.normalBias);void 0!==e.shadow.radius&&(s.shadow.radius=e.shadow.radius);void 0!==e.shadow.mapSize&&s.shadow.mapSize.fromArray(e.shadow.mapSize);void 0!==e.shadow.camera&&(s.shadow.camera=this.parseObject(e.shadow.camera))}void 0!==e.visible&&(s.visible=e.visible);void 0!==e.frustumCulled&&(s.frustumCulled=e.frustumCulled);void 0!==e.renderOrder&&(s.renderOrder=e.renderOrder);void 0!==e.userData&&(s.userData=e.userData);void 0!==e.layers&&(s.layers.mask=e.layers);if(void 0!==e.children){const a=e.children;for(let e=0;e<a.length;e++)s.add(this.parseObject(a[e],t,n,r,i))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const n=t[e];s.animations.push(i[n])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(s.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e];const r=s.getObjectByProperty("uuid",n.object);void 0!==r&&s.addLevel(r,n.distance)}}return s}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(true===e.isSkinnedMesh&&void 0!==e.skeleton){const n=t[e.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(n,e.bindMatrix)}}))}setTexturePath(e){console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");return this.setResourcePath(e)}}const kl={UVMapping:ne,CubeReflectionMapping:re,CubeRefractionMapping:ie,EquirectangularReflectionMapping:se,EquirectangularRefractionMapping:ae,CubeUVReflectionMapping:oe,CubeUVRefractionMapping:le};const Wl={RepeatWrapping:ce,ClampToEdgeWrapping:ue,MirroredRepeatWrapping:he};const jl={NearestFilter:de,NearestMipmapNearestFilter:pe,NearestMipmapLinearFilter:me,LinearFilter:ye,LinearMipmapNearestFilter:ve,LinearMipmapLinearFilter:be};class ImageBitmapLoader extends Loader{constructor(e){super(e);"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported.");this.options={premultiplyAlpha:"none"}}setOptions(e){this.options=e;return this}load(e,t,n,r){void 0===e&&(e="");void 0!==this.path&&(e=this.path+e);e=this.manager.resolveURL(e);const i=this;const s=Bl.get(e);if(void 0!==s){i.manager.itemStart(e);setTimeout((function(){t&&t(s);i.manager.itemEnd(e)}),0);return s}const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include";a.headers=this.requestHeader;fetch(e,a).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(n){Bl.add(e,n);t&&t(n);i.manager.itemEnd(e)})).catch((function(t){r&&r(t);i.manager.itemError(e);i.manager.itemEnd(e)}));i.manager.itemStart(e)}}ImageBitmapLoader.prototype.isImageBitmapLoader=true;let ql;const Xl={getContext:function(){void 0===ql&&(ql=new(window.AudioContext||window.webkitAudioContext));return ql},setContext:function(e){ql=e}};class AudioLoader extends Loader{constructor(e){super(e)}load(e,t,n,r){const i=this;const s=new FileLoader(this.manager);s.setResponseType("arraybuffer");s.setPath(this.path);s.setRequestHeader(this.requestHeader);s.setWithCredentials(this.withCredentials);s.load(e,(function(n){try{const e=n.slice(0);const r=Xl.getContext();r.decodeAudioData(e,(function(e){t(e)}))}catch(t){r?r(t):console.error(t);i.manager.itemError(e)}}),n,r)}}class HemisphereLightProbe extends LightProbe{constructor(e,t,n=1){super(void 0,n);const r=(new Color).set(e);const i=(new Color).set(t);const s=new Vector3(r.r,r.g,r.b);const a=new Vector3(i.r,i.g,i.b);const o=Math.sqrt(Math.PI);const l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o);this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}HemisphereLightProbe.prototype.isHemisphereLightProbe=true;class AmbientLightProbe extends LightProbe{constructor(e,t=1){super(void 0,t);const n=(new Color).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}AmbientLightProbe.prototype.isAmbientLightProbe=true;const Jl=new Matrix4;const Yl=new Matrix4;const Zl=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera";this.aspect=1;this.eyeSep=.064;this.cameraL=new PerspectiveCamera;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;const n=t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep;if(n){t.focus=e.focus;t.fov=e.fov;t.aspect=e.aspect*this.aspect;t.near=e.near;t.far=e.far;t.zoom=e.zoom;t.eyeSep=this.eyeSep;Zl.copy(e.projectionMatrix);const n=t.eyeSep/2;const r=n*t.near/t.focus;const i=t.near*Math.tan(Cn*t.fov*.5)/t.zoom;let s,a;Yl.elements[12]=-n;Jl.elements[12]=n;s=-i*t.aspect+r;a=i*t.aspect+r;Zl.elements[0]=2*t.near/(a-s);Zl.elements[8]=(a+s)/(a-s);this.cameraL.projectionMatrix.copy(Zl);s=-i*t.aspect-r;a=i*t.aspect-r;Zl.elements[0]=2*t.near/(a-s);Zl.elements[8]=(a+s)/(a-s);this.cameraR.projectionMatrix.copy(Zl)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Yl);this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Jl)}}class Clock{constructor(e=true){this.autoStart=e;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false}start(){this.startTime=now();this.oldTime=this.startTime;this.elapsedTime=0;this.running=true}stop(){this.getElapsedTime();this.running=false;this.autoStart=false}getElapsedTime(){this.getDelta();return this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running){this.start();return 0}if(this.running){const t=now();e=(t-this.oldTime)/1e3;this.oldTime=t;this.elapsedTime+=e}return e}}function now(){return("undefined"===typeof performance?Date:performance).now()}const Ql=new Vector3;const Kl=new Quaternion;const $l=new Vector3;const ec=new Vector3;class AudioListener extends Object3D{constructor(){super();this.type="AudioListener";this.context=Xl.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;this.timeDelta=0;this._clock=new Clock}getInput(){return this.gain}removeFilter(){if(null!==this.filter){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null}return this}getFilter(){return this.filter}setFilter(e){if(null!==this.filter){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination)}else this.gain.disconnect(this.context.destination);this.filter=e;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01);return this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener;const n=this.up;this.timeDelta=this._clock.getDelta();this.matrixWorld.decompose(Ql,Kl,$l);ec.set(0,0,-1).applyQuaternion(Kl);if(t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Ql.x,e);t.positionY.linearRampToValueAtTime(Ql.y,e);t.positionZ.linearRampToValueAtTime(Ql.z,e);t.forwardX.linearRampToValueAtTime(ec.x,e);t.forwardY.linearRampToValueAtTime(ec.y,e);t.forwardZ.linearRampToValueAtTime(ec.z,e);t.upX.linearRampToValueAtTime(n.x,e);t.upY.linearRampToValueAtTime(n.y,e);t.upZ.linearRampToValueAtTime(n.z,e)}else{t.setPosition(Ql.x,Ql.y,Ql.z);t.setOrientation(ec.x,ec.y,ec.z,n.x,n.y,n.z)}}}class Audio extends Object3D{constructor(e){super();this.type="Audio";this.listener=e;this.context=e.context;this.gain=this.context.createGain();this.gain.connect(e.getInput());this.autoplay=false;this.buffer=null;this.detune=0;this.loop=false;this.loopStart=0;this.loopEnd=0;this.offset=0;this.duration=void 0;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.source=null;this.sourceType="empty";this._startedAt=0;this._progress=0;this._connected=false;this.filters=[]}getOutput(){return this.gain}setNodeSource(e){this.hasPlaybackControl=false;this.sourceType="audioNode";this.source=e;this.connect();return this}setMediaElementSource(e){this.hasPlaybackControl=false;this.sourceType="mediaNode";this.source=this.context.createMediaElementSource(e);this.connect();return this}setMediaStreamSource(e){this.hasPlaybackControl=false;this.sourceType="mediaStreamNode";this.source=this.context.createMediaStreamSource(e);this.connect();return this}setBuffer(e){this.buffer=e;this.sourceType="buffer";this.autoplay&&this.play();return this}play(e=0){if(true===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(false===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();t.buffer=this.buffer;t.loop=this.loop;t.loopStart=this.loopStart;t.loopEnd=this.loopEnd;t.onended=this.onEnded.bind(this);t.start(this._startedAt,this._progress+this.offset,this.duration);this.isPlaying=true;this.source=t;this.setDetune(this.detune);this.setPlaybackRate(this.playbackRate);return this.connect()}pause(){if(false!==this.hasPlaybackControl){if(true===this.isPlaying){this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate;true===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration));this.source.stop();this.source.onended=null;this.isPlaying=false}return this}console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(false!==this.hasPlaybackControl){this._progress=0;this.source.stop();this.source.onended=null;this.isPlaying=false;return this}console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());this._connected=true;return this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());this._connected=false;return this}getFilters(){return this.filters}setFilters(e){e||(e=[]);if(true===this._connected){this.disconnect();this.filters=e.slice();this.connect()}else this.filters=e.slice();return this}setDetune(e){this.detune=e;if(void 0!==this.source.detune){true===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01);return this}}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(false!==this.hasPlaybackControl){this.playbackRate=e;true===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01);return this}console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=false}getLoop(){if(false===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return false}return this.loop}setLoop(e){if(false!==this.hasPlaybackControl){this.loop=e;true===this.isPlaying&&(this.source.loop=this.loop);return this}console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){this.loopStart=e;return this}setLoopEnd(e){this.loopEnd=e;return this}getVolume(){return this.gain.gain.value}setVolume(e){this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01);return this}}const tc=new Vector3;const nc=new Quaternion;const rc=new Vector3;const ic=new Vector3;class PositionalAudio extends Audio{constructor(e){super(e);this.panner=this.context.createPanner();this.panner.panningModel="HRTF";this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){this.panner.refDistance=e;return this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){this.panner.rolloffFactor=e;return this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){this.panner.distanceModel=e;return this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){this.panner.maxDistance=e;return this}setDirectionalCone(e,t,n){this.panner.coneInnerAngle=e;this.panner.coneOuterAngle=t;this.panner.coneOuterGain=n;return this}updateMatrixWorld(e){super.updateMatrixWorld(e);if(true===this.hasPlaybackControl&&false===this.isPlaying)return;this.matrixWorld.decompose(tc,nc,rc);ic.set(0,0,1).applyQuaternion(nc);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(tc.x,e);t.positionY.linearRampToValueAtTime(tc.y,e);t.positionZ.linearRampToValueAtTime(tc.z,e);t.orientationX.linearRampToValueAtTime(ic.x,e);t.orientationY.linearRampToValueAtTime(ic.y,e);t.orientationZ.linearRampToValueAtTime(ic.z,e)}else{t.setPosition(tc.x,tc.y,tc.z);t.setOrientation(ic.x,ic.y,ic.z)}}}class AudioAnalyser{constructor(e,t=2048){this.analyser=e.context.createAnalyser();this.analyser.fftSize=t;this.data=new Uint8Array(this.analyser.frequencyBinCount);e.getOutput().connect(this.analyser)}getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class PropertyMixer{constructor(e,t,n){this.binding=e;this.valueSize=n;let r,i,s;switch(t){case"quaternion":r=this._slerp;i=this._slerpAdditive;s=this._setAdditiveIdentityQuaternion;this.buffer=new Float64Array(6*n);this._workIndex=5;break;case"string":case"bool":r=this._select;i=this._select;s=this._setAdditiveIdentityOther;this.buffer=new Array(5*n);break;default:r=this._lerp;i=this._lerpAdditive;s=this._setAdditiveIdentityNumeric;this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r;this._mixBufferRegionAdditive=i;this._setIdentity=s;this._origIndex=3;this._addIndex=4;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;this.useCount=0;this.referenceCount=0}accumulate(e,t){const n=this.buffer,r=this.valueSize,i=e*r+r;let s=this.cumulativeWeight;if(0===s){for(let e=0;e!==r;++e)n[i+e]=n[e];s=t}else{s+=t;const e=t/s;this._mixBufferRegion(n,i,0,e,r)}this.cumulativeWeight=s}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity();this._mixBufferRegionAdditive(t,r,0,e,n);this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,r=e*t+t,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;if(i<1){const e=t*this._origIndex;this._mixBufferRegion(n,r,e,1-i,t)}s>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let e=t,i=t+t;e!==i;++e)if(n[e]!==n[e+t]){a.setValue(n,r);break}}saveOriginalState(){const e=this.binding;const t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let e=n,i=r;e!==i;++e)t[e]=t[r+e%n];this._setIdentity();this.cumulativeWeight=0;this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize;const t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric();this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize;const t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,r,i){if(r>=.5)for(let r=0;r!==i;++r)e[t+r]=e[n+r]}_slerp(e,t,n,r){Quaternion.slerpFlat(e,t,e,t,e,n,r)}_slerpAdditive(e,t,n,r,i){const s=this._workIndex*i;Quaternion.multiplyQuaternionsFlat(e,s,e,t,e,n);Quaternion.slerpFlat(e,t,e,t,e,s,r)}_lerp(e,t,n,r,i){const s=1-r;for(let a=0;a!==i;++a){const i=t+a;e[i]=e[i]*s+e[n+a]*r}}_lerpAdditive(e,t,n,r,i){for(let s=0;s!==i;++s){const i=t+s;e[i]=e[i]+e[n+s]*r}}}const sc="\\[\\]\\.:\\/";const ac=new RegExp("["+sc+"]","g");const oc="[^"+sc+"]";const lc="[^"+sc.replace("\\.","")+"]";const cc=/((?:WC+[\/:])*)/.source.replace("WC",oc);const uc=/(WCOD+)?/.source.replace("WCOD",lc);const hc=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",oc);const dc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",oc);const pc=new RegExp("^"+cc+uc+hc+dc+"$");const fc=["material","materials","bones"];class Composite{constructor(e,t,n){const r=n||PropertyBinding.parseTrackName(t);this._targetGroup=e;this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class PropertyBinding{constructor(e,t,n){this.path=t;this.parsedPath=n||PropertyBinding.parseTrackName(t);this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName)||e;this.rootNode=e;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,t,n):new PropertyBinding(e,t,n)}
/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(ac,"")}static parseTrackName(e){const t=pc.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]};const r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const e=n.nodeName.substring(r+1);if(-1!==fc.indexOf(e)){n.nodeName=n.nodeName.substring(0,r);n.objectName=e}}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const searchNodeSubtree=function(e){for(let n=0;n<e.length;n++){const r=e[n];if(r.name===t||r.uuid===t)return r;const i=searchNodeSubtree(r.children);if(i)return i}return null};const n=searchNodeSubtree(e.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t];this.targetObject.needsUpdate=true}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t];this.targetObject.matrixWorldNeedsUpdate=true}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.needsUpdate=true}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=true}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t];this.targetObject.needsUpdate=true}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t];this.targetObject.matrixWorldNeedsUpdate=true}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t);this.targetObject.needsUpdate=true}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t);this.targetObject.matrixWorldNeedsUpdate=true}_getValue_unbound(e,t){this.bind();this.getValue(e,t)}_setValue_unbound(e,t){this.bind();this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath;const n=t.objectName;const r=t.propertyName;let i=t.propertyIndex;if(!e){e=PropertyBinding.findNode(this.rootNode,t.nodeName)||this.rootNode;this.node=e}this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let r=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===r){r=t;break}break;default:if(void 0===e[n]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(void 0!==r){if(void 0===e[r]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[r]}}const s=e[r];if(void 0===s){const n=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e;void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.isBufferGeometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==e.morphTargetDictionary[i]&&(i=e.morphTargetDictionary[i])}o=this.BindingType.ArrayElement;this.resolvedProperty=s;this.propertyIndex=i}else if(void 0!==s.fromArray&&void 0!==s.toArray){o=this.BindingType.HasFromToArray;this.resolvedProperty=s}else if(Array.isArray(s)){o=this.BindingType.EntireArray;this.resolvedProperty=s}else this.propertyName=r;this.getValue=this.GetterByBindingType[o];this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.uuid=generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,n=arguments.length;t!==n;++t)e[arguments[t].uuid]=t;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let a,o=e.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let d=t[h];if(void 0===d){d=o++;t[h]=d;e.push(u);for(let e=0,t=s;e!==t;++e)i[e].push(new PropertyBinding(u,n[e],r[e]))}else if(d<l){a=e[d];const o=--l,c=e[o];t[c.uuid]=d;e[d]=c;t[h]=o;e[o]=u;for(let e=0,t=s;e!==t;++e){const t=i[e],s=t[o];let a=t[d];t[d]=s;void 0===a&&(a=new PropertyBinding(u,n[e],r[e]));t[o]=a}}else e[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=t[o];if(void 0!==l&&l>=i){const s=i++,c=e[s];t[c.uuid]=l;e[l]=c;t[o]=s;e[s]=a;for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[s],i=t[l];t[l]=r;t[s]=i}}}this.nCachedObjects_=i}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,s=e.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a],l=o.uuid,c=t[l];if(void 0!==c){delete t[l];if(c<i){const a=--i,o=e[a],l=--s,u=e[l];t[o.uuid]=c;e[c]=o;t[u.uuid]=a;e[a]=u;e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[a],i=t[l];t[c]=r;t[a]=i;t.pop()}}else{const i=--s,a=e[i];i>0&&(t[a.uuid]=c);e[c]=a;e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e];t[c]=t[i];t.pop()}}}}this.nCachedObjects_=i}subscribe_(e,t){const n=this._bindingsIndicesByPath;let r=n[e];const i=this._bindings;if(void 0!==r)return i[r];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,u=new Array(l);r=i.length;n[e]=r;s.push(e);a.push(t);i.push(u);for(let n=c,r=o.length;n!==r;++n){const r=o[n];u[n]=new PropertyBinding(r,e,t)}return u}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const r=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a],l=e[a];t[l]=n;s[n]=o;s.pop();i[n]=i[a];i.pop();r[n]=r[a];r.pop()}}}AnimationObjectGroup.prototype.isAnimationObjectGroup=true;class AnimationAction{constructor(e,t,n=null,r=t.blendMode){this._mixer=e;this._clip=t;this._localRoot=n;this.blendMode=r;const i=t.tracks,s=i.length,a=new Array(s);const o={endingStart:Gt,endingEnd:Gt};for(let e=0;e!==s;++e){const t=i[e].createInterpolant(null);a[e]=t;t.settings=o}this._interpolantSettings=o;this._interpolants=a;this._propertyBindings=new Array(s);this._cacheIndex=null;this._byClipCacheIndex=null;this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=Bt;this._loopCount=-1;this._startTime=null;this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;this.paused=false;this.enabled=true;this.clampWhenFinished=false;this.zeroSlopeAtStart=true;this.zeroSlopeAtEnd=true}play(){this._mixer._activateAction(this);return this}stop(){this._mixer._deactivateAction(this);return this.reset()}reset(){this.paused=false;this.enabled=true;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){this._startTime=e;return this}setLoop(e,t){this.loop=e;this.repetitions=t;return this}setEffectiveWeight(e){this.weight=e;this._effectiveWeight=this.enabled?e:0;return this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){e.fadeOut(t);this.fadeIn(t);if(n){const n=this._clip.duration,r=e._clip.duration,i=r/n,s=n/r;e.warp(1,i,t);this.warp(s,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;if(null!==e){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(e)}return this}setEffectiveTimeScale(e){this.timeScale=e;this._effectiveTimeScale=this.paused?0:e;return this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){this.timeScale=this._clip.duration/e;return this.stopWarping()}syncWith(e){this.time=e.time;this.timeScale=e.timeScale;return this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,i=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;if(null===a){a=r._lendControlInterpolant();this._timeScaleInterpolant=a}const o=a.parameterPositions,l=a.sampleValues;o[0]=i;o[1]=i+n;l[0]=e/s;l[1]=t/s;return this}stopWarping(){const e=this._timeScaleInterpolant;if(null!==e){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(e)}return this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(null!==i){const r=(e-i)*n;if(r<0||0===n)return;this._startTime=null;t=n*r}t*=this._updateTimeScale(e);const s=this._updateTime(t);const a=this._updateWeight(e);if(a>0){const e=this._interpolants;const t=this._propertyBindings;switch(this.blendMode){case kt:for(let n=0,r=e.length;n!==r;++n){e[n].evaluate(s);t[n].accumulateAdditive(a)}break;case Ht:default:for(let n=0,i=e.length;n!==i;++n){e[n].evaluate(s);t[n].accumulate(r,a)}}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(e)[0];t*=r;if(e>n.parameterPositions[1]){this.stopFading();0===r&&(this.enabled=false)}}}this._effectiveWeight=t;return t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){const r=n.evaluate(e)[0];t*=r;if(e>n.parameterPositions[1]){this.stopWarping();0===t?this.paused=true:this.timeScale=t}}}this._effectiveTimeScale=t;return t}_updateTime(e){const t=this._clip.duration;const n=this.loop;let r=this.time+e;let i=this._loopCount;const s=n===Vt;if(0===e)return-1===i?r:s&&1===(1&i)?t-r:r;if(n===Dt){if(-1===i){this._loopCount=0;this._setEndings(true,true,false)}e:{if(r>=t)r=t;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=true:this.enabled=false;this.time=r;this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===i)if(e>=0){i=0;this._setEndings(true,0===this.repetitions,s)}else this._setEndings(0===this.repetitions,true,s);if(r>=t||r<0){const n=Math.floor(r/t);r-=t*n;i+=Math.abs(n);const a=this.repetitions-i;if(a<=0){this.clampWhenFinished?this.paused=true:this.enabled=false;r=e>0?t:0;this.time=r;this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1})}else{if(1===a){const t=e<0;this._setEndings(t,!t,s)}else this._setEndings(false,false,s);this._loopCount=i;this.time=r;this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(s&&1===(1&i))return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;if(n){r.endingStart=Ft;r.endingEnd=Ft}else{r.endingStart=e?this.zeroSlopeAtStart?Ft:Gt:Ot;r.endingEnd=t?this.zeroSlopeAtEnd?Ft:Gt:Ot}}_scheduleFading(e,t,n){const r=this._mixer,i=r.time;let s=this._weightInterpolant;if(null===s){s=r._lendControlInterpolant();this._weightInterpolant=s}const a=s.parameterPositions,o=s.sampleValues;a[0]=i;o[0]=t;a[1]=i+e;o[1]=n;return this}}class AnimationMixer extends EventDispatcher{constructor(e){super();this._root=e;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,i=r.length,s=e._propertyBindings,a=e._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let c=l[o];if(void 0===c){c={};l[o]=c}for(let e=0;e!==i;++e){const i=r[e],l=i.name;let u=c[l];if(void 0!==u)s[e]=u;else{u=s[e];if(void 0!==u){if(null===u._cacheIndex){++u.referenceCount;this._addInactiveBinding(u,o,l)}continue}const r=t&&t._propertyBindings[e].binding.parsedPath;u=new PropertyMixer(PropertyBinding.create(n,l,r),i.ValueTypeName,i.getValueSize());++u.referenceCount;this._addInactiveBinding(u,o,l);s[e]=u}a[e].resultBuffer=u.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,r=this._actionsByClip[n];this._bindAction(e,r&&r.knownActions[0]);this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];if(0===n.useCount++){this._lendBinding(n);n.saveOriginalState()}}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];if(0===--n.useCount){n.restoreOriginalState();this._takeBackBinding(n)}}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,n){const r=this._actions,i=this._actionsByClip;let s=i[t];if(void 0===s){s={knownActions:[e],actionByRoot:{}};e._byClipCacheIndex=0;i[t]=s}else{const t=s.knownActions;e._byClipCacheIndex=t.length;t.push(e)}e._cacheIndex=r.length;r.push(e);s.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r;t[r]=n;t.pop();e._cacheIndex=null;const i=e._clip.uuid,s=this._actionsByClip,a=s[i],o=a.knownActions,l=o[o.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c;o[c]=l;o.pop();e._byClipCacheIndex=null;const u=a.actionByRoot,h=(e._localRoot||this._root).uuid;delete u[h];0===o.length&&delete s[i];this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0===--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,i=t[r];e._cacheIndex=r;t[r]=e;i._cacheIndex=n;t[n]=i}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,i=t[r];e._cacheIndex=r;t[r]=e;i._cacheIndex=n;t[n]=i}_addInactiveBinding(e,t,n){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[t];if(void 0===s){s={};r[t]=s}s[n]=e;e._cacheIndex=i.length;i.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,i=n.path,s=this._bindingsByRootAndName,a=s[r],o=t[t.length-1],l=e._cacheIndex;o._cacheIndex=l;t[l]=o;t.pop();delete a[i];0===Object.keys(a).length&&delete s[r]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,i=t[r];e._cacheIndex=r;t[r]=e;i._cacheIndex=n;t[n]=i}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,i=t[r];e._cacheIndex=r;t[r]=e;i._cacheIndex=n;t[n]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];if(void 0===n){n=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);n.__cacheIndex=t;e[t]=n}return n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,i=t[r];e.__cacheIndex=r;t[r]=e;i.__cacheIndex=n;t[n]=i}clipAction(e,t,n){const r=t||this._root,i=r.uuid;let s="string"===typeof e?AnimationClip.findByName(r,e):e;const a=null!==s?s.uuid:e;const o=this._actionsByClip[a];let l=null;void 0===n&&(n=null!==s?s.blendMode:Ht);if(void 0!==o){const e=o.actionByRoot[i];if(void 0!==e&&e.blendMode===n)return e;l=o.knownActions[0];null===s&&(s=l._clip)}if(null===s)return null;const c=new AnimationAction(this,s,t,n);this._bindAction(c,l);this._addInactiveAction(c,a,i);return c}existingAction(e,t){const n=t||this._root,r=n.uuid,i="string"===typeof e?AnimationClip.findByName(n,e):e,s=i?i.uuid:e,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,i=Math.sign(e),s=this._accuIndex^=1;for(let a=0;a!==n;++a){const n=t[a];n._update(r,e,i,s)}const a=this._bindings,o=this._nActiveBindings;for(let e=0;e!==o;++e)a[e].apply(s);return this}setTime(e){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,i=r[n];if(void 0!==i){const e=i.knownActions;for(let n=0,r=e.length;n!==r;++n){const r=e[n];this._deactivateAction(r);const i=r._cacheIndex,s=t[t.length-1];r._cacheIndex=null;r._byClipCacheIndex=null;s._cacheIndex=i;t[i]=s;t.pop();this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const e in n){const r=n[e].actionByRoot,i=r[t];if(void 0!==i){this._deactivateAction(i);this._removeInactiveAction(i)}}const r=this._bindingsByRootAndName,i=r[t];if(void 0!==i)for(const e in i){const t=i[e];t.restoreOriginalState();this._removeInactiveBinding(t)}}uncacheAction(e,t){const n=this.existingAction(e,t);if(null!==n){this._deactivateAction(n);this._removeInactiveAction(n)}}}AnimationMixer.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Uniform{constructor(e){if("string"===typeof e){console.warn("THREE.Uniform: Type parameter is no longer needed.");e=arguments[1]}this.value=e}clone(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(e,t,n=1){super(e,t);this.meshPerAttribute=n}copy(e){super.copy(e);this.meshPerAttribute=e.meshPerAttribute;return this}clone(e){const t=super.clone(e);t.meshPerAttribute=this.meshPerAttribute;return t}toJSON(e){const t=super.toJSON(e);t.isInstancedInterleavedBuffer=true;t.meshPerAttribute=this.meshPerAttribute;return t}}InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer=true;class GLBufferAttribute{constructor(e,t,n,r,i){this.buffer=e;this.type=t;this.itemSize=n;this.elementSize=r;this.count=i;this.version=0}set needsUpdate(e){true===e&&this.version++}setBuffer(e){this.buffer=e;return this}setType(e,t){this.type=e;this.elementSize=t;return this}setItemSize(e){this.itemSize=e;return this}setCount(e){this.count=e;return this}}GLBufferAttribute.prototype.isGLBufferAttribute=true;class Raycaster{constructor(e,t,n=0,r=Infinity){this.ray=new Ray(e,t);this.near=n;this.far=r;this.camera=null;this.layers=new Layers;this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){if(t&&t.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(t.matrixWorld);this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize();this.camera=t}else if(t&&t.isOrthographicCamera){this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t);this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld);this.camera=t}else console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=true,n=[]){intersectObject(e,this,n,t);n.sort(ascSort);return n}intersectObjects(e,t=true,n=[]){for(let r=0,i=e.length;r<i;r++)intersectObject(e[r],this,n,t);n.sort(ascSort);return n}}function ascSort(e,t){return e.distance-t.distance}function intersectObject(e,t,n,r){e.layers.test(t.layers)&&e.raycast(t,n);if(true===r){const r=e.children;for(let e=0,i=r.length;e<i;e++)intersectObject(r[e],t,n,true)}}class Spherical{constructor(e=1,t=0,n=0){this.radius=e;this.phi=t;this.theta=n;return this}set(e,t,n){this.radius=e;this.phi=t;this.theta=n;return this}copy(e){this.radius=e.radius;this.phi=e.phi;this.theta=e.theta;return this}makeSafe(){const e=1e-6;this.phi=Math.max(e,Math.min(Math.PI-e,this.phi));return this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){this.radius=Math.sqrt(e*e+t*t+n*n);if(0===this.radius){this.theta=0;this.phi=0}else{this.theta=Math.atan2(e,n);this.phi=Math.acos(clamp(t/this.radius,-1,1))}return this}clone(){return(new this.constructor).copy(this)}}class Cylindrical{constructor(e=1,t=0,n=0){this.radius=e;this.theta=t;this.y=n;return this}set(e,t,n){this.radius=e;this.theta=t;this.y=n;return this}copy(e){this.radius=e.radius;this.theta=e.theta;this.y=e.y;return this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){this.radius=Math.sqrt(e*e+n*n);this.theta=Math.atan2(e,n);this.y=t;return this}clone(){return(new this.constructor).copy(this)}}const mc=new Vector2;class Box2{constructor(e=new Vector2(Infinity,Infinity),t=new Vector2(-Infinity,-Infinity)){this.min=e;this.max=t}set(e,t){this.min.copy(e);this.max.copy(t);return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=mc.copy(t).multiplyScalar(.5);this.min.copy(e).sub(n);this.max.copy(e).add(n);return this}clone(){return(new this.constructor).copy(this)}copy(e){this.min.copy(e.min);this.max.copy(e.max);return this}makeEmpty(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){this.min.min(e);this.max.max(e);return this}expandByVector(e){this.min.sub(e);this.max.add(e);return this}expandByScalar(e){this.min.addScalar(-e);this.max.addScalar(e);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){const t=mc.copy(e).clamp(this.min,this.max);return t.sub(e).length()}intersect(e){this.min.max(e.min);this.max.min(e.max);return this}union(e){this.min.min(e.min);this.max.max(e.max);return this}translate(e){this.min.add(e);this.max.add(e);return this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Box2.prototype.isBox2=true;const gc=new Vector3;const yc=new Vector3;class Line3{constructor(e=new Vector3,t=new Vector3){this.start=e;this.end=t}set(e,t){this.start.copy(e);this.end.copy(t);return this}copy(e){this.start.copy(e.start);this.end.copy(e.end);return this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){gc.subVectors(e,this.start);yc.subVectors(this.end,this.start);const n=yc.dot(yc);const r=yc.dot(gc);let i=r/n;t&&(i=clamp(i,0,1));return i}closestPointToPoint(e,t,n){const r=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(e){this.start.applyMatrix4(e);this.end.applyMatrix4(e);return this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const vc=new Vector3;class SpotLightHelper extends Object3D{constructor(e,t){super();this.light=e;this.light.updateMatrixWorld();this.matrix=e.matrixWorld;this.matrixAutoUpdate=false;this.color=t;const n=new BufferGeometry;const r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let e=0,t=1,n=32;e<n;e++,t++){const i=e/n*Math.PI*2;const s=t/n*Math.PI*2;r.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new Float32BufferAttribute(r,3));const i=new LineBasicMaterial({fog:false,toneMapped:false});this.cone=new LineSegments(n,i);this.add(this.cone);this.update()}dispose(){this.cone.geometry.dispose();this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3;const t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e);vc.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(vc);void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const xc=new Vector3;const bc=new Matrix4;const _c=new Matrix4;class SkeletonHelper extends LineSegments{constructor(e){const t=getBoneList(e);const n=new BufferGeometry;const r=[];const i=[];const s=new Color(0,0,1);const a=new Color(0,1,0);for(let e=0;e<t.length;e++){const n=t[e];if(n.parent&&n.parent.isBone){r.push(0,0,0);r.push(0,0,0);i.push(s.r,s.g,s.b);i.push(a.r,a.g,a.b)}}n.setAttribute("position",new Float32BufferAttribute(r,3));n.setAttribute("color",new Float32BufferAttribute(i,3));const o=new LineBasicMaterial({vertexColors:true,depthTest:false,depthWrite:false,toneMapped:false,transparent:true});super(n,o);this.type="SkeletonHelper";this.isSkeletonHelper=true;this.root=e;this.bones=t;this.matrix=e.matrixWorld;this.matrixAutoUpdate=false}updateMatrixWorld(e){const t=this.bones;const n=this.geometry;const r=n.getAttribute("position");_c.copy(this.root.matrixWorld).invert();for(let e=0,n=0;e<t.length;e++){const i=t[e];if(i.parent&&i.parent.isBone){bc.multiplyMatrices(_c,i.matrixWorld);xc.setFromMatrixPosition(bc);r.setXYZ(n,xc.x,xc.y,xc.z);bc.multiplyMatrices(_c,i.parent.matrixWorld);xc.setFromMatrixPosition(bc);r.setXYZ(n+1,xc.x,xc.y,xc.z);n+=2}}n.getAttribute("position").needsUpdate=true;super.updateMatrixWorld(e)}}function getBoneList(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,getBoneList(e.children[n]));return t}class PointLightHelper extends Mesh{constructor(e,t,n){const r=new SphereGeometry(t,4,2);const i=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});super(r,i);this.light=e;this.light.updateMatrixWorld();this.color=n;this.type="PointLightHelper";this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;this.update()}dispose(){this.geometry.dispose();this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Mc=new Vector3;const wc=new Color;const Sc=new Color;class HemisphereLightHelper extends Object3D{constructor(e,t,n){super();this.light=e;this.light.updateMatrixWorld();this.matrix=e.matrixWorld;this.matrixAutoUpdate=false;this.color=n;const r=new OctahedronGeometry(t);r.rotateY(.5*Math.PI);this.material=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});void 0===this.color&&(this.material.vertexColors=true);const i=r.getAttribute("position");const s=new Float32Array(3*i.count);r.setAttribute("color",new BufferAttribute(s,3));this.add(new Mesh(r,this.material));this.update()}dispose(){this.children[0].geometry.dispose();this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");wc.copy(this.light.color);Sc.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const r=e<n/2?wc:Sc;t.setXYZ(e,r.r,r.g,r.b)}t.needsUpdate=true}e.lookAt(Mc.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(e=10,t=10,n=4473924,r=8947848){n=new Color(n);r=new Color(r);const i=t/2;const s=e/t;const a=e/2;const o=[],l=[];for(let e=0,c=0,u=-a;e<=t;e++,u+=s){o.push(-a,0,u,a,0,u);o.push(u,0,-a,u,0,a);const t=e===i?n:r;t.toArray(l,c);c+=3;t.toArray(l,c);c+=3;t.toArray(l,c);c+=3;t.toArray(l,c);c+=3}const c=new BufferGeometry;c.setAttribute("position",new Float32BufferAttribute(o,3));c.setAttribute("color",new Float32BufferAttribute(l,3));const u=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(c,u);this.type="GridHelper"}}class PolarGridHelper extends LineSegments{constructor(e=10,t=16,n=8,r=64,i=4473924,s=8947848){i=new Color(i);s=new Color(s);const a=[];const o=[];for(let n=0;n<=t;n++){const r=n/t*(2*Math.PI);const l=Math.sin(r)*e;const c=Math.cos(r)*e;a.push(0,0,0);a.push(l,0,c);const u=1&n?i:s;o.push(u.r,u.g,u.b);o.push(u.r,u.g,u.b)}for(let t=0;t<=n;t++){const l=1&t?i:s;const c=e-e/n*t;for(let e=0;e<r;e++){let t=e/r*(2*Math.PI);let n=Math.sin(t)*c;let i=Math.cos(t)*c;a.push(n,0,i);o.push(l.r,l.g,l.b);t=(e+1)/r*(2*Math.PI);n=Math.sin(t)*c;i=Math.cos(t)*c;a.push(n,0,i);o.push(l.r,l.g,l.b)}}const l=new BufferGeometry;l.setAttribute("position",new Float32BufferAttribute(a,3));l.setAttribute("color",new Float32BufferAttribute(o,3));const c=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(l,c);this.type="PolarGridHelper"}}const Tc=new Vector3;const Ec=new Vector3;const Ac=new Vector3;class DirectionalLightHelper extends Object3D{constructor(e,t,n){super();this.light=e;this.light.updateMatrixWorld();this.matrix=e.matrixWorld;this.matrixAutoUpdate=false;this.color=n;void 0===t&&(t=1);let r=new BufferGeometry;r.setAttribute("position",new Float32BufferAttribute([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new LineBasicMaterial({fog:false,toneMapped:false});this.lightPlane=new Line(r,i);this.add(this.lightPlane);r=new BufferGeometry;r.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(r,i);this.add(this.targetLine);this.update()}dispose(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()}update(){Tc.setFromMatrixPosition(this.light.matrixWorld);Ec.setFromMatrixPosition(this.light.target.matrixWorld);Ac.subVectors(Ec,Tc);this.lightPlane.lookAt(Ec);if(void 0!==this.color){this.lightPlane.material.color.set(this.color);this.targetLine.material.color.set(this.color)}else{this.lightPlane.material.color.copy(this.light.color);this.targetLine.material.color.copy(this.light.color)}this.targetLine.lookAt(Ec);this.targetLine.scale.z=Ac.length()}}const Lc=new Vector3;const Cc=new Camera;class CameraHelper extends LineSegments{constructor(e){const t=new BufferGeometry;const n=new LineBasicMaterial({color:16777215,vertexColors:true,toneMapped:false});const r=[];const i=[];const s={};const a=new Color(16755200);const o=new Color(16711680);const l=new Color(43775);const c=new Color(16777215);const u=new Color(3355443);addLine("n1","n2",a);addLine("n2","n4",a);addLine("n4","n3",a);addLine("n3","n1",a);addLine("f1","f2",a);addLine("f2","f4",a);addLine("f4","f3",a);addLine("f3","f1",a);addLine("n1","f1",a);addLine("n2","f2",a);addLine("n3","f3",a);addLine("n4","f4",a);addLine("p","n1",o);addLine("p","n2",o);addLine("p","n3",o);addLine("p","n4",o);addLine("u1","u2",l);addLine("u2","u3",l);addLine("u3","u1",l);addLine("c","t",c);addLine("p","c",u);addLine("cn1","cn2",u);addLine("cn3","cn4",u);addLine("cf1","cf2",u);addLine("cf3","cf4",u);function addLine(e,t,n){addPoint(e,n);addPoint(t,n)}function addPoint(e,t){r.push(0,0,0);i.push(t.r,t.g,t.b);void 0===s[e]&&(s[e]=[]);s[e].push(r.length/3-1)}t.setAttribute("position",new Float32BufferAttribute(r,3));t.setAttribute("color",new Float32BufferAttribute(i,3));super(t,n);this.type="CameraHelper";this.camera=e;this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix();this.matrix=e.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=s;this.update()}update(){const e=this.geometry;const t=this.pointMap;const n=1,r=1;Cc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);setPoint("c",t,e,Cc,0,0,-1);setPoint("t",t,e,Cc,0,0,1);setPoint("n1",t,e,Cc,-n,-r,-1);setPoint("n2",t,e,Cc,n,-r,-1);setPoint("n3",t,e,Cc,-n,r,-1);setPoint("n4",t,e,Cc,n,r,-1);setPoint("f1",t,e,Cc,-n,-r,1);setPoint("f2",t,e,Cc,n,-r,1);setPoint("f3",t,e,Cc,-n,r,1);setPoint("f4",t,e,Cc,n,r,1);setPoint("u1",t,e,Cc,.7*n,1.1*r,-1);setPoint("u2",t,e,Cc,.7*-n,1.1*r,-1);setPoint("u3",t,e,Cc,0,2*r,-1);setPoint("cf1",t,e,Cc,-n,0,1);setPoint("cf2",t,e,Cc,n,0,1);setPoint("cf3",t,e,Cc,0,-r,1);setPoint("cf4",t,e,Cc,0,r,1);setPoint("cn1",t,e,Cc,-n,0,-1);setPoint("cn2",t,e,Cc,n,0,-1);setPoint("cn3",t,e,Cc,0,-r,-1);setPoint("cn4",t,e,Cc,0,r,-1);e.getAttribute("position").needsUpdate=true}dispose(){this.geometry.dispose();this.material.dispose()}}function setPoint(e,t,n,r,i,s,a){Lc.set(i,s,a).unproject(r);const o=t[e];if(void 0!==o){const e=n.getAttribute("position");for(let t=0,n=o.length;t<n;t++)e.setXYZ(o[t],Lc.x,Lc.y,Lc.z)}}const Rc=new Box3;class BoxHelper extends LineSegments{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);const r=new Float32Array(24);const i=new BufferGeometry;i.setIndex(new BufferAttribute(n,1));i.setAttribute("position",new BufferAttribute(r,3));super(i,new LineBasicMaterial({color:t,toneMapped:false}));this.object=e;this.type="BoxHelper";this.matrixAutoUpdate=false;this.update()}update(e){void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments.");void 0!==this.object&&Rc.setFromObject(this.object);if(Rc.isEmpty())return;const t=Rc.min;const n=Rc.max;const r=this.geometry.attributes.position;const i=r.array;i[0]=n.x;i[1]=n.y;i[2]=n.z;i[3]=t.x;i[4]=n.y;i[5]=n.z;i[6]=t.x;i[7]=t.y;i[8]=n.z;i[9]=n.x;i[10]=t.y;i[11]=n.z;i[12]=n.x;i[13]=n.y;i[14]=t.z;i[15]=t.x;i[16]=n.y;i[17]=t.z;i[18]=t.x;i[19]=t.y;i[20]=t.z;i[21]=n.x;i[22]=t.y;i[23]=t.z;r.needsUpdate=true;this.geometry.computeBoundingSphere()}setFromObject(e){this.object=e;this.update();return this}copy(e){LineSegments.prototype.copy.call(this,e);this.object=e.object;return this}}class Box3Helper extends LineSegments{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);const r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];const i=new BufferGeometry;i.setIndex(new BufferAttribute(n,1));i.setAttribute("position",new Float32BufferAttribute(r,3));super(i,new LineBasicMaterial({color:t,toneMapped:false}));this.box=e;this.type="Box3Helper";this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;if(!t.isEmpty()){t.getCenter(this.position);t.getSize(this.scale);this.scale.multiplyScalar(.5);super.updateMatrixWorld(e)}}}class PlaneHelper extends Line{constructor(e,t=1,n=16776960){const r=n;const i=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];const s=new BufferGeometry;s.setAttribute("position",new Float32BufferAttribute(i,3));s.computeBoundingSphere();super(s,new LineBasicMaterial({color:r,toneMapped:false}));this.type="PlaneHelper";this.plane=e;this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];const o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute(a,3));o.computeBoundingSphere();this.add(new Mesh(o,new MeshBasicMaterial({color:r,opacity:.2,transparent:true,depthWrite:false,toneMapped:false})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8);this.scale.set(.5*this.size,.5*this.size,t);this.children[0].material.side=t<0?d:h;this.lookAt(this.plane.normal);super.updateMatrixWorld(e)}}const Pc=new Vector3;let Ic,Dc;class ArrowHelper extends Object3D{constructor(e=new Vector3(0,0,1),t=new Vector3(0,0,0),n=1,r=16776960,i=.2*n,s=.2*i){super();this.type="ArrowHelper";if(void 0===Ic){Ic=new BufferGeometry;Ic.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3));Dc=new CylinderGeometry(0,.5,1,5,1);Dc.translate(0,-.5,0)}this.position.copy(t);this.line=new Line(Ic,new LineBasicMaterial({color:r,toneMapped:false}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(Dc,new MeshBasicMaterial({color:r,toneMapped:false}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(e);this.setLength(n,i,s)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Pc.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Pc,t)}}setLength(e,t=.2*e,n=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1);this.line.updateMatrix();this.cone.scale.set(n,t,n);this.cone.position.y=e;this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e);this.cone.material.color.set(e)}copy(e){super.copy(e,false);this.line.copy(e.line);this.cone.copy(e.cone);return this}}class AxesHelper extends LineSegments{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e];const n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1];const r=new BufferGeometry;r.setAttribute("position",new Float32BufferAttribute(t,3));r.setAttribute("color",new Float32BufferAttribute(n,3));const i=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(r,i);this.type="AxesHelper"}setColors(e,t,n){const r=new Color;const i=this.geometry.attributes.color.array;r.set(e);r.toArray(i,0);r.toArray(i,3);r.set(t);r.toArray(i,6);r.toArray(i,9);r.set(n);r.toArray(i,12);r.toArray(i,15);this.geometry.attributes.color.needsUpdate=true;return this}dispose(){this.geometry.dispose();this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath";this.color=new Color;this.subPaths=[];this.currentPath=null}moveTo(e,t){this.currentPath=new Path;this.subPaths.push(this.currentPath);this.currentPath.moveTo(e,t);return this}lineTo(e,t){this.currentPath.lineTo(e,t);return this}quadraticCurveTo(e,t,n,r){this.currentPath.quadraticCurveTo(e,t,n,r);return this}bezierCurveTo(e,t,n,r,i,s){this.currentPath.bezierCurveTo(e,t,n,r,i,s);return this}splineThru(e){this.currentPath.splineThru(e);return this}toShapes(e,t){function toShapesNoHoles(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];const i=new Shape;i.curves=r.curves;t.push(i)}return t}function isPointInsidePolygon(e,t){const n=t.length;let r=false;for(let i=n-1,s=0;s<n;i=s++){let n=t[i];let a=t[s];let o=a.x-n.x;let l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0){n=t[s];o=-o;a=t[i];l=-l}if(e.y<n.y||e.y>a.y)continue;if(e.y===n.y){if(e.x===n.x)return true}else{const t=l*(e.x-n.x)-o*(e.y-n.y);if(0===t)return true;if(t<0)continue;r=!r}}else{if(e.y!==n.y)continue;if(a.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=a.x)return true}}return r}const n=ShapeUtils.isClockWise;const r=this.subPaths;if(0===r.length)return[];if(true===t)return toShapesNoHoles(r);let i,s,a;const o=[];if(1===r.length){s=r[0];a=new Shape;a.curves=s.curves;o.push(a);return o}let l=!n(r[0].getPoints());l=e?!l:l;const c=[];const u=[];let h=[];let d=0;let p;u[d]=void 0;h[d]=[];for(let t=0,a=r.length;t<a;t++){s=r[t];p=s.getPoints();i=n(p);i=e?!i:i;if(i){!l&&u[d]&&d++;u[d]={s:new Shape,p:p};u[d].s.curves=s.curves;l&&d++;h[d]=[]}else h[d].push({h:s,p:p[0]})}if(!u[0])return toShapesNoHoles(r);if(u.length>1){let e=false;const t=[];for(let e=0,t=u.length;e<t;e++)c[e]=[];for(let n=0,r=u.length;n<r;n++){const r=h[n];for(let i=0;i<r.length;i++){const s=r[i];let a=true;for(let r=0;r<u.length;r++)if(isPointInsidePolygon(s.p,u[r].p)){n!==r&&t.push({froms:n,tos:r,hole:i});if(a){a=false;c[r].push(s)}else e=true}a&&c[n].push(s)}}t.length>0&&(e||(h=c))}let f;for(let e=0,t=u.length;e<t;e++){a=u[e].s;o.push(a);f=h[e];for(let e=0,t=f.length;e<t;e++)a.holes.push(f[e].h)}return o}}const Bc=new Float32Array(1);const Vc=new Int32Array(Bc.buffer);class DataUtils{static toHalfFloat(e){if(e>65504){console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");e=65504}Bc[0]=e;const t=Vc[0];let n=t>>16&32768;let r=t>>12&2047;const i=t>>23&255;if(i<103)return n;if(i>142){n|=31744;n|=(255==i?0:1)&&8388607&t;return n}if(i<113){r|=2048;n|=(r>>114-i)+(r>>113-i&1);return n}n|=i-112<<10|r>>1;n+=1&r;return n}}const Nc=0;const Uc=1;const zc=0;const Gc=1;const Fc=2;function MeshFaceMaterial(e){console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");return e}function MultiMaterial(e=[]){console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");e.isMultiMaterial=true;e.materials=e;e.clone=function(){return e.slice()};return e}function PointCloud(e,t){console.warn("THREE.PointCloud has been renamed to THREE.Points.");return new Points(e,t)}function Particle(e){console.warn("THREE.Particle has been renamed to THREE.Sprite.");return new Sprite(e)}function ParticleSystem(e,t){console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");return new Points(e,t)}function PointCloudMaterial(e){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");return new PointsMaterial(e)}function ParticleBasicMaterial(e){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");return new PointsMaterial(e)}function ParticleSystemMaterial(e){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");return new PointsMaterial(e)}function Vertex(e,t,n){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");return new Vector3(e,t,n)}function DynamicBufferAttribute(e,t){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");return new BufferAttribute(e,t).setUsage(yn)}function Int8Attribute(e,t){console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");return new Int8BufferAttribute(e,t)}function Uint8Attribute(e,t){console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");return new Uint8BufferAttribute(e,t)}function Uint8ClampedAttribute(e,t){console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");return new Uint8ClampedBufferAttribute(e,t)}function Int16Attribute(e,t){console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");return new Int16BufferAttribute(e,t)}function Uint16Attribute(e,t){console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");return new Uint16BufferAttribute(e,t)}function Int32Attribute(e,t){console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");return new Int32BufferAttribute(e,t)}function Uint32Attribute(e,t){console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");return new Uint32BufferAttribute(e,t)}function Float32Attribute(e,t){console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");return new Float32BufferAttribute(e,t)}function Float64Attribute(e,t){console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");return new Float64BufferAttribute(e,t)}Curve.create=function(e,t){console.log("THREE.Curve.create() has been deprecated");e.prototype=Object.create(Curve.prototype);e.prototype.constructor=e;e.prototype.getPoint=t;return e};Path.prototype.fromPoints=function(e){console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");return this.setFromPoints(e)};function AxisHelper(e){console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");return new AxesHelper(e)}function BoundingBoxHelper(e,t){console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");return new BoxHelper(e,t)}function EdgesHelper(e,t){console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");return new LineSegments(new EdgesGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}GridHelper.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};SkeletonHelper.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function WireframeHelper(e,t){console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");return new LineSegments(new WireframeGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}Loader.prototype.extractUrlBase=function(e){console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");return LoaderUtils.extractUrlBase(e)};Loader.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function XHRLoader(e){console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");return new FileLoader(e)}function BinaryTextureLoader(e){console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");return new DataTextureLoader(e)}Box2.prototype.center=function(e){console.warn("THREE.Box2: .center() has been renamed to .getCenter().");return this.getCenter(e)};Box2.prototype.empty=function(){console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");return this.isEmpty()};Box2.prototype.isIntersectionBox=function(e){console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(e)};Box2.prototype.size=function(e){console.warn("THREE.Box2: .size() has been renamed to .getSize().");return this.getSize(e)};Box3.prototype.center=function(e){console.warn("THREE.Box3: .center() has been renamed to .getCenter().");return this.getCenter(e)};Box3.prototype.empty=function(){console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");return this.isEmpty()};Box3.prototype.isIntersectionBox=function(e){console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(e)};Box3.prototype.isIntersectionSphere=function(e){console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(e)};Box3.prototype.size=function(e){console.warn("THREE.Box3: .size() has been renamed to .getSize().");return this.getSize(e)};Sphere.prototype.empty=function(){console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");return this.isEmpty()};Frustum.prototype.setFromMatrix=function(e){console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");return this.setFromProjectionMatrix(e)};Line3.prototype.center=function(e){console.warn("THREE.Line3: .center() has been renamed to .getCenter().");return this.getCenter(e)};Matrix3.prototype.flattenToArrayOffset=function(e,t){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(e,t)};Matrix3.prototype.multiplyVector3=function(e){console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return e.applyMatrix3(this)};Matrix3.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Matrix3.prototype.applyToBufferAttribute=function(e){console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");return e.applyMatrix3(this)};Matrix3.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Matrix3.prototype.getInverse=function(e){console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");return this.copy(e).invert()};Matrix4.prototype.extractPosition=function(e){console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");return this.copyPosition(e)};Matrix4.prototype.flattenToArrayOffset=function(e,t){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(e,t)};Matrix4.prototype.getPosition=function(){console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");return(new Vector3).setFromMatrixColumn(this,3)};Matrix4.prototype.setRotationFromQuaternion=function(e){console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");return this.makeRotationFromQuaternion(e)};Matrix4.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Matrix4.prototype.multiplyVector3=function(e){console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");return e.applyMatrix4(this)};Matrix4.prototype.multiplyVector4=function(e){console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return e.applyMatrix4(this)};Matrix4.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Matrix4.prototype.rotateAxis=function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");e.transformDirection(this)};Matrix4.prototype.crossVector=function(e){console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return e.applyMatrix4(this)};Matrix4.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Matrix4.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Matrix4.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Matrix4.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Matrix4.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Matrix4.prototype.applyToBufferAttribute=function(e){console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");return e.applyMatrix4(this)};Matrix4.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Matrix4.prototype.makeFrustum=function(e,t,n,r,i,s){console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");return this.makePerspective(e,t,r,n,i,s)};Matrix4.prototype.getInverse=function(e){console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");return this.copy(e).invert()};Plane.prototype.isIntersectionLine=function(e){console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");return this.intersectsLine(e)};Quaternion.prototype.multiplyVector3=function(e){console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return e.applyQuaternion(this)};Quaternion.prototype.inverse=function(){console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");return this.invert()};Ray.prototype.isIntersectionBox=function(e){console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(e)};Ray.prototype.isIntersectionPlane=function(e){console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");return this.intersectsPlane(e)};Ray.prototype.isIntersectionSphere=function(e){console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(e)};Triangle.prototype.area=function(){console.warn("THREE.Triangle: .area() has been renamed to .getArea().");return this.getArea()};Triangle.prototype.barycoordFromPoint=function(e,t){console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");return this.getBarycoord(e,t)};Triangle.prototype.midpoint=function(e){console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");return this.getMidpoint(e)};Triangle.prototypenormal=function(e){console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");return this.getNormal(e)};Triangle.prototype.plane=function(e){console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");return this.getPlane(e)};Triangle.barycoordFromPoint=function(e,t,n,r,i){console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");return Triangle.getBarycoord(e,t,n,r,i)};Triangle.normal=function(e,t,n,r){console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");return Triangle.getNormal(e,t,n,r)};Shape.prototype.extractAllPoints=function(e){console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");return this.extractPoints(e)};Shape.prototype.extrude=function(e){console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");return new ExtrudeGeometry(this,e)};Shape.prototype.makeGeometry=function(e){console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");return new ShapeGeometry(this,e)};Vector2.prototype.fromAttribute=function(e,t,n){console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(e,t,n)};Vector2.prototype.distanceToManhattan=function(e){console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");return this.manhattanDistanceTo(e)};Vector2.prototype.lengthManhattan=function(){console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()};Vector3.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};Vector3.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};Vector3.prototype.getPositionFromMatrix=function(e){console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");return this.setFromMatrixPosition(e)};Vector3.prototype.getScaleFromMatrix=function(e){console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");return this.setFromMatrixScale(e)};Vector3.prototype.getColumnFromMatrix=function(e,t){console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");return this.setFromMatrixColumn(t,e)};Vector3.prototype.applyProjection=function(e){console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");return this.applyMatrix4(e)};Vector3.prototype.fromAttribute=function(e,t,n){console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(e,t,n)};Vector3.prototype.distanceToManhattan=function(e){console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");return this.manhattanDistanceTo(e)};Vector3.prototype.lengthManhattan=function(){console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()};Vector4.prototype.fromAttribute=function(e,t,n){console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(e,t,n)};Vector4.prototype.lengthManhattan=function(){console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()};Object3D.prototype.getChildByName=function(e){console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(e)};Object3D.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Object3D.prototype.translate=function(e,t){console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");return this.translateOnAxis(t,e)};Object3D.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Object3D.prototype.applyMatrix=function(e){console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");return this.applyMatrix4(e)};Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");return this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Mesh.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Mesh.prototype,{drawMode:{get:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");return Wt},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});SkinnedMesh.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};PerspectiveCamera.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");void 0!==t&&(this.filmGauge=t);this.setFocalLength(e)};Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias.");this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");this.shadow.mapSize.height=e}}});Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");return this.array.length}},dynamic:{get:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");return this.usage===yn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");this.setUsage(yn)}}});BufferAttribute.prototype.setDynamic=function(e){console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");this.setUsage(true===e?yn:gn);return this};BufferAttribute.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},BufferAttribute.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};BufferGeometry.prototype.addIndex=function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");this.setIndex(e)};BufferGeometry.prototype.addAttribute=function(e,t){console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");if(!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)){console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");return this.setAttribute(e,new BufferAttribute(arguments[1],arguments[2]))}if("index"===e){console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");this.setIndex(t);return this}return this.setAttribute(e,t)};BufferGeometry.prototype.addDrawCall=function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");this.addGroup(e,t)};BufferGeometry.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");this.clearGroups()};BufferGeometry.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};BufferGeometry.prototype.removeAttribute=function(e){console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");return this.deleteAttribute(e)};BufferGeometry.prototype.applyMatrix=function(e){console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");return this.applyMatrix4(e)};Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");return this.groups}},offsets:{get:function(){console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");return this.groups}}});InterleavedBuffer.prototype.setDynamic=function(e){console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");this.setUsage(true===e?yn:gn);return this};InterleavedBuffer.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ExtrudeGeometry.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};ExtrudeGeometry.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};ExtrudeGeometry.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Scene.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Uniform.prototype.onUpdate=function(){console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");return this};Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){console.warn("THREE.Material: .wrapRGB has been removed.");return new Color}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.");this.flatShading=e===f}},stencilMask:{get:function(){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead.");return this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead.");this.stencilFuncMask=e}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");return this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");this.extensions.derivatives=e}}});WebGLRenderer.prototype.clearTarget=function(e,t,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");this.setRenderTarget(e);this.clear(t,n,r)};WebGLRenderer.prototype.animate=function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");this.setAnimationLoop(e)};WebGLRenderer.prototype.getCurrentRenderTarget=function(){console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");return this.getRenderTarget()};WebGLRenderer.prototype.getMaxAnisotropy=function(){console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");return this.capabilities.getMaxAnisotropy()};WebGLRenderer.prototype.getPrecision=function(){console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");return this.capabilities.precision};WebGLRenderer.prototype.resetGLState=function(){console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");return this.state.reset()};WebGLRenderer.prototype.supportsFloatTextures=function(){console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");return this.extensions.get("OES_texture_float")};WebGLRenderer.prototype.supportsHalfFloatTextures=function(){console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");return this.extensions.get("OES_texture_half_float")};WebGLRenderer.prototype.supportsStandardDerivatives=function(){console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");return this.extensions.get("OES_standard_derivatives")};WebGLRenderer.prototype.supportsCompressedTextureS3TC=function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");return this.extensions.get("WEBGL_compressed_texture_s3tc")};WebGLRenderer.prototype.supportsCompressedTexturePVRTC=function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");return this.extensions.get("WEBGL_compressed_texture_pvrtc")};WebGLRenderer.prototype.supportsBlendMinMax=function(){console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");return this.extensions.get("EXT_blend_minmax")};WebGLRenderer.prototype.supportsVertexTextures=function(){console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");return this.capabilities.vertexTextures};WebGLRenderer.prototype.supportsInstancedArrays=function(){console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");return this.extensions.get("ANGLE_instanced_arrays")};WebGLRenderer.prototype.enableScissorTest=function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");this.setScissorTest(e)};WebGLRenderer.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};WebGLRenderer.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};WebGLRenderer.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};WebGLRenderer.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};WebGLRenderer.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};WebGLRenderer.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};WebGLRenderer.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};WebGLRenderer.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};WebGLRenderer.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};WebGLRenderer.prototype.getActiveMipMapLevel=function(){console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");return this.getActiveMipmapLevel()};Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");return this.getContext()}},vr:{get:function(){console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");return this.xr}},gammaInput:{get:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");return false},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");return false},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");this.outputEncoding=true===e?Jt:Xt}},toneMappingWhitePoint:{get:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");return 1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");return 2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function WebGLRenderTargetCube(e,t,n){console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");return new WebGLCubeRenderTarget(e,n)}Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");return this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");this.texture.wrapS=e}},wrapT:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");return this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");this.texture.wrapT=e}},magFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");return this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");this.texture.magFilter=e}},minFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");return this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");this.texture.minFilter=e}},anisotropy:{get:function(){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");return this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");this.texture.anisotropy=e}},offset:{get:function(){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");return this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");this.texture.offset=e}},repeat:{get:function(){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");return this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");this.texture.repeat=e}},format:{get:function(){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");return this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");this.texture.format=e}},type:{get:function(){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");return this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");this.texture.type=e}},generateMipmaps:{get:function(){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");return this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");this.texture.generateMipmaps=e}}});Audio.prototype.load=function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;const n=new AudioLoader;n.load(e,(function(e){t.setBuffer(e)}));return this};AudioAnalyser.prototype.getData=function(){console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");return this.getFrequencyData()};CubeCamera.prototype.updateCubeMap=function(e,t){console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");return this.update(e,t)};CubeCamera.prototype.clear=function(e,t,n,r){console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");return this.renderTarget.clear(e,t,n,r)};ImageUtils.crossOrigin=void 0;ImageUtils.loadTexture=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new TextureLoader;i.setCrossOrigin(this.crossOrigin);const s=i.load(e,n,void 0,r);t&&(s.mapping=t);return s};ImageUtils.loadTextureCube=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new CubeTextureLoader;i.setCrossOrigin(this.crossOrigin);const s=i.load(e,n,void 0,r);t&&(s.mapping=t);return s};ImageUtils.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};ImageUtils.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function CanvasRenderer(){console.error("THREE.CanvasRenderer has been removed")}function JSONLoader(){console.error("THREE.JSONLoader has been removed.")}const Oc={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function LensFlare(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}function ParametricGeometry(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");return new BufferGeometry}function TextGeometry(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");return new BufferGeometry}function FontLoader(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function Font(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function ImmediateRenderObject(){console.error("THREE.ImmediateRenderObject has been removed.")}"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:e}}));"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=e);export{ee as ACESFilmicToneMapping,w as AddEquation,Y as AddOperation,kt as AdditiveAnimationBlendMode,x as AdditiveBlending,Be as AlphaFormat,F as AlwaysDepth,mn as AlwaysStencilFunc,AmbientLight,AmbientLightProbe,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,Dl as AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,Audio,AudioAnalyser,Xl as AudioContext,AudioListener,AudioLoader,AxesHelper,AxisHelper,d as BackSide,Yt as BasicDepthPacking,o as BasicShadowMap,BinaryTextureLoader,Bone,BooleanKeyframeTrack,BoundingBoxHelper,Box2,Box3,Box3Helper,BoxGeometry as BoxBufferGeometry,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,we as ByteType,Bl as Cache,Camera,CameraHelper,CanvasRenderer,CanvasTexture,CatmullRomCurve3,$ as CineonToneMapping,CircleGeometry as CircleBufferGeometry,CircleGeometry,ue as ClampToEdgeWrapping,Clock,Color,ColorKeyframeTrack,CompressedTexture,CompressedTextureLoader,ConeGeometry as ConeBufferGeometry,ConeGeometry,CubeCamera,re as CubeReflectionMapping,ie as CubeRefractionMapping,CubeTexture,CubeTextureLoader,oe as CubeUVReflectionMapping,le as CubeUVRefractionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,i as CullFaceBack,s as CullFaceFront,a as CullFaceFrontBack,r as CullFaceNone,Curve,CurvePath,M as CustomBlending,te as CustomToneMapping,CylinderGeometry as CylinderBufferGeometry,CylinderGeometry,Cylindrical,DataTexture,DataTexture2DArray,DataTexture3D,DataTextureLoader,DataUtils,rn as DecrementStencilOp,an as DecrementWrapStencilOp,Vl as DefaultLoadingManager,Ge as DepthFormat,Fe as DepthStencilFormat,DepthTexture,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DodecahedronGeometry as DodecahedronBufferGeometry,DodecahedronGeometry,p as DoubleSide,B as DstAlphaFactor,N as DstColorFactor,DynamicBufferAttribute,wn as DynamicCopyUsage,yn as DynamicDrawUsage,bn as DynamicReadUsage,EdgesGeometry,EdgesHelper,EllipseCurve,k as EqualDepth,un as EqualStencilFunc,se as EquirectangularReflectionMapping,ae as EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry as ExtrudeBufferGeometry,ExtrudeGeometry,Gc as FaceColors,FileLoader,f as FlatShading,Float16BufferAttribute,Float32Attribute,Float32BufferAttribute,Float64Attribute,Float64BufferAttribute,Le as FloatType,Fog,FogExp2,Font,FontLoader,FramebufferTexture,h as FrontSide,Frustum,GLBufferAttribute,Tn as GLSL1,En as GLSL3,j as GreaterDepth,W as GreaterEqualDepth,fn as GreaterEqualStencilFunc,dn as GreaterStencilFunc,GridHelper,Group,Ce as HalfFloatType,HemisphereLight,HemisphereLightHelper,HemisphereLightProbe,IcosahedronGeometry as IcosahedronBufferGeometry,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,ImmediateRenderObject,nn as IncrementStencilOp,sn as IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16Attribute,Int16BufferAttribute,Int32Attribute,Int32BufferAttribute,Int8Attribute,Int8BufferAttribute,Ee as IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,Nt as InterpolateDiscrete,Ut as InterpolateLinear,zt as InterpolateSmooth,on as InvertStencilOp,JSONLoader,en as KeepStencilOp,KeyframeTrack,LOD,LatheGeometry as LatheBufferGeometry,LatheGeometry,Layers,LensFlare,O as LessDepth,H as LessEqualDepth,hn as LessEqualStencilFunc,cn as LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,Uc as LinePieces,LineSegments,Nc as LineStrip,Xt as LinearEncoding,ye as LinearFilter,LinearInterpolant,_e as LinearMipMapLinearFilter,xe as LinearMipMapNearestFilter,be as LinearMipmapLinearFilter,ve as LinearMipmapNearestFilter,Q as LinearToneMapping,Loader,LoaderUtils,LoadingManager,Dt as LoopOnce,Vt as LoopPingPong,Bt as LoopRepeat,ze as LuminanceAlphaFormat,Ue as LuminanceFormat,t as MOUSE,Material,MaterialLoader,Pn as Math,Pn as MathUtils,Matrix3,Matrix4,A as MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshFaceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,E as MinEquation,he as MirroredRepeatWrapping,J as MixOperation,MultiMaterial,_ as MultiplyBlending,X as MultiplyOperation,de as NearestFilter,ge as NearestMipMapLinearFilter,fe as NearestMipMapNearestFilter,me as NearestMipmapLinearFilter,pe as NearestMipmapNearestFilter,G as NeverDepth,ln as NeverStencilFunc,g as NoBlending,zc as NoColors,Z as NoToneMapping,Ht as NormalAnimationBlendMode,y as NormalBlending,q as NotEqualDepth,pn as NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,Kt as ObjectSpaceNormalMap,OctahedronGeometry as OctahedronBufferGeometry,OctahedronGeometry,C as OneFactor,V as OneMinusDstAlphaFactor,U as OneMinusDstColorFactor,D as OneMinusSrcAlphaFactor,P as OneMinusSrcColorFactor,OrthographicCamera,l as PCFShadowMap,c as PCFSoftShadowMap,PMREMGenerator,ParametricGeometry,Particle,ParticleBasicMaterial,ParticleSystem,ParticleSystemMaterial,Path,PerspectiveCamera,Plane,PlaneGeometry as PlaneBufferGeometry,PlaneGeometry,PlaneHelper,PointCloud,PointCloudMaterial,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry as PolyhedronBufferGeometry,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,e as REVISION,Zt as RGBADepthPacking,Ne as RGBAFormat,qe as RGBAIntegerFormat,mt as RGBA_ASTC_10x10_Format,dt as RGBA_ASTC_10x5_Format,pt as RGBA_ASTC_10x6_Format,ft as RGBA_ASTC_10x8_Format,gt as RGBA_ASTC_12x10_Format,yt as RGBA_ASTC_12x12_Format,it as RGBA_ASTC_4x4_Format,st as RGBA_ASTC_5x4_Format,at as RGBA_ASTC_5x5_Format,ot as RGBA_ASTC_6x5_Format,lt as RGBA_ASTC_6x6_Format,ct as RGBA_ASTC_8x5_Format,ut as RGBA_ASTC_8x6_Format,ht as RGBA_ASTC_8x8_Format,vt as RGBA_BPTC_Format,rt as RGBA_ETC2_EAC_Format,et as RGBA_PVRTC_2BPPV1_Format,$e as RGBA_PVRTC_4BPPV1_Format,Je as RGBA_S3TC_DXT1_Format,Ye as RGBA_S3TC_DXT3_Format,Ze as RGBA_S3TC_DXT5_Format,Ve as RGBFormat,je as RGBIntegerFormat,tt as RGB_ETC1_Format,nt as RGB_ETC2_Format,Ke as RGB_PVRTC_2BPPV1_Format,Qe as RGB_PVRTC_4BPPV1_Format,Xe as RGB_S3TC_DXT1_Format,ke as RGFormat,We as RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,RectAreaLight,Oe as RedFormat,He as RedIntegerFormat,K as ReinhardToneMapping,ce as RepeatWrapping,tn as ReplaceStencilOp,T as ReverseSubtractEquation,RingGeometry as RingBufferGeometry,RingGeometry,Rt as SRGB8_ALPHA8_ASTC_10x10_Format,At as SRGB8_ALPHA8_ASTC_10x5_Format,Lt as SRGB8_ALPHA8_ASTC_10x6_Format,Ct as SRGB8_ALPHA8_ASTC_10x8_Format,Pt as SRGB8_ALPHA8_ASTC_12x10_Format,It as SRGB8_ALPHA8_ASTC_12x12_Format,xt as SRGB8_ALPHA8_ASTC_4x4_Format,bt as SRGB8_ALPHA8_ASTC_5x4_Format,_t as SRGB8_ALPHA8_ASTC_5x5_Format,Mt as SRGB8_ALPHA8_ASTC_6x5_Format,wt as SRGB8_ALPHA8_ASTC_6x6_Format,St as SRGB8_ALPHA8_ASTC_8x5_Format,Tt as SRGB8_ALPHA8_ASTC_8x6_Format,Et as SRGB8_ALPHA8_ASTC_8x8_Format,Scene,Oc as SceneUtils,Qa as ShaderChunk,$a as ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry as ShapeBufferGeometry,ShapeGeometry,ShapePath,ShapeUtils,Se as ShortType,Skeleton,SkeletonHelper,SkinnedMesh,m as SmoothShading,Sphere,SphereGeometry as SphereBufferGeometry,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,I as SrcAlphaFactor,z as SrcAlphaSaturateFactor,R as SrcColorFactor,Mn as StaticCopyUsage,gn as StaticDrawUsage,xn as StaticReadUsage,StereoCamera,Sn as StreamCopyUsage,vn as StreamDrawUsage,_n as StreamReadUsage,StringKeyframeTrack,S as SubtractEquation,b as SubtractiveBlending,n as TOUCH,Qt as TangentSpaceNormalMap,TetrahedronGeometry as TetrahedronBufferGeometry,TetrahedronGeometry,TextGeometry,Texture,TextureLoader,TorusGeometry as TorusBufferGeometry,TorusGeometry,TorusKnotGeometry as TorusKnotBufferGeometry,TorusKnotGeometry,Triangle,qt as TriangleFanDrawMode,jt as TriangleStripDrawMode,Wt as TrianglesDrawMode,TubeGeometry as TubeBufferGeometry,TubeGeometry,ne as UVMapping,Uint16Attribute,Uint16BufferAttribute,Uint32Attribute,Uint32BufferAttribute,Uint8Attribute,Uint8BufferAttribute,Uint8ClampedAttribute,Uint8ClampedBufferAttribute,Uniform,Ka as UniformsLib,mi as UniformsUtils,Me as UnsignedByteType,De as UnsignedInt248Type,Ae as UnsignedIntType,Re as UnsignedShort4444Type,Pe as UnsignedShort5551Type,Ie as UnsignedShort565Type,Te as UnsignedShortType,u as VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,Vertex,Fc as VertexColors,VideoTexture,WebGL1Renderer,WebGLCubeRenderTarget,WebGLMultipleRenderTargets,WebGLMultisampleRenderTarget,WebGLRenderTarget,WebGLRenderTargetCube,WebGLRenderer,WebGLUtils,WireframeGeometry,WireframeHelper,Ot as WrapAroundEnding,XHRLoader,Gt as ZeroCurvatureEnding,L as ZeroFactor,Ft as ZeroSlopeEnding,$t as ZeroStencilOp,Jt as sRGBEncoding};

//# sourceMappingURL=three.module.js.map